# 置换环

## 问题：一个序列变成变成递增次序所需的最小交换次数

## 解决：置换环的解决

## 参考：

[Codeforces Round #842 (Div. 2) D(置换环) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/596949353)

[Codeforces Round #842 (Div. 2)_欧阳小百合的博客-CSDN博客](https://blog.csdn.net/weixin_45849398/article/details/128676894)

## 板子：

```C++
int fa[maxj];//记录并查集
int num[maxj];
void init(int n){
    for(int i=0;i<=n+1;++i){
        fa[i]=i;
        num[i]=1;
    }
}
int find(int x){//find函数
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
void uni(int x,int y){//合并函数
    int now=find(x),ff=find(y);
    if(now!=ff){
        fa[now]=ff;
        num[ff]+=num[now];//合并交换次数
    }
}
void solve()
{
	//置换环，有固定的板子,我选择并查集的实现方式
    int n;cin>>n;
    init(n);
    for(int i=1;i<=n;++i){
        int x;cin>>x;
        uni(x,i);
    }
    int dd=1;
    for(int i=1;i<n;++i){
        if(find(i)==find(i+1))dd=-1;
      //这个问题有一步是判断是否有相邻数在同一环中，若有减少一次交换，若没有则多一次交换
    }
    int ans=0;//记录变成递增次序的最小次数交换
    for(int i=1;i<=n;++i){
        if(find(i)==i){//总的父亲节点
            ans+=num[i]-1;
        }
    }
    cout<<ans+dd<<'\n';
}   
```

## 题：

[Problem - D - Codeforces](https://codeforces.com/contest/1768/problem/D)

