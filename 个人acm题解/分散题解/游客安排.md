# 游客安排

涉及知识点：（最长上升子序列+动态规划+二分贪心）

## 题目大意

### 题目描述

题目链接：[P8736 [蓝桥杯 2020 国 B\] 游园安排 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P8736)

L 星球游乐园非常有趣，吸引着各个星球的游客前来游玩。小蓝是 L 星球 游乐园的管理员。

为了更好的管理游乐园，游乐园要求所有的游客提前预约，小蓝能看到系统上所有预约游客的名字。每个游客的名字由一个大写英文字母开始，后面跟 0 个或多个小写英文字母。游客可能重名。

小蓝特别喜欢递增的事物。今天，他决定在所有预约的游客中，选择一部分游客在上午游玩，其他的游客都在下午游玩，在上午游玩的游客**要求按照预约的顺序排列后，名字是单调递增的，即排在前面的名字严格小于排在后面的名字。**

一个名字 A 小于另一个名字 B 是指：存在一个整数 i，使得 AA 的前 i 个字母与 B 的前 i 个字母相同，且 A 的第 i+1个字母小于 BB 的第 i+1 个字母。(如果 A 不存在第i+1 个字母且 B 存在第i+1 个字母, 也视为 A 的第i+1 个字母小于 B 的第i+1 个字母)

作为小蓝的助手，你要按照小蓝的想法安排游客，同时你又希望上午有**尽量多的游客**游玩，请告诉小蓝让哪些游客上午游玩。如果方案有多种，请输出上午游玩的第一个游客名字最小的方案。如果此时还有多种方案，请输出第一个游客名字最小的前提下第二个游客名字最小的方案。如果仍然有多种，依此类推选择第三个、第四个……游客名字最小的方案。

### 输入格式

输入包含一个字符串，按预约的顺序给出所有游客的名字，相邻的游客名字之间没有字符分隔。

### 输出格式

按预约顺序输出上午游玩的游客名单，中间不加任何分隔字符。

### 输入输出样例

输入 #1

```
WoAiLanQiaobei
```

输出 #1

```
AiLanQiaobei
```

### 说明/提示

对于 20% 的评测数据, 输入的总长度不超过20 个字母。

对于 50% 的评测数据, 输入的总长度不超过 300 个字母。

对于 70% 的评测数据, 输入的总长度不超过 10000 个字母。

对于所有评测数据, 每个名字的长度不超过 10 个字母, 输入的总长度不超过 10^6个字母。

蓝桥杯 2020 年国赛 B 组 G 题。

## 题解

参考：[第十一届蓝桥杯-游园安排_一个老蒟蒻的博客-CSDN博客](https://blog.csdn.net/qq_30347475/article/details/117395573)

最长上升子序列：[最长上升子序列 (LIS) 详解+例题模板 (全)_lxt_Lucia的博客-CSDN博客_最长上升子序列](https://blog.csdn.net/lxt_Lucia/article/details/81206439)

**解析**
    题目我看了很久，第一次做的时候以为是一道简单的排序题，可是怎么都输出不对，后来看了别人的题解才知道，这道题的本质是最长上升子序列，于是自己也想了一想，确实如此，不然你怎么能确定上午安排人的人数呢？


​    **什么是最长上升子序列？**

​    就是在一段字符中，取出某几个字符组成一个字符串，这个字符串的每一个字符都大于左边字符并且小于右边的字符，那么这个字符串就是上升序列，也就是说类似于函数中的单调递增的概念，就比如说abtxz这就是一个上升序列，那么最长上升子序列就是指一个字符串中的子序列中，最长的那个上升子序列


​	但是呢，这一题又有点不一样，这是最长上升字典序的问题，就是将一个字符串的人名所组成的字典作为字符，取最长的上升子序列，简单点说，就是将最长上升子序列中的字符改成人名组成的字符串进行组合就行了，那么就很好理解了，看了下样例输出，果然如此。

​	**方法：动态规划优化-二分加贪心**
​	二分其实没啥，就是为了寻找某个元素，而且是直接使用lower_bound来查找的，所以没什么困难的地方，这里的重点在于贪心，下面讲讲贪心的思路

​	首先将所有人序列取出存储到数组中后，先将第一个序列入队，遍历剩下所有序列，如果说碰见比队尾大的序列就直接入队，否则，也就是当前序列并不小于队尾序列的话，那么就用其代替掉队列中比其大的第一个序列（这是贪心思想，待会解释），并要更新一下当前情况下所能组成的最大单调子序列，将其入队

​	运用贪心的思想，我们就能很容易确定最长上升子序列的长度，因为碰见大的就插入，碰见小的就替换，那么整各队列的长度最终一定会是最长上升序列的长度

​	最后，我们从num开始往前遍历，和动态规划的回溯一样,这里就不解释了

​	值得一说的是，这里使用动态数组主要是为了防止超内存


```C++
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;

int num;
string s;
string v[N];
vector<string> endd;
vector<int> f;

int main()
{
	cin>>s;
	for(int i=0;i<s.length();i++)
	{
		if(s[i]>='A'&&s[i]<='Z')
		{
			if(i!=0)
				num++;
			v[num]="";
			v[num]+=s[i];
		}
		else
		{
			v[num]+=s[i];
		}
	}
	endd.push_back(v[0]);
	f.push_back(1);
	for(int i=1;i<=num;i++)	//遍历到最后一个子字符串数组元素 
	{
		if(v[i]>endd.back())	//如果当前end中的字符串能构成上升序列 
		{
			endd.push_back(v[i]);	//则将当前子字符串入队 
			f.push_back(endd.size());	//那么当前动态数组的长度就是当前上升序列的长度 
		}
		else 
		{   //下面是贪心做法 
			//如果不能构成单调上升序列
			int pos=lower_bound(endd.begin(),endd.end(),v[i])-endd.begin();	
			//找到大于等于序列v[i]的第一个元素的位置 
				 
			endd[pos]=v[i];	//将这个元素替换为v[i]（这个可能不好理解，下面会说的） 
			f.push_back(pos+1);
			//更新一下，那么当前的上升序列的长度就是pos+1（因为0-pos是单调上升的，加上0这个首元素所以是pos+1) 
		}
	}
	string k[N];	//用字符串连接会超时 
  	int cnt=0;
	for(int i=num,m=endd.size();m>0;i--)	//类似动态规划将结果逆序输出
	 {
		if(f[i]==m)	
		{	
			k[cnt++]=v[i];
			m--;
		}
	}
  	for(int i=cnt-1;i>=0;i--) cout<<k[i];
	return 0;
}

```

```
现在来说一下贪心的思路

首先我们上面说了，我们只要碰到比尾部小的元素就更换队列内的元素，否则就加入队尾，这种贪心思想其实就是方法一中的动态规划思想求出最长子序列的方法，f一样存储的是每个子序列的最长上升子序列的长度，所以说，不要这样想：我这样遍历不是动态数组里面的顺序都是乱的吗？那我到时候怎么输出啊，不不不，这种贪心只是为了能够用上二分法来对时间复杂度进行优化，他的本质还是动态规划，二分+贪心只是为了解决方法一中的嵌套循环的问题，使时间复杂度降低到 O(NlogN)
```

一个问题：最长非降序子序列如何寻找

另外，在做题时，要用全局变量开数组，也不要用vector，因为要开双倍空间

```
string ans[maxj];
string ve[maxj];//以字符串为单位
vector<string>ed;//记录答案序列
vector<int>f;
```

AC代码：

```c++
string ans[maxj];
string ve[maxj];//以字符串为单位
vector<string>ed;//记录答案序列
vector<int>f;
void solve(){
    string s;
    cin>>s;
    int num=0;
    for(int i=0;i<s.size();){
        string now="";
        now+=s[i];
        int j;
        for(j=i+1;j<s.size();++j){
            if(s[j]>='A'&&s[j]<='Z')break;
            now+=s[j];
            
        }
        // cout<<now<<' ';
        ve[num++]=now;
        i=j;
    }
    int cnt=0;
    ed.emplace_back(ve[0]);
    f.emplace_back(1);//记录大小
    for(int i=1;i<num;++i){
        if(ve[i]>ed.back()){
            ed.emplace_back(ve[i]);
            f.emplace_back(ed.size());
        }else{//贪心+二分
            int pos=lower_bound(ed.begin(),ed.end(),ve[i])-ed.begin();
            ed[pos]=ve[i];
            f.emplace_back(pos+1);
        }
    }
    
    cnt=0;
    for(int i=num,m=ed.size();m>=0;--i){
        if(f[i]==m){
            m--;
            ans[++cnt]=ve[i];
        }
    }
    for(int i=cnt;i>=1;--i)cout<<ans[i];cout<<'\n';
}   
```

