# 字符串

## 一、后缀数组

### 概述

​     字符串从1开始sa[i]表示将所有后缀排序后第  i 小的后缀的编号，也是所说的后缀数组，后文也称编号数组 sa ；

​      rk[i]表示后缀  i 的排名，是重要的辅助数组，后文也称排名数组 rk 这两个数组满足性质：sa[rk[i]]=rk[sa[i]]=i

### 板子

应该是nlog

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxj = 1e6 + 100, MOD = 1e9 + 7, inf = 0x3f3f3f3f;
int sa[maxj], x[maxj], y[maxj], c[maxj], rk[maxj], height[maxj];
int n,m;
string s;
void get_sa()
{
    for (int i = 1; i <= n; i++)
        c[x[i] = s[i]]++;
    for (int i = 2; i <= m; i++)
        c[i] += c[i - 1];
    for (int i = n; i; i--)
        sa[c[x[i]]--] = i;
    for (int k = 1; k <= n; k <<= 1)
    {
        int num = 0;
        for (int i = n - k + 1; i <= n; i++)
            y[++num] = i;
        for (int i = 1; i <= n; i++)
            if (sa[i] > k)
                y[++num] = sa[i] - k;
        for (int i = 1; i <= m; i++)
            c[i] = 0;
        for (int i = 1; i <= n; i++)
            c[x[i]]++;
        for (int i = 2; i <= m; i++)
            c[i] += c[i - 1];
        for (int i = n; i; i--)
            sa[c[x[y[i]]]--] = y[i], y[i] = 0;
        swap(x, y);
        x[sa[1]] = 1, num = 1;
        for (int i = 2; i <= n; i++)
            x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++num;
            if (num == n) break;
        m = num;
    }
}
void get_height()
{
    for (int i = 1; i <= n; i++)
        rk[sa[i]] = i;
    for (int i = 1, k = 0; i <= n; i++)
    {
        if (rk[i] == 1)
            continue;
        if (k)
            k--;
        int j = sa[rk[i] - 1];
        while (i + k <= n && j + k <= n && s[i + k] == s[j + k])
            k++;
        height[rk[i]] = k;
    }
}int k;
bool check(int x){
    if(sa[x]>k&&sa[x-1]<k)return 1;
    if(sa[x-1]>k&&sa[x]<k)return 1;
    return 0;
}
void solve()
{
    //不是马拉车算法，马拉车算法是最长回文子串
    //在符合条件的子串中选最大的height，lcp
    string s1, s2;
    cin >> s1 >> s2;
    k=s1.size()+1;//恰好是分隔符的位置
    s=' '+s1+'@'+s2;
    n=s.size()-1;
    m=127;
    get_sa();
    get_height();
    int mn=min(s1.size(),s2.size());
    int ans=0;
    for(int i=1;i<=n;++i){
        if(check(i))ans=max(ans,height[i]);
    }
    cout<<ans<<'\n';
}
signed main()
{
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout); // a为add,,w
#endif
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t;
    t = 1;
    //     cin>>t;
    while (t--)
        solve();
    return 0;
}
//后缀数组在于对sa，rk，height 的理解和应用，尤其是height数组lcp
//尤其是height数组的运用，而且大部分题都和“相同子串”这个问题有关，并且有其他数据结构的加入
//https://ac.nowcoder.com/acm/contest/50135/D
//https://ac.nowcoder.com/acm/contest/50135/I   并查集+后缀数组，
```

## 二、字符hash

### 板子

```
ull h[maxj],p[maxj];
char str[maxj];
ull get(int l,int r){
    return h[r]-h[l-1] * p[r-l+1];
}
signed main()
{
    int n,m;cin>>n>>m;
    cin>>n>>m;
    cin>>str+1;
    p[0]=1;
    for(int i=1;i<=n;++i){
        p[i]=p[i-1]*P;
        h[i]=h[i-1]*P+str[i];
    }
    while(m--){
        int l1,r1,l2,r2;
        cin>>l1>>r1>>l2>>r2;
        if(get(l1,r1)==get(l2,r2))cout<<"YES"<<'\n';
        else cout<<"NO"<<'\n';
    }
    return 0;
}
//https://ac.nowcoder.com/acm/contest/50135/L
```



## 三、Manacher

### 概述

求最长回文子串的长度是多少

复杂度为O（n），s的空间是原空间的二倍

[P4555 [国家集训队\] 最长双回文串 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4555)

[Problem - 7326 (hdu.edu.cn)](https://acm.hdu.edu.cn/showproblem.php?pid=7326)



### 板子

```
char a[maxj],b[maxj<<1];
int p[maxj<<1];//记录每个对应位置的回文半径，注意是变换后的串,半径减1是回文长度
//
int n;
//将长度变换成奇数
void init(){
    int k=0;
    b[k++]='$';
    b[k++]='#';
    for(int i=0;i<n;++i){
        b[k++]=a[i];
        b[k++]='#';
    }
    b[k++]='^';
    n=k;
}
//执行马拉车算法,可以求最长回文长度，
void manacher(){
    //右边界都采用开区间,所以是mr-i
    int mr=0,mid;
    for(int i=1;i<n;++i){
        //根据分析，最长回文内部选最小
        if(i<mr) p[i]=min(p[2*mid-i],mr-i);
        else p[i]=1;
        
        //进行扩展，算自己了
        while(b[i-p[i]]==b[i+p[i]])p[i]++;
        
        //更新最大回文区间
        if(i+p[i]>mr){
            mr=i+p[i];
            mid=i;
        }
    }
}
```



## 四、后缀自动机

### 后缀自动机概述

**后缀自动机**(suffix automaton, SAM) 是一个能解决许多字符串相关问题的有力的数据结构。

举个例子，以下的字符串问题都可以在线性时间内通过 SAM 解决。

- 在另一个字符串中搜索一个字符串的所有出现位置。
- 计算给定的字符串中有多少个不同的子串。

直观上，字符串的 SAM 可以理解为给定字符串的 **所有子串** 的压缩形式。值得注意的事实是，SAM 将所有的这些信息以高度压缩的形式储存。对于一个长度为 [n]的字符串，它的空间复杂度仅为 [O(n)]此外，构造 SAM 的时间复杂度仅为 [O(n)]准确地说，一个 SAM 最多有 [2n-1]个节点和 [3n-4]条转移边。

### 板子

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 100005;
int siz, last, n, ans;
//
struct hou
{
  struct Suffix_Automaton
  {
    int len, link; // len记载SAM[cur].len,这个状态的最长长度，SAM[SAM[cur].link].len记载以cur为结尾的最短len-1
    std::map<int, int> nxt;
  } SAM[maxn << 1]; // 开两倍大小的空间

  int SAM_extend(int c)
  {
    int cur = ++siz;
    SAM[cur].len = SAM[last].len + 1;
    int p = last;
    while (p != -1 && !SAM[p].nxt.count(c))
    {
      SAM[p].nxt[c] = cur;
      p = SAM[p].link;
    }
    if (p == -1)
      SAM[cur].link = 0;
    else
    {
      int q = SAM[p].nxt[c];
      if (SAM[q].len == SAM[p].len + 1)
        SAM[cur].link = q;
      else
      {
        int copy = ++siz;
        SAM[copy].len = SAM[p].len + 1;
        SAM[copy].link = SAM[q].link;
        SAM[copy].nxt = SAM[q].nxt;
        while (p != -1 && SAM[p].nxt.count(c))
        {
          if (SAM[p].nxt[c] == q)
            SAM[p].nxt[c] = copy, p = SAM[p].link;
          else
            break;
        }
        SAM[q].link = SAM[cur].link = copy;
      }
    }
    last = cur;
    return SAM[cur].len - SAM[SAM[cur].link].len; // 最长减最短是不同字串的个数
  }
} h;

signed main()
{
  cin >> n;
  h.SAM[0].link = -1;//开始初始化
  for (int i = 1, q; i <= n; ++i)
  {
    cin >> q;
    ans += h.SAM_extend(q);
    cout << ans << '\n';
  }
  return 0;
}
// 参考文章:https://www.cnblogs.com/zaza-zt/p/15419181.html
// https://ac.nowcoder.com/acm/contest/50135/H
```

## 五、trie树

```
#include <bits/stdc++.h>
using namespace std;
// #define int long long
const int maxj = 1e5 + 100;
struct Trie
{
    int son[maxj*27][27]={0};//阿拉伯字母，所以第一维几个*层数 ，第二维数据范围
    int idx=0;
    int cnt[maxj*27];
    void insert(string str)
    {
        int p = 0; // 类似指针，指向当前节点
        for (int i = 0; str[i]; i++)
        {
            int u = str[i] - 'a'; // 将字母转化为数字
            if (!son[p][u])
                son[p][u] = ++idx;
            // 该节点不存在，创建节点,其值为下一个节点位置
            p = son[p][u]; // 使“p指针”指向下一个节点位置
        }
        cnt[p]++; // 结束时的标记，也是记录以此节点结束的字符串个数
    }
    int query(string str)
    {
        int p = 0;
        for (int i = 0; str[i]; i++)
        {
            int u = str[i] - 'a';
            if (!son[p][u])
                return 0; // 该节点不存在，即该字符串不存在
            p = son[p][u];
        }
        return cnt[p]; // 返回字符串出现的次数
    }
}tt;
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout); // a为add,,w
#endif
    string ss;cin>>ss;
    tt.insert(ss);
    if(tt.query("asd"))cout<<"1"<<'\n';
    else cout<<"0"<<'\n';
    return 0;
}
//https://ac.nowcoder.com/acm/contest/50135/E
//这个题别卡了好久的数据类型，开大了内存超限，开小了过不去
//https://codeforces.com/contest/1792/problem/D
//这个板子，好像每次时间和空间都很紧张
//https://codeforces.com/contest/557/problem/E
//半回文子串+dp+字典树的特殊处理
```

## 六、kmp

kmp处理循环节在分散题单里有解释

kmp可以统计循环节，统计某一字符串前缀在另一字符串中子串出现情况

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxj = 2e6 + 10, MOD = 998244353, inf = 0x3f3f3f3f;
string s[maxj];
string mn;
int len = inf;
int nex[maxj]; // 需要一个kmp的板子
int n, m;
void ne(string s)
{
	m = s.size() - 1;
	nex[1] = 0;
	for (int i = 2, j = 0; i <= m; i++)
	{
		while (j && s[i] != s[j + 1])
			j = nex[j];
		if (s[i] == s[j + 1])
			j++;
		nex[i] = j;
	}
}
int kmp(string s, string p) // p是模式串，作为子串出现的那个,字符串要从1开始
{
	n = s.size() - 1, m = p.size() - 1;
	int cnt = 0;
	for (int i = 1, j = 0; i <= n; i++)
	{
		while (j && s[i] != p[j + 1])
			j = nex[j];
		// 如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串
		// 用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)
		if (s[i] == p[j + 1])
			j++;
		// 当前元素匹配，j移向p串下一位
		if (j == m)
		{
			// 匹配成功，进行相关操作
			j = nex[j]; // 继续匹配下一个子串
			cnt++;
		}
	}
	return cnt;
}
void solve()
{
	// 开始还以为是后缀数组，其实是kmp模式匹配，
	// 题目大意：si对于所有sj匹配子串的个数的乘积，对于每个si单独输出一行
	// 目前做的题，大都是对于板子核心的运用
	int nn;
	cin >> nn;
	for (int i = 1; i <= nn; ++i)
	{
		cin >> s[i];
		s[i] = ' ' + s[i];
		if (s[i].size() < len)
		{
			len = s[i].size();
			mn = s[i];
		}
	}
	// 长字符串对于短字符串的模式匹配肯定是0
	// 短对短的需要验证是否成立
	for (int i = 1; i <= nn; ++i)
	{
		if (len == s[i].size() && mn != s[i])
		{
			for (int i = 1; i <= nn; ++i)
			{
				cout << 0 << '\n';
			}
			return; // 都不存在可匹配的
		}
	}
	// 首先处理nex数组
	//  string s1,s2;
	//  cin>>s1>>s2;
	ne(mn);
	// cout<<kmp(s1,s2);
	int ans = 1;
	for (int i = 1; i <= nn; ++i)
	{
		ans = ans * kmp(s[i], mn) % MOD;
	}
	for (int i = 1; i <= nn; ++i)
	{
		if (s[i].size() == len)
		{
			cout << ans << '\n';
		}
		else
		{
			cout << 0 << '\n';
		}
	}
}
signed main()
{
#ifdef LOCAL
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout); // a为add,,w
#endif
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t;
	t = 1;
	// cin>>t;
	while (t--)
		solve();
	return 0;
} // https://ac.nowcoder.com/acm/contest/50135/A
```

