# 基础算法

## 一、启发式合并

### [2154. 梦幻布丁 - AcWing题库](https://www.acwing.com/problem/content/description/2156/)

#### 思路：

启发式合并，将小的颜色块合并到大的颜色块里，

先消除颜色块的影响，然后合并，但是注意有个数组映射



[AcWing 2154. 梦幻布丁-之为什么有p[M\]映射对应的事实 - AcWing](https://www.acwing.com/solution/content/65396/)

简要地说：把x看成y，或者把y看成x，段数关系不变，但是能起到将小的段数合并到大的段数里

### [Problem - E - Codeforces](https://codeforces.com/contest/1810/problem/E)

#### 思路：

**这个题需要注意可以走重复的点，但是当前集合的尺寸要大于当前点的权值** 

**采用启发式合并，注意初始化，内容按权值排序，**

**采用bfs进行遍历，合并点，遍历点，最后能够全部合并即为答案**

#### 代码：

```c++
struct DSU {
    std::vector<int> f, siz;
    
    DSU() {}
    DSU(int n) {
        init(n);
    }
    
    void init(int n) {
        f.resize(n);
        std::iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }
    
    int leader(int x) {
        while (x != f[x]) {
            x = f[x] = f[f[x]];
        }
        return x;
    }
    
    bool same(int x, int y) {
        return leader(x) == leader(y);
    }
    
    bool merge(int x, int y) {
        x = leader(x);
        y = leader(y);
        if (x == y) {
            return false;
        }
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }
    
    int size(int x) {
        return siz[leader(x)];
    }
};
void solve() {
    int n, m;
    std::cin >> n >> m;
    
    std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> a[i];
    }
    
    std::vector<std::vector<int>> adj(n);
    for (int i = 0; i < m; i++) {
        int u, v;
        std::cin >> u >> v;
        u--, v--;
        
        if (std::pair(a[u], u) < std::pair(a[v], v)) {
            std::swap(u, v);
        }
        adj[u].push_back(v);
    }
    
    std::vector<bool> ok(n);
    
    std::vector<int> order(n);
    std::iota(order.begin(), order.end(), 0);
    std::sort(order.begin(), order.end(), [&](int i, int j) {
        return std::pair(a[i], i) < std::pair(a[j], j);
    });
    
    DSU dsu(n);
    
    for (auto x : order) {
        ok[x] = a[x] == 0;
        for (auto y : adj[x]) {
            y = dsu.leader(y);
            if (ok[y] && dsu.size(y) >= a[x]) {
                ok[x] = true;
            }
            dsu.merge(x, y);
        }
    }
    
    for (int i = 0; i < n; i++) {
        if (!dsu.same(0, i)) {
            std::cout << "NO\n";
            return;
        }
    }
    
    if (ok[dsu.leader(0)]) {
        std::cout << "YES\n";
    } else {
        std::cout << "NO\n";
    }
}
```

### [Problem - E - Codeforces](https://codeforces.com/contest/1833/problem/E)（）（并查集+环数）

#### 思路：

并查集+环数

## 二、kmp循环节

### 知识：

 [kmp循环节.md](..\分散题解\kmp循环节.md) 

### 代码：

## 三、自动取模

### 板子：

```
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;
using LL = long long;

template<const int T>
struct ModInt {
    const static int mod = T;
    int x;
    ModInt(int x = 0) : x(x % mod) {}
    ModInt(long long x) : x(int(x % mod)) {} 
    int val() { return x; }
    ModInt operator + (const ModInt &a) const { int x0 = x + a.x; return ModInt(x0 < mod ? x0 : x0 - mod); }
    ModInt operator - (const ModInt &a) const { int x0 = x - a.x; return ModInt(x0 < 0 ? x0 + mod : x0); }
    ModInt operator * (const ModInt &a) const { return ModInt(1LL * x * a.x % mod); }
    ModInt operator / (const ModInt &a) const { return *this * a.inv(); }
    void operator += (const ModInt &a) { x += a.x; if (x >= mod) x -= mod; }
    void operator -= (const ModInt &a) { x -= a.x; if (x < 0) x += mod; }
    void operator *= (const ModInt &a) { x = 1LL * x * a.x % mod; }
    void operator /= (const ModInt &a) { *this = *this / a; }
    friend ostream &operator<<(ostream &os, const ModInt &a) { return os << a.x;}
    
    ModInt pow(int64_t n) const {
        ModInt res(1), mul(x);
        while(n){
            if (n & 1) res *= mul;
            mul *= mul;
            n >>= 1;
        }
        return res;
    }
    
    ModInt inv() const {
        int a = x, b = mod, u = 1, v = 0;
        while (b) {
            int t = a / b;
            a -= t * b; swap(a, b);
            u -= t * v; swap(u, v);
        }
        if (u < 0) u += mod;
        return u;
    }
    
};
typedef ModInt<1000000007> mint;

int main(){

    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(0);

    int T;
    cin >> T;
    while(T--){
        int n, k;
        cin >> n >> k;
        vector<int> c(n);
        for(int i = 0; i < n; i++) 
            cin >> c[i], c[i]--;
        vector<vector<bool> > ok(n + 1, vector<bool>(n));
        vector<vector<mint> > dp(n + 1, vector<mint>(n));
        ok[0][0] = true;
        dp[0][0] = 1;
        vector<bool> can(n / k + 1);
        vector<mint> sum(n / k + 1);
        sum[0] = 1;
        can[0] = true;
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j >= 1; j--){
                if (j % k == 1){
                    if (can[j / k]){
                        ok[j][c[i]] = true;
                        dp[j][c[i]] += sum[j / k];
                    }
                }
                else{
                    if (ok[j - 1][c[i]]){
                        ok[j][c[i]] = true;
                        dp[j][c[i]] += dp[j - 1][c[i]];
                    }
                }
                if (j % k == 0 && ok[j][c[i]]){
                    can[j / k] = true;
                    sum[j / k] += dp[j - 1][c[i]];
                }
            }
        }
        for(int i = n / k; i >= 0; i--){
            if (can[i]){
                cout << sum[i] << '\n';
                break;
            }
        }
    }

}
```

### 板子：jiangly

```c++
constexpr int P = 998244353;
using i64 = long long;
int norm(int x) {
    if (x < 0) {
        x += P;
    }
    if (x >= P) {
        x -= P;
    }
    return x;
}
template<class T>
T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
struct Z {
    int x;
    Z(int x = 0) : x(norm(x)) {}
    Z(i64 x) : x(norm(x % P)) {}
    int val() const {
        return x;
    }
    Z operator-() const {
        return Z(norm(P - x));
    }
    Z inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    Z &operator*=(const Z &rhs) {
        x = i64(x) * rhs.x % P;
        return *this;
    }
    Z &operator+=(const Z &rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    Z &operator-=(const Z &rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    Z &operator/=(const Z &rhs) {
        return *this *= rhs.inv();
    }
    friend Z operator*(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res *= rhs;
        return res;
    }
    friend Z operator+(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res += rhs;
        return res;
    }
    friend Z operator-(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res -= rhs;
        return res;
    }
    friend Z operator/(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res /= rhs;
        return res;
    }
    friend std::istream &operator>>(std::istream &is, Z &a) {
        i64 v;
        is >> v;
        a = Z(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const Z &a) {
        return os << a.val();
    }
};
```

## 四、分层图



例题：[P4568 [JLOI2011\] 飞行路线 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4568)

向上走消耗为0，模拟分层。

### 板子：

```
vector<pair<int,int>>g[maxj];
int dis[maxj];
bool vis[maxj];
void dij(int s){
    fill(dis,dis+maxj-6,inf);
    priority_queue<pii, vector<pii> , greater<pii> >que;
    que.emplace(0,s);
    dis[s]=0;//初始化
    while(que.size()){
        pii now=que.top();
        que.pop();
        if(vis[now.second])continue;
        vis[now.second]=1;
        for(auto i:g[now.second]){
            int v=i.first,w=i.second;
            if(dis[v]>dis[now.second]+w){
                dis[v]=dis[now.second]+w;
                que.emplace(dis[v],v);
            }
        }
    }

}
void solve(){
    //多建层多建边从而模拟分层
    int n,m,k;
    cin>>n>>m>>k;
    int s,t;
    cin>>s>>t;
    for(int i=1;i<=m;++i){
        int u,v,w;cin>>u>>v>>w;
        g[u].emplace_back(v,w);
        g[v].emplace_back(u,w);
        for(int j=1;j<=k;++j){//同一层之间花费c，不同层之间花费0，按照题意走的
            g[u+(j-1)*n].emplace_back(v+(j)*n,0);
            g[v+(j-1)*n].emplace_back(u+(j)*n,0);
            g[u+(j)*n].emplace_back(v+(j)*n,w);
            g[v+(j)*n].emplace_back(u+(j)*n,w);
            
        }
    }
    for(int i=1;i<=k;++i){//不同层之间结束位置构造
        g[t+(i-1)*n].emplace_back(t+i*n,0);
        // g[t+(i)*n].emplace_back(t+i*n,0);
    }
    dij(s);
    cout<<dis[t+n*k]<<'\n';//免费一次，相当于跳了一层
}  
```

[Problem - I - Codeforces](https://codeforces.com/group/QJA47ykHfD/contest/437692/problem/I)

### 思路：

关键是每一层内的建立方式，还有层间的建立方式，注意题目要求。

## 五、逆序对&&正序对（未完

### 参考资料：

[逆序数 + 正序数（归并排序）_逆序数加顺序数_芋圆西米露的博客-CSDN博客](https://blog.csdn.net/qq_41117236/article/details/80862639)

这两个打法的区别，

核心都是普通数组做归并排序，

不同的是：

正序对是在if后边ans+=r-j+1,因为排序后边的值都比当前大

逆序对是在else后边ans+=j-cnt;，因为cnt到j这一部分都比a[j ]小

### 正序对（未完

#### 题：

[2352 -- 星星 (poj.org)](http://poj.org/problem?id=2352)

[富哥 - CUSTOJ](http://10.36.65.50:81/training/14/problem/L)                                  （custoj）

线段树板子：

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=50005;
int a[maxn],b[maxn],c;
void f(int *a,int l,int mid,int r)
{
    int i=l,j=mid+1,k=l;
    while(i<=mid&&j<=r){
        if(a[i]<a[j]){
            c+=r-j+1;
            b[k++]=a[i++];
        }
        else b[k++]=a[j++];
    }
    while(i<=mid)
        b[k++]=a[i++];
    while(j<=r)
        b[k++]=a[j++];
    for(i=l;i<=r;i++)
        a[i]=b[i];
}
void ff(int *a,int l,int r)
{
    if(l<r){
        int mid=(l+r)/2;
        ff(a,l,mid);
        ff(a,mid+1,r);
        f(a,l,mid,r);
    }
}
int main()
{
    int n,i;
    while(~scanf("%d",&n)){
        for(i=0;i<n;i++) scanf("%d",&a[i]);
        c=0;
        ff(a,0,n-1);
        printf("%d\n",c);
    }
    return 0;
}
```

归并排序

```c++

```

### 逆序对：（完

冒泡排序交换次数等于逆序对数

#### 题：

[P1908 逆序对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1908)

板子题

[Problem - 7359 (hdu.edu.cn)](https://acm.hdu.edu.cn/showproblem.php?pid=7359)

利用位置关系，理解到逆序对，利用逆序对

[E-Red and Blue and Green_2023牛客暑期多校训练营5 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/57359/E)

根据逆序对反向构造全排列

#### 板子：

归并排序

```
#include<bits/stdc++.h>
using namespace std;
const int maxj=5e5+10;
int a[maxj],tmp[maxj];
long long ans=0;
void mergesort(int l,int r){//跟前边比
    if(l==r)return ;
    int mid=(l+r)>>1;
    mergesort(l,mid);mergesort(mid+1,r);
    int pre=l,las=mid+1,now=l;
    while(pre<=mid&&las<=r){
        if(a[pre]>a[las])ans+=(mid-pre+1),tmp[now++]=a[las++];
        else tmp[now++]=a[pre++];
    }
    while(pre<=mid)tmp[now++]=a[pre++];
    while(las<=r)tmp[now++]=a[las++];
    for(int i=l;i<=r;++i){
        a[i]=tmp[i];
    }
}
int main(){
    
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",a+i);
    }//归并排序
    mergesort(1,n);
    printf("%lld",ans);
    return 0;
}
```

树状数组：

```
#include<bits/stdc++.h>
using namespace std;
const int maxj=5e5+10;
int a[maxj],tmp[maxj];
#define rtr rt<<1|1
#define rtl rt<<1
struct node{
    int sum;
}d[maxj<<2];
void update(int rt){
    d[rt].sum=d[rtr].sum+d[rtl].sum;
}
void build_tree(int l,int r,int rt){
    if(l==r){
        d[rt].sum=0;
        return ;
    }
    int mid=(l+r)>>1;
    build_tree(l,mid,rtl);
    build_tree(mid+1,r,rtr);
    update(rt);
}
void add(int L,int c,int l,int r,int rt){
    if(l==r){
        d[rt].sum+=c;
        return ;
    }
    int mid=(l+r)>>1;
    if(L<=mid)add(L,c,l,mid,rtl);
    else add(L,c,mid+1,r,rtr);
    update(rt);
}
int query(int L,int R,int l,int r,int rt){
    if(L>R)return 0;
    if(L<=l&&R>=r)return d[rt].sum;
    long long res=0;
    int mid=(l+r)>>1;
    if(L<=mid)res+= query(L,R,l,mid,rtl);
    if(R>=mid+1)res+= query(L,R,mid+1,r,rtr);
    return res;
}
int main(){
    int n;
    long long ans=0;
    scanf("%d",&n);
    int tot=0;
    for(int i=1;i<=n;++i){
        scanf("%d",a+i);tmp[++tot]=++a[i];
    }//离散化,二分,树状数组
    sort(tmp+1,tmp+1+tot);tot=unique(tmp+1,tmp+1+tot)-tmp-1;
    for (int i=1;i<=n;++i) {
        a[i] = lower_bound(tmp+1,tmp+1+tot,a[i])-tmp;
    }
    for(int i=1;i<=n;++i){
        ans+= query(a[i]+1,tot,1,tot,1);
        add(a[i],1,1,tot,1);
    }
    cout<<ans;
    return 0;
}
```



## 六、单调队列（找动态规划章节

参考资料：[单调队列优化DP（超详细！！！） - endl\n - 博客园 (cnblogs.com)](https://www.cnblogs.com/ljy-endl/p/11638389.html)

维护区间（一维或者二维）的最值

### 一维单调队列：

```c++
int n,m;
int q1[1000001],q2[1000001];
int a[1000001];
int min_deque()
{
    //单调队列需要两样东西，一个保证区间答案，一个维护最值
    //que主要在于维护位置，不是其他的
    int h=1,t=0;
    for(int i=1;i<=n;i++)
    {
        while(h<=t&&q1[h]+m<=i) h++;
        while(h<=t&&a[i]<a[q1[t]]) t--;
        q1[++t]=i;
        if(i>=m) printf("%d ",a[q1[h]]);
    }
    cout<<endl;
}
int max_deque()
{
    int h=1,t=0;
    for(int i=1;i<=n;i++)
    {
        while(h<=t&&q2[h]+m<=i) h++;
        while(h<=t&&a[i]>a[q2[t]]) t--;
        q2[++t]=i;
        if(i>=m) printf("%d ",a[q2[h]]);
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    min_deque();
    max_deque();
    return 0;
}
```

### 二维单调队列：

```c++
/*
二维单调队列可以维护区间的最大值，最小值
*/
#include <bits/stdc++.h>
using namespace std;
typedef long long int LL;
const int MAXN = 1000 + 10;
const int INF = 0x3f3f3f3f;
int n, m, k, num[MAXN][MAXN], minNum[MAXN][MAXN], maxNum[MAXN][MAXN];
void solve(int type, int seg[][MAXN]){
    deque<pair<int, int> > deq;
    for (int i = 1; i <= n; i++){ //求行子段的最值。
        deq.clear();
        for (int j = 1; j <= m; j++){
            while (!deq.empty() && j - deq.front().second >= k){ deq.pop_front(); }
            if (type){
                while (!deq.empty() && deq.back().first < num[i][j]){ deq.pop_back(); }
            }
            else{
                while (!deq.empty() && deq.back().first > num[i][j]){ deq.pop_back(); }
            }
            deq.push_back(make_pair(num[i][j], j));
            seg[i][j] = deq.front().first;
        }
    }
    for (int j = 1; j <= m; j++){ //求列的最值
        deq.clear();
        for (int i = 1; i <= n; i++){
            while (!deq.empty() && i - deq.front().second >= k){ deq.pop_front(); }
            if (type){
                while (!deq.empty() && deq.back().first < seg[i][j]){ deq.pop_back(); }
            }
            else{
                while (!deq.empty() && deq.back().first > seg[i][j]){ deq.pop_back(); }
            }
            deq.push_back(make_pair(seg[i][j], i));
            seg[i][j] = deq.front().first;
        }
    }
}
int main(){
    while (~scanf("%d%d%d", &n, &m, &k)){
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= m; j++){
                scanf("%d", &num[i][j]);
            }
        }
        int ans = INF;
        solve(0, minNum); solve(1, maxNum);//求区间最小值，最大值
        for (int i = k; i <= n; i++){
            for (int j = k; j <= m; j++){
                ans = min(ans, maxNum[i][j] - minNum[i][j]);
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}
```



## 七、大整数乘法

### 1，有限制但高效的算法，适合规模较大的部分

​      要求输入的数据规模必须为 2 的幂次方，因此如果输入的大整数不满足该条件，则需要进行额外操作来对其进行补零，这会增加计算时间和空间开销。

fft算法：

FFT 算法在实现大整数乘法时有以下限制：

1. 精度限制：FFT 算法是基于复数域上的运算，因此在实现过程中需要使用浮点数运算。这会导致精度问题，可能会影响最终的计算结果。
2. 数据规模限制：FFT 算法要求输入的数据规模必须为 2 的幂次方，因此如果输入的大整数的位数不是 2 的幂次方，则需要进行补零操作，这会占用额外的空间和计算时间。
3. 空间限制：FFT 算法需要占用额外的存储空间来保存中间结果。具体来说，在实现大整数乘法时，需要创建两个长度为 2n 的数组，分别用于存储两个输入大整数的 FFT 结果和它们的点值积。这会导致空间占用较高，特别是在处理大数据时。
4. 时间复杂度限制：虽然 FFT 算法的时间复杂度为 O(n * log(n))，但是由于前面提到的精度问题以及额外的空间开销，会导致实际运行时间比理论上的时间复杂度还要高一些。

因此，在实际应用中，需要仔细考虑以上限制，并根据实际情况选择合适的算法来实现大整数乘法。

```
#include <bits/stdc++.h>
using namespace std;

const double PI = acos(-1);
typedef complex<double> cd;
vector<int> multiply(vector<int>& a, vector<int>& b) {
    int n = 1;
    while (n < a.size() + b.size()) n <<= 1;
    vector<cd> fa(n), fb(n);
    for (int i = 0; i < a.size(); ++i) fa[i] = a[i];
    for (int i = 0; i < b.size(); ++i) fb[i] = b[i];
    fft(fa, false); fft(fb, false);
    for (int i = 0; i < n; ++i) fa[i] *= fb[i];
    fft(fa, true);
    vector<int> res(n);
    int carry = 0;
    for (int i = 0; i < n; ++i) {
        int t = (int)(fa[i].real() + 0.5) + carry;
        res[i] = t % 10;
        carry = t / 10;
    }
    while (res.size() > 1 && res.back() == 0) res.pop_back();
    reverse(res.begin(), res.end());
    return res;
}

int main() {
    string s1, s2;
    cin >> s1 >> s2;
    vector<int> a(s1.size()), b(s2.size());
    for (int i = 0; i < s1.size(); ++i) a[i] = s1[s1.size() - i - 1] - '0';
    for (int i = 0; i < s2.size(); ++i) b[i] = s2[s2.size() - i - 1] - '0';
    vector<int> c = multiply(a, b);
    for (int i = 0; i < c.size(); ++i) cout << c[c.size() - i - 1];
    return 0;
}

```

Schönhage-Strassen 算法：

在实际应用中，Schönhage-Strassen 算法也存在以下限制：

1. 数据规模限制：由于 Schönhage-Strassen 算法要求输入的数据规模必须为 2 的幂次方，因此如果输入的大整数不满足该条件，则需要进行额外操作来对其进行补零，这会增加计算时间和空间开销。
2. 实现复杂度高：与传统的列竖式计算相比，Schönhage-Strassen 算法的实现难度较高。需要掌握基本的多项式运算知识、FFT 算法以及底层优化技巧等内容，并且需要针对具体实现进行适当的调优。
3. 空间开销高：Schönhage-Strassen 算法需要占用额外的存储空间来保存中间结果，具体来说，需要创建两个长度为 2n 的数组，分别用于存储两个输入大整数的 FFT 结果和它们的点值积。这会导致空间占用较高，特别是在处理大数据时。
4. 精度限制：在实现 Schönhage-Strassen 算法时，需要使用浮点数运算，因此可能会出现精度问题，这会影响最终的计算结果。
5. 实际效率受硬件环境限制：Schönhage-Strassen 算法中包含有较多的低级别操作，例如乘法和除法等。这些操作的效率会受到底层硬件环境的影响，例如 CPU 的指令优化、缓存大小等。因此，在不同的硬件环境下，Schönhage-Strassen 算法的实际效率也会有所差异。

综上所述，Schönhage-Strassen 算法虽然具有比传统列竖式计算更高的时间复杂度，但在实际应用中也存在一定的限制和限制条件，需要进行充分的考虑和选择。

```
#include <bits/stdc++.h>
using namespace std;

const int base = 1e9;
typedef vector<int> vi;

vi karatsuba(const vi& a, const vi& b) {
    int n = a.size(), m = b.size();
    if (n < m) return karatsuba(b, a);
    if (n < 100) { // 递归边界，切换到传统竖式运算
        vi c(n + m); int carry = 0;
        for (int i = 0; i < n; ++i) {
            carry = 0;
            for (int j = 0; j < m || carry; ++j) {
                long long t = c[i + j] + (long long)a[i] * (j < m ? b[j] : 0) + carry;
                c[i + j] = t % base; carry = t / base;
            }
        }
        while (c.size() > 1 && c.back() == 0) c.pop_back();
        return c;
    }
    int k = (n + 1) / 2;
    vi a1(a.begin(), a.begin() + k), a2(a.begin() + k, a.end());
    vi b1(b.begin(), b.begin() + min<int>(m, k)), b2(b.begin() + min<int>(m, k), b.end());
    vi A = karatsuba(a1, b1), B = karatsuba(a2, b2);
    vi AB = karatsuba(add(a1, a2), add(b1, b2));
    vi res(n + m);
    for (int i = 0; i < A.size(); ++i) res[i] += A[i];
    for (int i = 0; i < B.size(); ++i) res[n + i] += B[i];
    for (int i = 0; i < AB.size(); ++i) res[k + i] += AB[i] - A[i] - B[i];
    while (res.size() > 1 && res.back() == 0) res.pop_back();
    return res;
}

vi mul(const vi& a, const vi& b) {
    int n = a.size(), m = b.size();
    if (n == 0 || m == 0) return {};
    if (n < 100 || m < 100) { // 如果数据规模较小，使用传统竖式计算
        vi c(n + m); int carry = 0;
        for (int i = 0; i < n; ++i) {
            carry = 0;
            for (int j = 0; j < m || carry; ++j) {
                long long t = c[i + j] + (long long)a[i] * (j < m ? b[j] : 0) + carry;
                c[i + j] = t % base; carry = t / base;
            }
        }
        while (c.size() > 1 && c.back() == 0) c.pop_back();
        return c;
    }
    int k = (max(n, m) + 1) / 2;
    vi a1(a.begin(), a.begin() + min<int>(k, n)), a2(a.begin() + min<int>(k, n), a.end());
    vi b1(b.begin(), b.begin() + min<int>(k, m)), b2(b.begin() + min<int>(k, m), b.end());
    vi A = mul(a1, b1), B = mul(a2, b2);
    vi AB = mul(add(a1, a2), add(b1, b2));
    vi res(n + m);
    for (int i = 0; i < A.size(); ++i) res[i] += A[i];
    for (int i = 0; i < B.size(); ++i) res[n + i] += B[i];
    for (int i = k; i < AB.size() + k; ++i) res[i] += AB[i - k] - A[i - k] - B[i - k];
    while (res.size() > 1 && res.back() == 0) res.pop_back();
    return res;
}

string to_str(const vi& a) {
    stringstream ss; ss << a.back();
    for (int i = a.size() - 2; i >= 0; --i) {
        ss.width(9); ss.fill('0');
        ss << a[i];
    }
    string s; ss >> s; return s;
}

vi from_str(const string& s) {
    vi res(s.size() / 9 + 1);
    for (int i = 0, j = 0, k = 1; i < s.size(); ++i, k *= 10) {
        if (k == base) k = 1, ++j;
        res[j] += (s[i] - '0') * k;
    }
    while (res.size() > 1 && res.back() == 0) res.pop_back();
    return res;
}

int main() {
    string s1, s2; cin >> s1 >> s2;
    vi a = from_str(s1), b = from_str(s2);
    vi c = karatsuba(a, b);
    cout << to_str(c) << '\n';
    return 0;
}

```

分治法实现：

Karatsuba 算法是一种使用分治策略实现大整数乘法的方法，它可以将两个 n 位的大整数相乘的复杂度降低到 O(n^log2(3))。

Karatsuba 算法的核心思想是将两个大整数分别拆分成两个 n/2 位的整数，并通过递归的方式计算出它们的乘积。然后，使用这四个乘积来计算原始的两个大整数的乘积。

具体地，设要计算的两个大整数为 X 和 Y，分别拆分成四个 n/2 位的整数 A、B、C 和 D。那么有如下公式：

1. 计算 ac = A * C。
2. 计算 bd = B * D。
3. 计算 (A + B) * (C + D)，得到 abcd = A*C + B*D + (A+B)*(C+D)。
4. 计算 adbc = abcd - ac - bd。
5. 将 ac 和 bd 后面添加 n 个 0，将 adbc 后面添加 n/2 个 0。
6. 计算结果：X*Y = ac * 10^n + adbc * 10^(n/2) + bd。

在 Karatsuba 算法中，将问题规模缩小到了 n/2，因此递归深度为 log2(n)。在每一层递归中，需要进行三次乘法，每次乘法都是两个 n/2 位整数相乘。因此总共有 T(n) = 3T(n/2) + O(n) 的时间复杂度。

根据主定理可知，该算法的时间复杂度为 O(n^log2(3))，约为 O(n^1.585)。这比传统列竖式计算乘积的时间复杂度 O(n^2) 要快得多，尤其适用于位数较大的大整数相乘。

```
#include <iostream>
#include <vector>
#include <string>

using namespace std;

void add(vector<int>& a, vector<int>& b) {
    int carry = 0;
    for (int i = 0; i < a.size(); i++) {
        int sum = a[i] + b[i] + carry;
        a[i] = sum % 10;
        carry = sum / 10;
    }
}

void sub(vector<int>& a, vector<int>& b) {
    int borrow = 0;
    for (int i = 0; i < a.size(); i++) {
        int diff = a[i] - b[i] - borrow;
        if (diff < 0) {
            diff += 10;
            borrow = 1;
        } else {
            borrow = 0;
        }
        a[i] = diff;
    }
}

vector<int> multiply(vector<int>& a, vector<int>& b) {
    if (a.size() < b.size()) {
        swap(a, b);
    }
    int n = a.size(), m = b.size();
    vector<int> c(n + m);
    if (n <= 4) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                c[i + j] += a[i] * b[j];
                c[i + j + 1] += c[i + j] / 10;
                c[i + j] %= 10;
            }
        }
        while (c.size() > 1 && c.back() == 0) {
            c.pop_back();
        }
        return c;
    }
    int k = (n + 1) / 2;
    vector<int> a1(a.begin(), a.begin() + k), a2(a.begin() + k, a.end());
    vector<int> b1(b.begin(), b.begin() + min(m, k)), b2(b.begin() + min(m, k), b.end());
    vector<int> c1 = multiply(a1, b1);
    vector<int> c2 = multiply(a2, b2);
    vector<int> a3(k), b3(k);
    for (int i = 0; i < k; i++) {
        if (i < a2.size()) {
            a3[i] = a2[i];
        }
        if (i < b2.size()) {
            b3[i] = b2[i];
        }
    }
    vector<int> c3 = multiply(add(a1, a3), add(b1, b3));
    sub(c3, c1);
    sub(c3, c2);
    for (int i = 0; i < c1.size(); i++) {
        c[i] += c1[i];
    }
    for (int i = 0; i < c2.size(); i++) {
        c[i + n - k * 2] += c2[i];
    }
    for (int i = 0; i < c3.size(); i++) {
        c[i + n - k] += c3[i];
    }
    while (c.size() > 1 && c.back() == 0) {
        c.pop_back();
    }
    return c;
}

int main() {
    string s1, s2;
    cin >> s1 >> s2;
    vector<int> a(s1.size()), b(s2.size());
    for (int i = 0; i < s1.size(); ++i) {
        a[s1.size() - 1 - i] = s1[i] - '0';
    }
    for (int i = 0; i < s2.size(); ++i) {
        b[s2.size() - 1 - i] = s2[i] - '0';
    }
    vector<int> res = multiply(a, b);
    reverse(res.begin(), res.end());
    for (int x : res) {
        cout << x;
    }
    cout << endl;
    return 0;
}

```

### 2，模拟但低效，适合规模较小的时候

相比于 FFT 算法等高级算法，模拟实际运算的方法有以下优点：

1. 实现简单：不需要掌握高级算法，只需要了解基础的乘法原理即可实现。
2. 不受数据规模限制：不需要满足输入数据必须为 2 的幂次方的限制，能够处理任意长度的大整数。
3. 精度高：由于不需要使用浮点数运算，因此精度比使用 FFT 算法等复杂算法时更高。
4. 空间开销小：不需要额外占用空间存储中间结果，只需要使用常数级别的空间即可完成计算。

当然，模拟实际运算的方法也存在一些缺点，主要是速度慢。随着数据规模的增大，其时间复杂度将呈指数级别增长，无法满足某些场景下对速度的要求。

综上所述，选择何种方法实现大整数乘法应该根据具体情况而定。如果数据规模较小，可以选择模拟实际运算的方法；如果数据规模较大，需要更高效的算法来保证运行速度。

```

```

## 八、二分+公式

[融化冰块 - CUSTOJ](https://oj.acm.cust.team/contest/1060/problem/F)

有公式的推导，

```
bool check(int x)
{
    // 二分的方式，冰箱时间和单分钟时间
    int pos=upper_bound(a+1,a+1+n,x)-a;
    int cnt=0;
    for(int i=pos;i<=n;++i){
        int ll=1,rr=x;
        int ans = 0 ;
        while(ll<=rr){
            int mid=ll+rr>>1;
            if(mid*m+x-mid>=a[i]){
                ans=mid;
                rr=mid-1;
            }else{
                ll=mid+1;
            }
        }
        cnt+=ll;//左边是最小的
        
    }
    return cnt<=x;
}
```

### 板子：

```;
int l=1,r=1e18;
while(l<=r){
	int mid=l+r>>1;
	if(check(mid)){
		r=mid-1;
		ans=mid;
	}else{
		l=mid+1;
	}
}
cout<<ans<<'\n';
//这里如果有很多可能一样的东西
//ans=l;  ans=r;
```

## 九、快写

```
void write(int x)
{
    if (x == 0)
    {
        return;
    }
    string s;
    while (x)
    {
        s += to_string((signed)(x % 10));
        x = x / 10;
    }
    reverse(s.begin(), s.end());
    cout << s << '\n';
}
```

## 十、单调栈

### 思考：

### 板子：



## 十一、双指针

[1003 Simple Set Problem (hdu.edu.cn)](https://acm.hdu.edu.cn/contest/problem?cid=1097&pid=1003)

右边界固定，左边界移动，一个动一个定

```c++
signed main()
{
    int ans=0;
    int n;
    cin>>n;
    for(int i=1;i<=n;++i)
        cin>>a[i];
    //前提有序
    sort(a+1,a+1+n);
    for(int i=1,j=1; i<=n; ++i)
    {
        //改变右区间
        --操作
        while(cnt[a[i]]>1&&l<=r){
            //改变左区间
            --操作
            j++;
            //更新答案
        	ans=max(ans,i-j+1);
        }
       	
        //i++，右区间++
    }
    cout<<ans<<endl;
    return 0;
}
```

## 十二、联通块、并查集

#### jiangly的dsu

```
struct DSU {
    std::vector<int> f, siz;
    
    DSU() {}
    DSU(int n) {
        init(n);
    }
    
    void init(int n) {
        f.resize(n);
        std::iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }
    
    int find(int x) {
        while (x != f[x]) {
            x = f[x] = f[f[x]];
        }
        return x;
    }
    
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }
    
    int size(int x) {
        return siz[find(x)];
    }
};
```

[1007 Solubility (hdu.edu.cn)](https://acm.hdu.edu.cn/contest/problem?cid=1101&pid=1007)

```c++
 //并查集初始化
    for(int i=1;i<=n;++i){
        fa[i]=i;
    }
    for(int i=1;i<=m;++i){
        int u,v;
        cin>>u>>v;
        //并查集直接合并
        fa[find(u)]=find(v);
    }
```

## 十三、二维前缀和

[A (codeforces.com)](https://codeforces.com/gym/104128/problem/A)

板子：

```
void Add(int X3,int Y3,int X4,int Y4,int Delt=1){
    DP[X3][Y3]+=Delt;
    DP[X4+1][Y3]-=Delt;
    DP[X3][Y4+1]-=Delt;
    DP[X4+1][Y4+1]+=Delt;
}
```

```
DP[i][j]=DP[i][j]+DP[i-1][j]+DP[i][j-1]-DP[i-1][j-1];
```

## 十四、gcd，辗转相除法

递推

```c++
#include <stdio.h>
int main()
{
	int u, v;
	scanf("%d %d", &u, &v);
	while (v != 0)
	{
		int tmp = u % v;
		u = v;
		v = tmp;
	}
	printf("%d", u);
	return 0;
 
}
```

递归

```
private static int gcd(int a, int b) {
        return b != 0 ? gcd(b, a % b) : a;
}
```

## 十五、二维vector

```c++
// 初始化一个 二维的matrix, 行M,列N,且值为0
vector<vector<int>> matrix(M,vector<int>(N));
//等价于下面的
vector<vector<int> > matrix(M); 
for(int i=0;i<M;i++) {
    matrix[i].resize(N);
}
//等价于下面的
vector< vector<int> > matrix;
matrix.resize(M);//M行
for(int i=0;i<matrix.size();i++){
    matrix[i].resize(N);//每一行都是N列
}
    
// 初始化一个 二维的matrix, 行M,列N,且值自定义为data;
vector<vector<int>> matrix(M,vector<int>(N,data));

```

## 十六、三分（待补

[Problem - D - Codeforces](https://codeforces.com/contest/1928/problem/D)

```c++
int c1(int n)
{
    return n * (n - 1) / 2;
}
int c[N];
int n, b, x;
int check(int y)
{
    int ans = 0;
    // 模拟一些参数作为check函数使用
    for (int i = 1; i <= n; ++i)
    {
        if (c[i] <= y)
        {
            ans += c1(c[i]);
        }
        else
        {
            int tp = c[i] / y;
            int a = c[i] % y;
            int b = y - a;
            ans += c1(a) * (tp + 1) * (tp + 1);
            ans += c1(b) * tp * tp;
            ans += a * (tp + 1) * b * tp;
        }
    }

    return ans * b - (y - 1) * x;
}
void solve()
{
    /*
    这个题目前用到三分，之后有时间再刷，目前不适合

    */

    cin>>n>>b>>x;
    for (int i = 1; i <= n; ++i)
    {
        cin >> c[i];
    }
    sort(c + 1, c + 1 + n);
    int l = 1, r = c[n];
    while (l < r)
    {
        int m1 = l + (r - l) / 3;
        int m2 = r - (r - l) / 3;
        if (check(m1) > check(m2))
        {
            r = m2 - 1;
        }
        else
            l = m1 + 1;
    }
    cout << check(l) << '\n';
}
```

## 十七、逆序对

### 原理



### 板子

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxj = 5e5 + 10;
int a[maxj], tmp[maxj];
#define rtr rt << 1 | 1
#define rtl rt << 1
struct node
{
    int sum;
} d[maxj << 2];
void update(int rt)
{
    d[rt].sum = d[rtr].sum + d[rtl].sum;
}
void build_tree(int l, int r, int rt)
{
    if (l == r)
    {
        d[rt].sum = 0;
        return;
    }
    int mid = (l + r) >> 1;
    build_tree(l, mid, rtl);
    build_tree(mid + 1, r, rtr);
    update(rt);
}
void add(int L, int c, int l, int r, int rt)
{
    if (l == r)
    {
        d[rt].sum += c;
        return;
    }
    int mid = (l + r) >> 1;
    if (L <= mid)
        add(L, c, l, mid, rtl);
    else
        add(L, c, mid + 1, r, rtr);
    update(rt);
}
int query(int L, int R, int l, int r, int rt)
{
    if (L > R)
        return 0;
    if (L <= l && R >= r)
        return d[rt].sum;
    long long res = 0;
    int mid = (l + r) >> 1;
    if (L <= mid)
        res += query(L, R, l, mid, rtl);
    if (R >= mid + 1)
        res += query(L, R, mid + 1, r, rtr);
    return res;
}
int main()
{
    int n;
    long long ans = 0;
    scanf("%d", &n);
    int tot = 0;
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d", a + i);
        tmp[++tot] = ++a[i];
    } // 离散化,二分,树状数组
    sort(tmp + 1, tmp + 1 + tot);
    tot = unique(tmp + 1, tmp + 1 + tot) - tmp - 1;
    for (int i = 1; i <= n; ++i)
    {
        a[i] = lower_bound(tmp + 1, tmp + 1 + tot, a[i]) - tmp;
    }
    for (int i = 1; i <= n; ++i)
    {
        ans += query(a[i] + 1, tot, 1, tot, 1);
        add(a[i], 1, 1, tot, 1);
    }
    cout << ans;
    return 0;
}
```

## 十八、st表

[ST 表 - OI Wiki (oi-wiki.org)](https://oi-wiki.org//ds/sparse-table/)

[Problem - B - Codeforces](https://codeforces.com/contest/1973/problem/B)

可重复贡献问题的解决方案，区间最大，区间与，区间或

对于log计算  log[1]=0 log[2]=1; log[i+1]=log[i/2]+1;

f数组的理解采用倍增的想法

```c++
#include <bits/stdc++.h>
using namespace std;
const int logn = 21;
const int maxn = 2000001;
int f[maxn][logn + 1], Logn[maxn + 1];

int read() {  // 快读
  char c = getchar();
  int x = 0, f = 1;
  while (c < '0' || c > '9') {
    if (c == '-') f = -1;
    c = getchar();
  }
  while (c >= '0' && c <= '9') {
    x = x * 10 + c - '0';
    c = getchar();
  }
  return x * f;
}

void pre() {  // 准备工作，初始化
  Logn[1] = 0;
  Logn[2] = 1;
  for (int i = 3; i < maxn; i++) {
    Logn[i] = Logn[i / 2] + 1;
  }
}

int main() {
  int n = read(), m = read();
  for (int i = 1; i <= n; i++) f[i][0] = read();
  pre();
  for (int j = 1; j <= logn; j++)
    for (int i = 1; i + (1 << j) - 1 <= n; i++)
      f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);  // ST表具体实现
  for (int i = 1; i <= m; i++) {
    int x = read(), y = read();
    int s = Logn[y - x + 1];
    printf("%d\n", max(f[x][s], f[y - (1 << s) + 1][s]));
  }
  return 0;
}
```

