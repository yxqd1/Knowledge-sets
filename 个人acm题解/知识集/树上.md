## 一、基环树

## 二、树hash

### 有根树

```
#include <cctype>
#include <chrono>
#include <cstdio>
#include <random>
#include <set>
#include <vector>

typedef unsigned long long ull;

const ull mask = std::chrono::steady_clock::now().time_since_epoch().count();

ull shift(ull x) {
  x ^= mask;
  x ^= x << 13;
  x ^= x >> 7;
  x ^= x << 17;
  x ^= mask;
  return x;
}

const int N = 1e6 + 10;

int n;
ull hash[N];
std::vector<int> edge[N];
std::set<ull> trees;

void getHash(int x, int p) {
  hash[x] = 1;
  for (int i : edge[x]) {
    if (i == p) {
      continue;
    }
    getHash(i, x);
    hash[x] += shift(hash[i]);
  }
  trees.insert(hash[x]);
}

int main() {
  scanf("%d", &n);
  for (int i = 1; i < n; i++) {
    int u, v;
    scanf("%d%d", &u, &v);
    edge[u].push_back(v);
    edge[v].push_back(u);
  }
  getHash(1, 0);
  printf("%lu", trees.size());
}
//https://uoj.ac/problem/763
```

### 无根树

```c++
#include <chrono>
#include <cstdio>
#include <map>
#include <random>
#include <set>
#include <vector>

typedef unsigned long long ull;

const int N = 60, M = 998244353;
const ull mask = std::chrono::steady_clock::now().time_since_epoch().count();

ull shift(ull x) {
  x ^= mask;
  x ^= x << 13;
  x ^= x >> 7;
  x ^= x << 17;
  x ^= mask;
  return x;
}

std::vector<int> edge[N];
ull sub[N], root[N];
std::map<ull, int> trees;

void getSub(int x) {
  sub[x] = 1;
  for (int i : edge[x]) {
    getSub(i);
    sub[x] += shift(sub[i]);
  }
}

void getRoot(int x) {
  for (int i : edge[x]) {
    root[i] = sub[i] + shift(root[x] - shift(sub[i]));
    getRoot(i);
  }
}
//因为根不统一，所以需要对根进行在处理
int main() {
  int m;
  scanf("%d", &m);
  for (int t = 1; t <= m; t++) {
    int n, rt = 0;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
      int fa;
      scanf("%d", &fa);
      if (fa) {
        edge[fa].push_back(i);
      } else {
        rt = i;
      }
    }
    getSub(rt);
    root[rt] = sub[rt];
    getRoot(rt);
    ull hash = 1;
    for (int i = 1; i <= n; i++) {
      hash += shift(root[i]);
    }
    if (!trees.count(hash)) {
      trees[hash] = t;
    }
    printf("%d\n", trees[hash]);
    for (int i = 1; i <= n; i++) {
      edge[i].clear();
    }
  }
}
//https://www.luogu.com.cn/problem/P5043
```

## 二、tire树

```
#include <bits/stdc++.h>
using namespace std;
// #define int long long
const int maxj = 1e5 + 100;
struct Trie
{
    int son[maxj*27][27]={0};//阿拉伯字母，所以第一维几个*层数 ，第二维数据范围
    int idx=0;
    int cnt[maxj*27];
    void insert(string str)
    {
        int p = 0; // 类似指针，指向当前节点
        for (int i = 0; str[i]; i++)
        {
            int u = str[i] - 'a'; // 将字母转化为数字
            if (!son[p][u])
                son[p][u] = ++idx;
            // 该节点不存在，创建节点,其值为下一个节点位置
            p = son[p][u]; // 使“p指针”指向下一个节点位置
        }
        cnt[p]++; // 结束时的标记，也是记录以此节点结束的字符串个数
    }
    int query(string str)
    {
        int p = 0;
        for (int i = 0; str[i]; i++)
        {
            int u = str[i] - 'a';
            if (!son[p][u])
                return 0; // 该节点不存在，即该字符串不存在
            p = son[p][u];
        }
        return cnt[p]; // 返回字符串出现的次数
    }
}tt;
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout); // a为add,,w
#endif
    string ss;cin>>ss;
    tt.insert(ss);
    if(tt.query("asd"))cout<<"1"<<'\n';
    else cout<<"0"<<'\n';
    return 0;
}
//https://ac.nowcoder.com/acm/contest/50135/E
//这个题别卡了好久的数据类型，开大了内存超限，开小了过不去
//https://codeforces.com/contest/1792/problem/D
//这个板子，好像每次时间和空间都很紧张
//https://codeforces.com/contest/557/problem/E
//半回文子串+dp+字典树的特殊处理
```

