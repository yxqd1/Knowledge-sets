---

---

# 动态规划

动态规划，有重复子问题，往往有递归方程，这个往往可以演绎出递推方程，

## 背包问题

### 01背包

#### 题目描述：

有 N件物品和一个容量是 V的背包。每件物品只能使用一次。

#### 状态表示：

前i个物品，占用体积v的价值最大

#### 集合划分：

第i个物品可以选（容量减小，价值变大），可以不选（容量价值不变）

#### 代码：

```c++
for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=v[i];j--)
        {
            dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
        }
    }
```



### 完全背包

#### 题目描述：

有 N 种物品和一个容量是 V的背包，每种物品都有无限件可用。

#### 状态表示：

前i个物品，占用体积v的价值最大

#### 集合划分：

第i个物品可以选（容量减小，价值变大），可以不选（容量价值不变）

从小到大更新，更新f[i,j],从大到小更新,更新f[i-1,j];

公式试推导出来的

f[i,j]=f[i,j-v]+w...

f[i,j-v]=f[j-v*2]+w....

=>当前公式

#### 代码：

```c++
  for (int i = 1; i <= n; i ++ )
        for (int j = v[i]; j <= m; j ++ )
            f[j] = max(f[j], f[j - v[i]] + w[i]);
```



### 多重背包

#### 题目描述：

有 N种物品和一个容量是 V 的背包。

第 i种物品最多有 si 件，每件体积是 vi，价值是 wi。

#### 状态表示：

前i个物品，占用体积v的价值最大

#### 集合划分：

第i个物品可以选（容量减小，价值变大），可以不选（容量价值不变）

注意可以运用区间的可分性，采用倍增来做题。

通过倍增分组，然后采用01背包来做题

#### 代码：

```c++
int n,v0;
    cin>>n>>v0;
    //多重背包涉及倍增优化，分组的优化,转化成01背包
    int cnt=0;
    for(int i=1;i<=n;++i){
        int vv,ww,ss;
        cin>>vv>>ww>>ss;
        int now=1;
        while(ss>0){
            now=min(ss,now);
            v[++cnt]=vv*now;
            w[cnt]=ww*now;
            ss-=now;
            now*=2;
        }
        if(ss>0){
            v[++cnt]=vv*ss;
            w[cnt]=ww*ss;
        }
        // cout<<0
    }
    // for(int i=1;i<=cnt;++i)cout<<v[i]<<' ';
    n=cnt;
    for(int i=1;i<=n;++i){
        for(int j=v0;j>=v[i];--j){
            f[j]=max(f[j],f[j-v[i]]+w[i]);
        }
    }
    cout<<f[v0]<<'\n';
```



### 分组背包

#### 题目描述：

有 N组物品和一个容量是 V的背包。

每组物品有若干个，同一组内的物品最多只能选一个。

#### 状态表示：

前i个物品，占用体积v的价值最大

#### 集合划分：

第i个物品可以选（容量减小，价值变大），可以不选（容量价值不变）

第一维第几组

第二维多大重量，从大到小，采用01背包的打法

第三维遍历所有情况，拿到最优解

#### 代码：

```
for(int i=1;i<=n;++i){
        cin>>x[i];
        for(int j=1;j<=x[i];++j){
            cin>>v[i][j]>>w[i][j];
        }
    }
    // f[0]=1;，方向错了，正着完全背包，反着01背包
    for(int i=1;i<=n;++i){
        for(int j=v0;j>=1;--j){
            for(int k=1;k<=x[i];++k){
                if(j>=v[i][k]){
                    f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);
                }
            }
        }
    }
```



## 线性DP

### lcs（最长公共子序列

#### 板子：

```c++
//https://www.luogu.com.cn/problem/P1439
void solve(){
    int n;cin>>n;
    unordered_map<int,int>mp;//由于a全排列，所以记录每个数在a中的位置
    for(int i=1;i<=n;++i){
        cin>>a[i];
        mp[a[i]]=i;
        dp[i]=1e12;
    }
    for(int i=1;i<=n;++i){
        cin>>b[i];
    }
    //最长上升子序列+最长公共子序列
    int len=0;
    dp[0]=0;
    for(int i=1;i<=n;++i){
        int l=0,r=len;
        if(mp[b[i]]>dp[len])dp[++len]=mp[b[i]];//如果当前位置靠后，那么就可以添加进这个数，
        else {
            int ans=0;
            //dp数组满足单调性，所以可以二分更新右边界+1，右边界+1的位置尽可能小，那么才可能加进更多的数
            while(l<=r){
                int mid=l+r>>1;
                if(dp[mid]>mp[b[i]]){
                    r=mid-1;
                }else {
                    l=mid+1;
                    ans=mid;
                }
            }
            ans++;
            dp[ans]=min(dp[ans],mp[b[i]]);
        }
    }
    cout<<len<<'\n';
}   
```

### Lis（最长上升子序列

#### 板子

```c++

```



### Lcp（最长公共前缀

https://codeforces.com/contest/611/problem/D

#### 板子

```c++
 //lcp加dp，这个题个人觉得挺难的
int dp[5500][5500],sum[5500][5500];
int n;string s;
int lcp[5500][5500];//字符串长度，第i到最后，和第j到最后的lcp公共长度
void getLcp() //最长公共前缀lcp
{
    for (int i = n; i > 0; i--)
    {
        for (int j = n; j > i; j--)
        {
            if (s[i] == s[j]) lcp[i][j] = lcp[i + 1][j + 1] + 1;
            else lcp[i][j] = 0;
        }
    }
} 
bool check(int x,int y){//长度一样的起始位置
    char a1=s[x+lcp[x][y]];
    char a2=s[y+lcp[x][y]];
    if(a1<a2)return 1;
    return 0;
}
void solve()
{
    //主要在解决两个问题，
    //如何节省字符串大小比较的复杂度，---采用lcp来O1的比较
    //dp方程如何设，---dp[i][j]第i个位置，后边j长度的合理答案
    cin>>n;
    cin>>s;
    s=' '+s;
    getLcp();

    for(int i=0;i<=n;++i)sum[0][i]=1;//初始化
    for(int i=1;i<=n;++i){
        for(int len=1;len<=i;++len){//到i位置的长度
            int j=i-len+1;//起始位置
            if(s[j]=='0')continue;
            //长度绝对可控的时候
            dp[i][len]=sum[j-1][len-1];//由前边位置转移过来，前边的个数小
            int pre=j-len;//长度一样的时候的初始位置
            if(pre<1)continue;
            if(check(pre,j)&&lcp[pre][j]<len){//
                dp[i][len]=(dp[i][len]+ dp[j-1][len])%MOD;//在长度相等的情况下，由之前的转移过来
            }
        }
        for(int j=1;j<=n;++j){
            sum[i][j]=(sum[i][j-1]+dp[i][j])%MOD;//累计所有情况,错在，sum--相同结束的地方，然后一定长度下，由上一个长度转移过来
        }
    }

    int ans=0;
    for(int i=1;i<=n;++i){
        ans=(ans+dp[n][i])%MOD;
    }
    cout<<ans%MOD<<'\n';
}
```



## 区间DP

思路比较固定，代码比较板子，状态和集合划分比较简一

dp[i,j,01]或者dp[i,j]，ij一般表示区间，01一般表示左加还是右加

### [P3205 [HNOI2010\]合唱队 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3205)

#### 状态和集合划分

dp[i,j,01]表示从i到j，在左还是在右添加，注意初始化和价值改变

在左：

从左来0

从右来1

在右：

从左来0

从右来1

```c++

int a[maxj];
int dp[2000][2000][2];
void solve(){
	//多少种排列方式使得结果是理想型
	//问题的逆向，以理想型为结果，找多少种方式可以到达
	int n;cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i];
	}
	//区间dp ，区间上可以做到分解合并新增元素 
	//初始化,其实就是一个顺序问题 
	for(int i=1;i<=n;++i){
		dp[i][i][0]=1;
	} 
	//第一维往往是长度 
	for(int len=1;len<=n;++len){
		//第二维往往是左端点 
		for(int l=1,r=l+len;l<=n&&r<=n;++l,++r){
			//第三维可能是切块或者左右移动
			//向左移动 
			if(a[l]<a[r])dp[l][r][0]=(dp[l][r][0]+dp[l+1][r][1])%mod;
			if(a[l]<a[l+1])dp[l][r][0]=(dp[l][r][0]+dp[l+1][r][0])%mod;
			
			//向右移动
			if(a[r]>a[r-1])dp[l][r][1]=(dp[l][r][1]+dp[l][r-1][1])%mod;
			if(a[r]>a[l])dp[l][r][1]=(dp[l][r][1]+dp[l][r-1][0])%mod;
			dp[l][r][0]%=mod;
			dp[l][r][1]%=mod; 
		}
	}
	cout<<(dp[1][n][0]+dp[1][n][1])%mod<<'\n';
}   
```

### [P4170 [CQOI2007\]涂色 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4170)

#### 状态和集合划分

因为是涂色，所以可以区间合并，区间添加元素往往是区间dp

dp[i,j]从i到j涂色的所有搭配数量

l和r颜色一样，从中间选最小

不一样，中间选择，合并找到最小，价值增加在于两个区间各自最小的颜色方案数的求和

```c++
int a[maxj];
int dp[2000][2000];
void solve(){
	//区间dp,新增新的元素 
	string s;cin>>s;
	int n=s.size();
	s=' '+s;
	//基本的板子+集合划分（分堆，区间新增元素的理解
	//初始化
	//因为有最小的选择，所以初始化到最大 
	memset(dp,0x3f3f3f3f,sizeof(dp));
	for(int i=1;i<=n;++i){
		dp[i][i]=1;
	} 
	for(int len = 1;len <= n;++len){
		for(int l=1,r=l+len;r<=n&&l<=n;++l,++r){
			//增加元素
			if(s[l]==s[r]){
				dp[l][r]=min(dp[l][r-1],dp[l+1][r]);
			}else {
				//我理解是最优子结构，由小部分组合成大部分
				for(int k=l;k<r;++k){//右端点不等，因为需要留一个 
					dp[l][r]=min(dp[l][r],dp[l][k]+dp[k+1][r]);
				} 
			}
		}    
	} 
	cout<<dp[1][n]<<'\n'; 
}
```

### [P1220 关路灯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1220)

#### 状态和集合划分

区间dp的题很固定，状态往往直接设，循环方程往往是固定的形式，

向左向右的题，往往开三维，直接设，遍历的去走

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
int dp[100][100][3];
int a[100],b[100];
int sum[100];
int n,c;
signed main(){
	//区间dp，要适当处理调头这一动作
	//左右移动和分堆的题和板子没啥区别 
	cin>>n>>c;
	for(int i=1;i<=n;++i){
		cin>>a[i]>>b[i];
		sum[i]=sum[i-1]+b[i];
	}	
	memset(dp,0x3f3f3f3f,sizeof(dp));
	//向两端遍历
	//初始化 
	dp[c][c][0]=dp[c][c][1]=0;
	//第一维是长度 
	for(int len = 1;len<=n;++len){
		//第二维是左端点 
		for(int l=1;l+len<=n;++l){
			int r=l+len;
			//多增的功率，在于当前和未被关闭得灯的功率*累加的时间 
			//从左边转移过来 
			if(l+1<=r)
			dp[l][r][0]=min(dp[l+1][r][1]+(a[r]-a[l])*(sum[l]+sum[n]-sum[r]),dp[l+1][r][0]+(a[l+1]-a[l])*(sum[l]+sum[n]-sum[r]));
//			dp[l][r][0]=min(dp[l][r][0],);
			//从右边转移过来 
			if(l<=r-1)
			dp[l][r][1] = min(dp[l][r-1][1]+(a[r]-a[r-1])*(sum[l-1]+sum[n]-sum[r-1]),dp[l][r-1][0]+(a[r]-a[l])*(sum[l-1]+sum[n]-sum[r-1]));
//			dp[l][r][1]=min(dp[l][r][1],);
		}
	}
	cout<<min(dp[1][n][0],dp[1][n][1]) <<'\n';
    return 0;
}
```

### [Problem - H - Codeforces](https://codeforces.com/group/QJA47ykHfD/contest/437692/problem/H)

#### 思路：

![image-20230410092323837](C:\Users\30279\AppData\Roaming\Typora\typora-user-images\image-20230410092323837.png)

区间dp有O(n^3)和O(n^2)两种打法，前者用k分块，后者从区间中间向区间两边进军，后者需要考虑区间两端的变化就可以。

```c++
dp[l][r]=dp[l+1][r-1]+a[r]*b[l]+a[l]*b[r]-a[l]*b[l]-a[r]*b[r];
```

dp[l ] [r ]表示l到r  反转后对于答案的贡献，然后对于所有a*b求和，加上最大的dp[l ] [r ]即为答案。

### [P1063 [NOIP2006 提高组\] 能量项链 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1063)

#### 思路：

矩阵连乘问题，多了个循环（多开一倍的空间），

len上限n，右区间的上限2*n，最后是，dp[i ] [i+n-1]因为长度是n所以必须减1，要不然就多了。

具体的转移控制下标：

```
dp[l][r]=max(dp[l][r],dp[l][k]+dp[k+1][r]+p[l]*p[k+1]*p[r+1]);//拼接
```



## 图上的dp

### [P1613 跑路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1613)

#### 状态和集合划分

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
vector<int>g[100];
//floyd算法+倍增+dp（Floyd本身就是图上暴力dp的一种
//第三维记载二进制 
int dis[100][100][100];//初始化dp数组使用 
int dp[100][100];//答案数组 
signed main(){
	int n,m;cin>>n>>m;
	//输入 
	memset(dp,0x3f3f3f3f,sizeof(dp));
	for(int i=1;i<=m;++i){
		int u,v;cin>>u>>v;
		dis[u][v][0]=1;
		dis[v][u][0]=1;
		dp[u][v]=1;//这里需要初始化，本身一步就可达 
	}
	//初始化dp数组 
	for(int k=1;k<=64;++k){
		for(int t=1;t<=n;++t){
			for(int i=1;i<=n;++i){
				for(int j=1;j<=n;++j){
					if(dis[i][t][k-1]==1&&dis[t][j][k-1]==1)
					dis[i][j][k]=1,dp[i][j]=1;
				}
			}
		}
	}
	//Floyd算法

		for(int t=1;t<=n;++t){
			for(int i=1;i<=n;++i){
				for(int j=1;j<=n;++j){
					dp[i][j]=min(dp[i][t]+dp[t][j],dp[i][j]);
				}
			}
		}
	
	cout<<dp[1][n]<<'\n';
    return 0;
}
```

## 状压dp（未完

最主要的在于二进制枚举子集，在于对状态的枚举和筛选

### 类型1：棋盘上的状压dp，

1）暴力列的所有状态，选择合适的状态（同行间的限制

2）暴力所有状态的组合，记录不同行间的限制

3）注意位置的限制，之后进行状态的转移

### 类型2：覆盖问题





### 小国王（类型1

[1064. 小国王 - AcWing题库](https://www.acwing.com/problem/content/1066/)

#### 思路

注意check函数--同行间的限制

注意count--行状态的1的个数

注意状态的转移

#### 代码：

```c++
int cnt[1200];
int id[1200];
vector<int>head[2000];
vector<int>state;
int check(int x){
    //格子不能相邻
    for(int i=0;i<12;++i){
        if(((x>>i)&1)&&((x>>(i+1))&1)){
            return 0;
        }
    }
    return  1;
}
int count(int x){
    int res=0;
    for(int i=0;i<12;++i){
        if((x>>i)&1)res++;
    }
    return res;
}
int dp[12][2000][2000];//第几行多少个国王并且状态是什么。
//一种是按行设变量，一种是按属性类去设变量
void solve(){
    int n,k;cin>>n>>k;
    //n*n放k个精确覆盖
    //棋盘类型的dp
    //预处理需要暴力的数组,二进制暴力
    for(int i=0;i<(1<<n);++i){
        if(check(i)){
            state.emplace_back(i);
            cnt[i]=count(i);
            // id[i]=state.size()-1;
        }
    }
    //暴力i，j选择合适
    for(int  i=0;i<state.size();++i){
        for(int j=0;j<state.size();++j){
            int ii=state[i],jj=state[j];
            if((ii&jj)==0&&(check(ii|jj)))
                //反了
            head[i].emplace_back(j);//说明i可以由j迁移过来,一个i可以由多少个j迁移过来
        }
    }
    dp[0][0][0]=1;
    for(int i=1;i<=n+1;++i){
    for(int kk=0;kk<=k;++kk)
        for(int j=0;j<state.size();++j){
            //暴力可以到达的所有状态
            // int now=state[j];
            for(auto jj:head[j]){
                //这里记录的是下标
                //jj和j都只是状态的下标
                int c=cnt[state[j]];
                // cout<<state[j]<<' ';
                if(kk>=c){
                    dp[i][kk][j]+=dp[i-1][kk-c][jj];
                    // cout<<dp[i][kk][j]<<' '; 
                }
                
            }
        }
    }
    cout<<dp[n+1][k][0]<<'\n';
}
```

### 炮兵阵地（类型1

[292. 炮兵阵地 - AcWing题库](https://www.acwing.com/problem/content/294/)

#### 思路

注意check函数--同行间的限制，当前格的右边和右右边都不可以有

注意count--行状态的1的个数，对应状态的1的个数

注意状态的转移--dp[2] [pre] [now],now当前行对应状态的下标，pre是上一行对应状态的下标

注意w【】用于记录不可以放置大炮的位置，所有操作都是通过位运算进行的。

#### 代码

```c++
char c[120][12];
vector<int>state;
int cnt[2000];
int w[120];//记录当前行的状态，山地在哪一行里有没有
bool check(int state){
    for(int i=0;i<12;++i){
        //当前的右边两个都是不可行的,错了
        if ((state >> i & 1) && ((state >> i + 1 & 1) || (state >> i + 2 & 1)))
            return false;
    }
    return 1;
    // if((x>>i&1)&&((x+1>>i&1)||(x+2>>i&1))){
    //         return 0;
    //     }
}
int count(int x){
    int res=0;
    for(int i=0;i<12;++i){
        if((x>>i)&1)res++;
    }
    return res;
}
int dp[2][2000][2000];
//所有的有和没有都会采用二进制优化
void solve(){
    //需要处理上两行右三列，合理位置处理答案数组
    int n,m;cin>>n>>m;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            cin>>c[i][j];
            if(c[i][j]=='H')w[i]|=1<<(j-1);
        }
    }
    for(int i=0;i<(1<<m);++i){
        if(check(i)){//筛选合适的子集，并进行子集划分
            state.emplace_back(i);
            cnt[i]=count(i);
            // cout<<i<<' ';
        }
    }
    // dp[0][0][0]=1;
    //数组更新的下标是state的位置
    for(int id=1;id<=n;++id)//第几行
    for(int i=0;i<state.size();++i){
        for(int j=0;j<state.size();++j){
            for(int k=0;k<state.size();++k){
                int a=state[j],b=state[i],c=state[k];
                // cout<<w[id]<<' ';
                if((w[id]&a)||(w[id-1]&b))continue;
                if((a&b)||(b&c)||(a&c))continue;
                    //采用滚动数组进行优化，第一维是滚动数组，第二维是上一行的状态，第三维是当前行的状态
                    dp[id&1][i][j]=max(dp[id&1][i][j],dp[id-1&1][k][i]+cnt[a]);
                    // cout<<a<<' ';
                
            }
        }
    }
    int ans=0;
    // for(int i=0;i<=1;++i){
        for(int j=0;j<state.size();++j){
            for(int z=0;z<state.size();++z){
                ans=max(ans,dp[n&1][j][z]);
            }
        }
    // }
    cout<<ans<<'\n';
}
```

### 愤怒的小鸟

[524. 愤怒的小鸟 - AcWing题库](https://www.acwing.com/problem/content/526/)

#### 思路：



#### 代码：

## 数位dp

[算法学习笔记(22)：数位DP（数位动态规划） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/613107701)

前缀和的思想很重要，一般涉及的是对于每一个数位的限制。

### 板子

```c++
ll dp[20][70][2000][2][2];
ll a[100];
ll dfs(ll b/*进制*/,ll len/*当前枚举第几位*/,int f/*是否有前导零*/,ll state/*对应二进制为各数字状态*/,int limit/*是否处在边界*/){
	ll res=0;
	if(!len){
		return !state;//各位置都为0,则表示各位置都取了偶数次 
	}
	if(dp[b][len][state][f][limit]!=-1){
		return dp[b][len][state][f][limit];
	}
	int top=b-1;
	if(limit){
		top=a[len];
	}	
	for(int i=0;i<=top;i++){
		if(i==0&&f){
			res+=dfs(b,len-1,1,state,limit&&(i==top));
		}
		else{
			res+=dfs(b,len-1,0,state^(1<<i),limit&&(i==top));
		}
	}
	dp[b][len][state][f][limit]=res;
	return res;
}
ll cal(ll b,ll d){
	int res=0;
	while(d){
		a[++res]=d%b;
		d/=b;
	}
	return dfs(b,res,1,0,1);
}
int main(){
/*cout<<setiosflags(ios::fixed)<<setprecision(8)<<ans<<endl;//输出ans（float）格式控制为8位小数（不含整数部分）*/
/*cout<<setprecision(8)<<ans<<endl;//输出ans（float）格式控制为8位小数（含整数部分）*/
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);//同步流
	memset(dp,-1,sizeof(dp));
	int t;
	cin>>t;
	while(t--){
		ll b,l,r;
		cin>>b>>l>>r;
		cout<<cal(b,r)-cal(b,l-1)<<endl;
	}
	return 0;
}
//题目链接：https://codeforces.com/contest/855/problem/E
//（代码参考:）  https://blog.csdn.net/jk211766/article/details/81474632
//(过程讲解参考:)   https://www.cnblogs.com/young-children/articles/11351588.html
```

### 一、C. Unlucky Numbers

[Problem - C - Codeforces](https://codeforces.com/contest/1808/problem/C)

#### 思路：

有的地方可能炸掉了，但是开成ull就可以了

这个题，枚举暴力每位最大和最小的差值，然后dfs（其实是暴力），之后枚举每位下界，每一位，从上界到下界开是否可行，找到可行的最大数，此时符合条件即可，

其实就是对于每一位进行有限制的暴力

```c++
int ans=0;
    //每一位的变化左界
    for(int nl=0;nl<=9;++nl){
        //对于每一位进行枚举暴力
        int now=0;
        for(int i=1;i<=len;++i){
            int nr=min((unsigned long long )9,de+nl);
            //枚举可行的所有情况
            for(int k=nr;k>=nl;--k){
                int las=now*10+k;
                for(int j=i+1;j<=len;++j){
                    las=las*10+nl;
                }
                if(las<=r){
                    now=now*10+k;
                    break;
                }
            }
        }
        ans=max(ans,now);
    }
```

### 二、E. Living Sequence

[Problem - E - Codeforces](https://codeforces.com/contest/1811/problem/E)

#### 思路:

在数位上的题，应该都可以用dp。dp本身就是一种思想。

二分找到合适的位置，然后进行数位dp，dp[i]表示当前位数符合条件的答案，

limt表示前一位是否达到上限，注意边界和暴力搜索

还有种想法--9进制，因为缺1位，所以转化成9进制，取余 ，然后判断是否小于4，不是就加1，因为缺一个4位

```c++
void solve(){
    int n;cin>>n;
    //10个数少一个数，因此可以转化成9进制，循环叠加
    string s="";
    while(n){
        s+=char('0'+((n%9)<4?(n%9):(n%9)+1));
        n/=9;
    }
    reverse(s.begin(),s.end());
    cout<<s<<'\n';
}   
```

## 换根dp

[【朝夕的ACM笔记】动态规划-换根DP - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/348349531)

- 其相比于一般的树形DP具有以下特点：

1，以树上的不同点作为根，其解不同。

2，故为求解答案，不能单求某点的信息，需要求解每个节点的信息。

3，故无法通过一次搜索完成答案的求解，因为一次搜索只能得到一个节点的答案。

- 换根DP的一般套路：

1，指定某个节点为根节点。

2，第一次搜索完成预处理（如子树大小等），同时得到该节点的解。

3，第二次搜索进行换根的动态规划，由已知解的节点推出相连节点的解。

### 一、[Problem - D - Codeforces](https://codeforces.com/contest/1805/problem/D)

#### 思路：

题意：边长至少为k的联通块的个数

策略：换根dp，每个节点更新到其它点的最长距离

这个问题：

首先更新一个点的最长，回溯更新now

其次更新其他点，深搜更新v

#### 代码：

```
//换根dp，比较板子
//题意边长至少为k的联通块的个数
void dfs1(int now,int fa){//从1开始的最远距离
    for(auto v:g[now]){
        if(v==fa)continue;
        dfs1(v,now);
        int no=dp1[v]+1;
        //更新最大距离和次大距离，回溯更新当前点
        if(no>dp1[now]){
            dp2[now]=dp1[now];
            dp1[now]=no;
        }else if(no>dp2[now]){
            dp2[now]=no;
        }
    }
}
void dfs2(int now,int fa){
    dis[now]=dp1[now];
    for(auto v:g[now]){
        if(v==fa)continue;
        //更新每个点的最大，这里有个树的直径，任一点最远距离的一个端点一定是直径的一端
        if(dp1[now]!=dp1[v]+1){//更新最大，这里指v没有在now到直径端点的路径上
            dp2[v]=dp1[v];
            dp1[v]=dp1[now]+1;//到直径的距离
        }else{//更新相对于now次大的路径,这时v在now到直径端点上
            if(dp2[now]+1>dp1[v]){
                dp2[v]=dp1[v];
                dp1[v]=dp2[now]+1;
            }else if(dp2[now]+1>dp2[v]){
                dp2[v]=dp2[now]+1;
            }
        }
        dfs2(v,now);
    }
}
```

## 树上dp

第一维通常是节点编号，一般先递归在它的每个子节点上进行dp，在回溯时，从子节点向节点x进行状态转移，

[树形DP 学习笔记 - zfz04 - 博客园 (cnblogs.com)](https://www.cnblogs.com/Wednesday-zfz/p/12209729.html)



题单：[0x2 树形dp - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/training/13994)

有时树上节点物品数量的统计很重要

### 一、节点类

[P1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1352)

```c++
void dfs(int now,int fa){
    //初始化的位置
    dp[now][0]=0;
    dp[now][1]=r[now];
    for(auto i:g[now]){
        if(i==fa)continue;
        dfs(i,now);
        //回溯更新所有节点
        dp[now][0]+=max(dp[i][0],dp[i][1]);//当前节点不要
        dp[now][1]+=dp[i][0];//当前节点要
    }
    
}
```

### 二、背包类

#### 2.1

[P2014 [CTSC1997\] 选课 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2014)

也可以是分组背包：最大容量，每组最多只要一个--分组背包或许更具一般性，可能是树形很适合孩子当成组，回溯选择最优二重循环这种结构了吧

```c++
//背包树形dp，判断容量，在树上进行选与不选
int dp[440][440];//当前节点,容量为j
int n,m;
void dfs(int now,int fa){
    //初始化的位置
    // dp[now][m]=1;
    for(auto i:g[now]){
        if(i==fa)continue;
        dfs(i,now);
        //转移的位置，m+1的原因是：0不应该要，但是为了将森林变成树，却要了，多了个状态
        for(int ii=m+1;ii>=1;--ii){
            for(int k=0;k<ii;++k){
                dp[now][ii]=max(dp[now][ii],dp[i][k]+dp[now][ii-k]);
            }
        }
    }
}
```

#### 2.2

[P1273 有线电视网 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1273)

分组背包



首先，状态和状态的转移

其次，初始化、预处理以及边界的处理

最后，在于答案的寻找

```c++
vector<pii>g[3400];
//背包树形dp，判断容量，在树上进行选与不选,集合的划分
int dp[3400][3400];//节点 当前节点多少用户  花费  换一下维度，题可能简单很多
int n,m;
int a[3400];
int dfs(int now,int fa){
    //初始化的位置
    if(now>n-m){//终端用户
        dp[now][1]=a[now];
        // cout<<dp[now][1]<<' ';
        return 1;
    }
    int sum=0;
    for(auto i:g[now]){
        if(i.first==fa)continue;
        int t=dfs(i.first,now);sum+=t;//sum记录该点用户数量
        //转移的位置,类似分组背包，暴力所有节点选择与不选择的情况
        for(int ii=sum;ii>=1;--ii){//01背包
            for(int j=1;j<=t;++j){//分组背包
                if(ii>=j)dp[now][ii]=max(dp[now][ii],dp[now][ii-j]+dp[i.first][j]-i.second);
            }
        }
    }
    return sum;
}
void solve()
{
    //之所以是树，有前后关系
    //之所以是背包，有选不选的问题
    cin>>n>>m;
    //dp初始化，很重要，要不然选择时，负的都比0小，所以无法记录负的
    memset(dp,~0x3f,sizeof(dp));
    for(int i=1;i<=n;++i)dp[i][0]=0;
    for(int i=1;i<=n-m;++i){
        int k;cin>>k;
        for(int j=1;j<=k;++j){
            int a,c;
            cin>>a>>c;
            g[i].emplace_back(a,c);
            g[a].emplace_back(i,c);
        }
    }
    for(int i=n-m+1;i<=n;++i){
        cin>>a[i];
    }
    dfs(1,0);
    int ans=0;
    for(int i=m;i>=1;--i){
        // cout<<dp[1][i]<<' ';
        if(dp[1][i]>=0){
            cout<<i<<'\n';
            return ;
        }
    }
}
```



### 三、扫描（换根dp

特点：给定一个树形结构，，需要以每个节点为根进行一系列统计。

换根dp一般采用二次扫描来求解

1，第一次扫描时，任选一个节点为根，在有根树上执行一次树形dp，也就是在回溯时发生的、自底向上的状态转移

2，第二次扫描时，从刚才选出的根出发，对整棵树执行一次深度优先遍历，在每次递归前进行自顶向下的推导，计算出“换根”后的解。

#### 3.1

[P2986 [USACO10MAR\] Great Cow Gathering G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2986)

换根的时候，要充分考虑原来的样子以及换根后的影响，考虑第一次扫描的情况

```
//关注怎么处理距离
//第一次是有根树,注意统计子树的数量
int dfs1(int now,int fa){
    int tot=0;
    for(auto i:g[now]){
        int v=i.first,w=i.second;
        if(v==fa)continue;
        int s=dfs1(v,now);
        tot+=s;
        //儿子节点的累加，每个儿子
        f1[now]+=s*w+f1[v];
    }
    return cnt[now]=tot+c[now];//记录当前树的牛的数量
}
//第二次需要画图，找变化,儿子节点=旧的儿子节点-从父亲节点退回+从父亲节点进入儿子节点
void dfs2(int now,int fa){
    for(auto i:g[now]){
        int v=i.first,w=i.second;
        if(v==fa)continue;
        //从now转移 , 水流没有孩子数量的问题,这个假设都先到1号节点，然后进行转移，所以没有旧的数组
        f2[v]=f2[now]-cnt[v]*w+(sum-cnt[v])*w;
        dfs2(v,now);
    }
}
void solve()
{
    //不确定根，有最优的选择，无法贪心--换根dp
    int n;cin>>n;
    for(int i=1;i<=n;++i){
        cin>>c[i];
        sum+=c[i];//sum求错了，NM
    }
    for(int i=1,u,v,w;i<n;++i){
        cin>>u>>v>>w;
        // sum+=w;
        g[u].emplace_back(v,w);
        g[v].emplace_back(u,w);
    }
    dfs1(1,0);
    // f2[1]=f1[1];
    dfs2(1,0);
    int mn=inf;
    for(int i=1;i<=n;++i){
        if(f2[i]<mn){
            mn=f2[i];
        }
    }
    //补充起始数组大小
    cout<<mn+f1[1]<<'\n';

}
```

#### 3.2有点难，多做一下

[Problem - 708C - Codeforces](https://codeforces.com/problemset/problem/708/C)

```c++
//不是重心但是可以是重心--有且只有一个节点尺寸》=n/2，让这个节点的尺寸《=n/2字树接到根上，使之符合条件
//因此，转移的时候就是在找是否存在这么个子树的子树，使之成为重心
vector<int>g[maxj];
int ans[maxj];
int f1[maxj][3]; //节点 0表示第一大 1表示第二大  准确的说是子树的最大尺寸
int f2[maxj];    //换根后子树的最大情况
int maxsiz[maxj];
int siz[maxj];
int las[maxj];
int n;
void dfs1(int now,int fa){
    siz[now]=1;
    // maxsiz[now]=1;
    for(auto i:g[now]){
        if(i==fa)continue;
        dfs1(i,now);
        //回溯转移
        siz[now]+=siz[i];
        int v;
        //更新最大子树
        if(siz[i]>siz[maxsiz[now]])maxsiz[now]=i;
        //更新可行的最大尺寸
        if(siz[i]<=n/2)v=siz[i];
        else v=f1[i][0];
        //更新最大和最小
        if(v>f1[now][0]){
            f1[now][1]=f1[now][0];
            f1[now][0]=v;
            las[now]=i;
        }else if(v>f1[now][1])f1[now][1]=v;
    }
}
void dfs2(int now,int fa){
    ans[now]=1;
    //if判断的是不行的情况，然后改变看行不行
    if(siz[maxsiz[now]]>n/2)ans[now]=(siz[maxsiz[now]]-f1[maxsiz[now]][0]<=n/2);
    else if(n-siz[now]>n/2)ans[now]=(n-siz[now]-f2[now]<=n/2);
    for(auto i:g[now]){
        if(i==fa)continue;
        //递归换根
        int v;
        //一直在找不合适的情况
        if(n-siz[now]>n/2)v=f2[now];
        else v=n-siz[now];//记录可能是重心的情况
        f2[i]=max(f2[i],v);
        //记载相应子树的子树的最大，然后为剪枝做准备
        if(las[now]==i){
            f2[i]=max(f2[i],f1[now][1]);
        }else{
            f2[i]=max(f2[i],f1[now][0]);
        }
        dfs2(i,now);
    }
}
```

## DDP动态动态规划

动态规划维护的部分数据是变化的

### 一、[Problem - E - Codeforces](https://codeforces.com/contest/1814/problem/E)

题解参考：

[Educational Codeforces Round 146 (Rated for Div. 2) ABCE - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/620545656)

参考知识：

[【数据结构 数学 线段树 矩阵乘法 动态dp】SP1716 GSS3 Can you answer these queries III_动态dp sp1716_nymph181的博客-CSDN博客](https://blog.csdn.net/SSL_hzb/article/details/99360804)

#### 思路：

本身dp，但是一直在维护询问，所以需要动态dp，

线段树上dp，普通的正解是什么，dp转移的策略是什么

 动态动态规划=矩阵乘法+dp转移+线段树（二叉树）

#### 矩阵乘法+dp转移板子：

```c++
struct Mat {
    LL a[2][2];
    Mat operator*(const Mat& T) const {
        Mat res;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                res.a[i][j] = INF;
                for (int k = 0; k < 2; k++) {
                    res.a[i][j] = min(res.a[i][j], a[i][k] + T.a[k][j]);//res是答案，a是当前，T是对象
                }
            }
        }
        return res;
    }
};
```

## 单调队列优化dp

### 知识：

维护区间长度<=m的最值，

有几个要素很重要：

1，适用：维护区间长度不大于m的最值

2，结合：dp转移方程，前缀和，二分，二维

3，注意：hh变化的条件和题意有关，对谁的单调区间（也就是谁和谁的比较使得tt--

### 滑动窗口的板子：

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+100;
int a[N],q[N];
signed main(){
    int n,m;
    scanf("%lld %lld",&n,&m);
    for(int i=1;i<=n;++i)scanf("%lld",&a[i]);
    //模拟队列
    int hh=0,tt=-1;
    //先说最小
    for(int i=1;i<=n;++i){
        if(hh<=tt&&q[hh]<=i-m)hh++;
        while(hh<=tt&&a[q[tt]]>=a[i])tt--;
        q[++tt]=i;
        if(i>=m)printf("%lld ",a[q[hh]]);
    }
    cout<<'\n';
    //再说最大
    hh=0,tt=-1;
    for(int i=1;i<=n;++i){
        if(hh<=tt&&q[hh]<=i-m)hh++;
        while(hh<=tt&&a[q[tt]]<=a[i])tt--;
        q[++tt]=i;
        if(i>=m)printf("%lld ",a[q[hh]]);
    }
    cout<<'\n';
    return 0;
}
```

### 一、前缀和+单调队列优化dp

[135. 最大子序和 - AcWing题库](https://www.acwing.com/problem/content/description/137/)

```
/*
连续子序列，即子串
前缀和+单调队列优化
dp代表最后位置的值，转移方程
s[i]-min(s[j]) s[j]是距离不超过m范围的最小值，然后整体最大
*/
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;++i){
        cin>>a[i];
        s[i]=s[i-1]+a[i];
    }
    int hh=0,tt=0;
    int ans=-1e18;
    //以最后的位置为终点，维护长度为m的最大值,
    for(int i=1;i<=n;++i){
        //前缀和是l-1
        if(hh<=tt&&q[hh]<i-m)hh++;
        ans=max(ans,s[i]-s[q[hh]]);
        while(hh<=tt&&s[q[tt]]>=s[i])tt--;
        q[++tt]=i;
    }
    cout<<ans<<'\n';
    return 0;
}
```

### 二、二分+单调队列优化dp

[1090. 绿色通道 - AcWing题库](https://www.acwing.com/problem/content/1092/)



二分的本质在于区间单调，一半区间满足一般区间不满足

错的七零八落的，

```
/*

题意：在连续代价不大于t的前提下，中间消耗最小
策略：
二分中间消耗时间(答案)，观察t是否可以满足
最长的最小也在提示二分答案

单调队列维护的区间长度往往是不大于某个值
dp数组维护要当前位的代价和之前不得不要的最小代价

*/
bool check(int mid){
    for(int i=0;i<=n+1;++i)dp[i]=0;
    int hh=0,tt=0;
    //应该是维护区间最小值，求和不大于t
    for(int i=1;i<=n;++i){
        //小于临界,m个空，所以是m+1的最小值
        while(hh<=tt&&q[hh]<i-mid-1)hh++;
        //dp值维护累加选择的最小值
        dp[i]=dp[q[hh]]+a[i];
        //维护dp区间必用最小值
        while(hh<=tt&&dp[q[tt]]>=dp[i])tt--;
        q[++tt]=i;
    }
    //空的区间不能大于m
    if(q[hh]<n-mid)hh++;
    return dp[q[hh]]<=t;
}
void solve(){
    cin>>n>>t;
    for(int i=1;i<=n;++i){
        cin>>a[i];
    }
    int l=0,r=n;
    int ans=0;
    while(l<=r){
        int mid=l+r>>1;
        if(check(mid)){
            ans=mid;
            r=mid-1;
        }else l=mid+1;
    }
    cout<<ans<<'\n';
}
```



### 三、二维单调队列优化

[1091. 理想的正方形 - AcWing题库](https://www.acwing.com/problem/content/description/1093/)



先进行 行 间单调队列优化， 然后进行 列 间单调队列优化

tt--那里卡了半天，妈的，你不应该用队尾进行比较吗

```
/*
二维单调队列优化
先进行行间最值的选择
后进行列间最值的选择

*/
// 原数组 给谁 大小
void getmax(int a[],int b[],int cnt){
    int hh=0,tt=0;
    // q[0]=0;
    for(int i=1;i<=cnt;++i){
        while(hh<=tt&&q[hh]<=i-k)hh++;
        while(hh<=tt&&a[q[tt]]<=a[i])tt--;
        q[++tt]=i;
        b[i]=a[q[hh]];
    }
}
void getmin(int a[],int b[],int cnt){
    int hh=0,tt=0;
    // q[0]=0;
    for(int i=1;i<=cnt;++i){
        while(hh<=tt&&q[hh]<=i-k)hh++;
        while(hh<=tt&&a[q[tt]]>=a[i])tt--;
        q[++tt]=i;
        b[i]=a[q[hh]];
    }
}
void solve(){
    cin>>n>>m>>k;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            cin>>x[i][j];
        }
    }
    //行间最小，最大
    for(int i=1;i<=n;++i){
        getmax(x[i],mx[i],m);
        getmin(x[i],mn[i],m);
    }
    //列间最小，最大
    int ans=1e9;
    for(int i=k;i<=m;++i){
        //先存起来
        for(int j=1;j<=n;++j){
            aa[j]=mx[j][i];
            bb[j]=mn[j][i];
        }
        getmax(aa,cc,n);
        getmin(bb,dd,n);
        // for(int j=1;j<=n;++j){
        //     cout<<cc[j]<<' ';
        // }cout<<'\n';
        for(int j=k;j<=n;++j){
            ans=min(ans,cc[j]-dd[j]);
        }
    }
    cout<<ans<<'\n';
}
```



### 四、其他

#### 4.1顺时针、逆时针分别维护最值

[1088. 旅行问题 - AcWing题库](https://www.acwing.com/problem/content/1090/)

成环的解决方案：破环为链

核心难点：顺时针（逆时针）时o-d的前缀和一致为正

最好采用相同的思想,s维护差值的前缀和--全部维护后置的最小，但是要下一个位置不大于后边的最小，以下一个位置为定点，遍历n长度前缀最小，保证前缀不负

```
/*
成环问题：破环成链
可以顺时针走或者逆时针走,
最好采用相同的思想,s维护差值的前缀和
*/
void solve(){
    int n;cin>>n;
    for(int i=1;i<=n;++i){
        cin>>o[i]>>d[i];
        o[n+i]=o[i];
        d[n+i]=d[i];
    }
    //每个点都要统计一遍
    //顺时针走，逆着来够大
    for(int i=1;i<=n;++i){
        s[i]=s[i+n]=o[i]-d[i];
    }
    for(int i=1;i<=2*n;++i){
        s[i]+=s[i-1];
    }
    int hh=0,tt=-1;
    // 全部维护后置的最小，但是要下一个位置不大于后边的最小，以下一个位置为定点，遍历n长度前缀最小，保证前缀不负
    for(int i=2*n;i>=1;--i){
        while(hh<=tt&&q[hh]>=i+n)hh++;
        while(hh<=tt&&s[q[tt]]>=s[i])tt--;
        q[++tt]=i;
        if(i<=n){
            ans[i]|=(s[i-1]<=s[q[hh]]);
        }
    }
    //注意下一个距离的变化
    d[0]=d[n];
    for(int i=1;i<=n;++i){
        s[i]=s[i+n]=o[i]-d[i-1];
    }
    for(int i=2*n;i>=1;--i){
        s[i]+=s[i+1];
    }
    hh=0,tt=-1;
    for(int i=1;i<=2*n;++i){
        while(hh<=tt&&q[hh]<=i-n)hh++;
        while(hh<=tt&&s[q[tt]]>=s[i])tt--;
        q[++tt]=i;
        if(i>n){
            ans[i-n]|=(s[i+1]<=s[q[hh]]);
        }
    }
    for(int i=1;i<=n;++i){
        if(ans[i])cout<<"TAK\n";
        else cout<<"NIE\n";
    }
}
```



#### 4.2待补

[1087. 修剪草坪 - AcWing题库](https://www.acwing.com/problem/content/1089/)



#### 4.3待补（洛谷

[P5858 「SWTR-03」Golden Sword - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5858)

#### 4.4

[Problem - B - Codeforces](https://codeforces.com/gym/104128/problem/B)



