# 常用的数学或者技巧

## 一、线性dp

[P4933 大师 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4933)

### 思路：

如何记载子序列不全为空且有次序可缺项的情况的总合，1 2 3  4  ans +1 +2 +3 +4           +1  +1  +1  +1

题意：子序列构成等差数列的情况的个数，

策略：线性dp，dp[i ] [ j ]表示以i为结尾，j为公差的情况数     ans记录总合，但是单个次序的记录的方法

```c++
int h[maxj];
int dp[1100][40010];//以i为结尾，以j为公差，总共的个数，重复子问题递推的求解。
void solve(){
    //n的个数支持立方的操作。
    int n;cin>>n;
    for(int i=1;i<=n;++i){
        cin>>h[i];
    }
    int ans=0;
    int p=20000;
    //转移，集合划分错了，排列组合，逐个求解可以表达所有可能,也就是说  +1 +2 +3 逐个加可以
    for(int i=1;i<=n;++i){
        ans++;//作为单个出现的时候
        for(int l=i-1;l>=1;--l){//01背包
            dp[i][h[i]-h[l]+p]+=dp[l][h[i]-h[l]+p]+1;//公差可能重复所以需要累加
            dp[i][h[i]-h[l]+p]%=mod;
            ans+=dp[l][h[i]-h[l]+p]+1;
            ans%=mod;
        }
    }
    cout<<ans<<'\n';
}  
```

## 二、置换环

 [置换环.md](..\分散题解\置换环.md) 

## 三、find函数

```c++
string ans=b+b;
auto pos=ans.find(a);
if(pos==ans.npos)
{
	cout<<"no this"<<'\n';
}
```

## 四、提示注意

涉及01==》二进制枚举  状压dp   01背包

某种意义上递归和递推是对仗的，可以相互转化。

时间单调的，对于求解某种具体的答案，可以用二分去做。

输入大的时候，一定要用较快的输入输出方式。

map太耗费空间，尽量别再函数内开太大的

邻接矩阵建图容易空间过大

边输入边处理容易出现各种问题

set之类有lower_bound函数的，最好使用se.lower_boud，不要用其他的，会T

## 五、一些函数

### 1、交换函数

[c++stl和std_std :: rotate（）函数以及C ++ STL中的示例_cumt951045的博客-CSDN博客](https://blog.csdn.net/cumt951045/article/details/107795673)

### 2、vector取最大值

```
cout << (*max_element(v.begin() + 1, v.end())) << '\n';
```

### 3、sort排序，内置规则

```c++
vector<vector<int>>a(n,vector<int>(m));
for(int i=0;i<n;++i){
    for(int j=0;j<m;++j){
        cin>>a[i][j];
    }
    vector<int>o(m);//用于排序记录位置
    iota(o.begin(),o.end(),0);//从0开始，逐个递增填充数
    sort(o.begin(),o.end(),
        [&](int x,int y){
            return a[i][x]>a[i][y];
        });//sort内置规则
    a[i]=o;
}
```

### 4，填充初始化函数

```c++
vector<int>a(100);
fill(a.begin(),a.end(),12);
```

### 5，find的边界

```c++
s.find(t)!=string::npos //不等号为真 表示存在这个字符串t
```

### 6，bitset

下面是 `std::bitset` 类型的一些常用操作：

- `size()` 返回 `std::bitset` 的长度
- `count()` 返回 `std::bitset` 中值为 1 的位的数量
- `any()` 返回 `std::bitset` 中是否存在值为 1 的位
- `none()` 返回 `std::bitset` 中是否所有位都是 0
- `all()` 返回 `std::bitset` 中是否所有位都是 1
- `test(pos)` 返回 `std::bitset` 中位于 `pos` 位置的值
- `set(pos)` 将 `std::bitset` 中位于 `pos` 位置的值设为 1
- `reset(pos)` 将 `std::bitset` 中位于 `pos` 位置的值设为 0
- `flip(pos)` 将 `std::bitset` 中位于 `pos` 位置的值取反
- `to_ulong()` 返回 `std::bitset` 转换成的无符号整数值
- `to_ullong()` 返回 `std::bitset` 转换成的无符号长整数值

`std::bitset` 重载了许多二进制运算符，如 `&`、`|`、`^`、`~` 等，使其支持类似于整数类型的位运算操作。

## 六、io快读

```
struct fio{ 
	inline char gc(){
		static const int IN_LEN = 1<<18|1;
		static char buf[IN_LEN] , *s , *t ;
		static streambuf *sb = cin.rdbuf();
		return (s==t)&&(t=(s=buf)+sb->sgetn(buf,IN_LEN)),s==t?-1:*s++;
	}
	inline fio & operator >> (string &s){
		static char ch ; ch = gc();
		s.clear();
		for(;isspace(ch);ch = gc()) if(ch == -1) return *this;
		for(;!isspace(ch) && ch != -1;ch = gc()) s+=ch;
		return *this;  
	}
	inline fio &operator >> (char * s){
		static char ch ; ch = gc();
		for(;isspace(ch);ch=gc()) if(ch == -1) return *this;
		for(;!isspace(ch)&&ch != -1;ch=gc()) *(s++) = ch;
		return *this;
	}
	inline void gtline(string& s){
		static char ch ; ch = gc();
		s.clear();
		for(;ch != '\n' && ch != -1;ch = gc()) s+=ch;
	}
	template <typename T > inline fio & operator >> (vector<T> & n){
		for(auto &it : n){
			*this >> it ;
		}
		return *this;
	}
	template <typename T > inline fio & operator >> (T &n){
		static char ch , sgn ;
		ch = gc() , sgn = 0 ;
		for(;!isdigit(ch);ch=gc()){if(ch==-1) return *this ;sgn|=ch=='-';}
		for(n=0;isdigit(ch);ch=gc()) n=n*10+(ch^'0');
		if(ch == '.'){
			T tmp = 0 ; ch = gc();
			for(; isdigit(ch) ; ch = gc()) tmp=tmp*10+(ch^'0');
			while(tmp>1)tmp/=10;
			n += tmp; 
		}
		sgn&&(n=-n);
		return *this;
	}
}io;
```

## 七、array

长度固定：因为长度固定，这里的元素个数不能是变量。

【】仍然有效：下标从0开始，可以使用【】来进行索引或者修改

| 成员函数            | 功能                                                         |
| ------------------- | ------------------------------------------------------------ |
| begin()             | 返回指向容器中第一个元素的随机访问迭代器。                   |
| end()               | 返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。 |
| rbegin()            | 返回指向最后一个元素的随机访问迭代器。                       |
| rend()              | 返回指向第一个元素之前一个位置的随机访问迭代器。             |
| cbegin()            | 和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。 |
| cend()              | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
| crbegin()           | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
| crend()             | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
| size()              | 返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。 |
| max_size()          | 返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。 |
| empty()             | 判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。 |
| at(n)               | 返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。 |
| front()             | 返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。 |
| back()              | 返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。 |
| data()              | 返回一个指向容器首个元素的[指针](http://c.biancheng.net/c/80/)。利用该指针，可实现复制容器中所有元素等类似功能。 |
| fill(val)           | 将 val 这个值赋值给容器中的每个元素。                        |
| array1.swap(array2) | 交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。 |

应用实例：



```c++
#include <iostream>
//需要引入 array 头文件
#include <array>
using namespace std;
int main()
{
    std::array<int, 4> values{};
    //初始化 values 容器为 {0,1,2,3}
    for (int i = 0; i < values.size(); i++) {
        values.at(i) = i;
    }
    //使用 get() 重载函数输出指定位置元素
    cout << get<3>(values) << endl;
    //如果容器不为空，则输出容器中所有的元素
    if (!values.empty()) {
        for (auto val = values.begin(); val < values.end(); val++) {
            cout << *val << " ";
        }
    }
}
//输出：
/*
3
0 1 2 3
*/
```

## 八、日期问题

有关日期问题有两点要特别关注：

- 有月份的问题往往涉及月份映射数组
- 2月要特判平年、闰年
- check判断很重要

## 九、精度问题

平均数可以乘1.0，可能有精度误差

除法可以转化为乘法问题，比如y>=(x+1)/2=>y*2>=x

## 十、dfs和bfs选择

走地图、迷等图上的，尤其是不返回的，最好用bfs。主要因为dfs需要另外加标记

[Problem - F - Codeforces](https://codeforces.com/contest/1933/problem/F)

必要的时候可以单独加距离数组

## 十一、c语言排序

