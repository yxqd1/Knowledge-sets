# 数论

## 一、exgcd

### 基本原理

#### 裴蜀定理：

a、b不全为0，则存在正整数x、y使得

ax+by=__gcd(a,b);

#### 欧几里得算法：

辗转相除法，求a、b的最大公因数

它的板子就是扩展欧几里得板子的简略版

#### 扩展欧几里得算法：

算裴蜀定理里的最小x、y

### 应用：

exgcd用于求解不定方程*ax+by=c*的一组解。准确的说，它是用来求解**ax+by=gcd(a,b)**的x和y。

欧几里得算法：两个数x和y的[最大公约数](https://so.csdn.net/so/search?q=最大公约数&spm=1001.2101.3001.7020)**gcd(x,y)=gcd(y,x%y).**

### 常见推导的理解：

通解的理解：

- 对于ax+by=d 

若求出来的是x0，y0

x=x0-k*(b/d)

y=y0+k*(a/d)

- 对于ax+by=m

x=x0*m/d

y=y0*m/d

### 板子：

```c++
// 求x, y，使得ax + by = gcd(a, b)
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```

### 例题1：[P1082 [NOIP2012 提高组\] 同余方程 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1082)

#### 取余操作推导总结：

​    a%b==c <=>a=b*k+c  <=> c=a-a/b * b

#### 思路

原来的取余可以转化为

ax+my=b  =>  x0 y0 => x=x0*b/d%m  y=y0 * b/d%m 

### 例题2：[Problem - A - Codeforces](https://codeforces.com/gym/104090/problem/A)

exgcd只是一种求二元不定方程x、y的一种工具

ns+n*(n+1)/2 *d+sum)%m最小

a=n,b=n*(n+1)/2

a*x+b *y+sum)%m

#### 求最小值：

ax+by=k1g1

k1g1%m  =>  k1g1+t*m = k2g2

最开始的式子转化为:

(k2g2+sum)%m

k2可以为负，尽可能让k2g2接近sum，所以相当于ans=sum%g2

#### 求x、y

ax+by=k1g1

k1g1+tm=ans-sum=k2g2

反向求解，求两次exgcd即可

```
//好多数学公式都和取余有关，推导猜测尝试
//注意下边的步骤
void solve(){
    int n,m,sum=0;
    cin>>n>>m;
    for(int i=1,x;i<=n;++i){
        cin>>x;
        sum+=x;
    }
    sum%=m;
    //明白exgcd公式的本质加上一点推导
    //求最小值
    int a=n,b=n*(n+1)/2,x,y,k1,t;
    int g1=__gcd(a,b);
    int g2=__gcd(g1,m);
    int ans=sum%g2;
    //求xy，利用方程组求
    exgcd(g1,m,k1,t);
    //这时的k1是最小的k1，不是实际公式里的
    k1=((ans-sum)/g2%m*k1%m+m)%m;
    exgcd(a,b,x,y);
    x=(x*k1%m+m)%m,y=(y*k1%m+m)%m;
    cout<<ans<<'\n';
    cout<<x<<' '<<y<<'\n';
}
```



## 二、中国剩余定理

### 基本原理

求解一元线性同余方程，其中m1 m2 m3.....两两互质

x≡a1(%m1)

x≡a2(%m2)

x≡a3(%m3)

.....

### 板子题

[204. 表达整数的奇怪方式 - AcWing题库](https://www.acwing.com/problem/content/206/)

推导大致采取两两合并线性推导的方式来推导的

有点问题

```c++
void solve(){
    //两两结合，转化为取余m余a
    int a1,m1,a2,m2,n,x;cin>>n;
    cin>>m1>>a1;
    for(int i=1;i<n;++i){
        cin>>m2>>a2;
        int k1,k2;
        //先记着用吧,a是公式右边的数
        int d=exgcd(m1,-m2,k1,k2);
        if((a2-a1)%d){
            x=-1;
            break;
        }
        a1=((a2-a1)*k1/d%(m2/d)+m2/d)%(m2/d)*m1+a1;
        m1=abs(m1/d*m2);
    }
    if(x!=-1)
    x=(a1%m1+m1)%m1;
    cout<<x<<'\n';
}
```



## 三、整除分块

[P2261 [CQOI2007\]余数求和 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2261)

### 板子：

```
for(int l=1,r;l<=n;l=r+1){
	if(k/l !=0)
		r=min(k/(k/l),n);
   	else r=n;
	//r=n/(n/l);//k实质是需要分块的区间长度，可以和循环的n不一样
	ans+=(r-l+1)*(k/l);//区间长度*区间值
}
```

因为**a%b=a-b*(a/b);**     向上取整和向下取整相互转换**「m/k = (m+k-1)/k」**

所以

原式=求和（k-i*(k/i))

=>n*k-求和(i/(k/i)),

所以

外围循环i的范围1-n

内围r=k/(k/l)   

ans-=k/l* (r-l+1) *(l+r)/2 //区间值 * 区间长度 * 平均每个值大小

## 四、博弈论

### 3.1 nim游戏，sg函数

##### 关于nim游戏

- 必胜态：可以一步到达必败态的状态
- 必败态：无论怎么走都会到达必胜态

若一个游戏满足：

1. ​	由两名玩家交替行动

2. ​	在游戏进行的任意时刻，可以执行的合法行动与轮到哪位玩家无关
3. ​	不能行动的玩家判负

​		则称该游戏为一个公平组合游戏。

​		尼姆游戏（NIM）属于公平组合游戏，但常见的棋类游戏，比如围棋就不是公平组合游戏，因为围棋交战双方分别只能落黑子和白子，胜负判定也比较负责，不满足条件2和3。

##### 关于sg函数

1.Mex运算:
		设S表示一个非负整数集合.定义mex(S)为求出不属于集合S的最小非负整数运算,即: mes(S)=min{x};
		例如:S={0,1,2,4},那么mes(S)=3;

2.SG函数
		在有向图游戏中,对于每个节点x,设从x出发共有k条有向边,分别到达节点y1,y2,····yk,定义SG(x)的后记节点y1,y2,····yk的SG函数值构成的集合在执行mex运算的结果,即: SG(x)=mex({SG(y1),SG(y2)····SG(yk)})
		特别地,整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值,即 SG(G)=SG(s).

3.有向图游戏的和
		设G1，G2,····,Gm是m个有向图游戏.定义有向图游戏G,他的行动规则是任选某个有向图游戏Gi,并在Gi上行动一步.G被称为有向图游戏G1,G2,·····,Gm的和.
		有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数的异或和,即: SG(G)=SG(G1)xorSG(G2)xor···xor SG(Gm)

#### 板子题：铁博文的号

[891. Nim游戏 - AcWing题库](https://www.acwing.com/problem/content/893/)

所有堆异或值为0则必败

[892. 台阶-Nim游戏 - AcWing题库](https://www.acwing.com/problem/content/894/)

```
//结论：奇数台阶的异或值为0，则必败
//理解：开始为0，后手可以让先手始终为0，后手可以跟随先手
//开始不为0，先手可以选择始终让后手为0的局面，从而使得后手必输
int n;cin>>n;
int ans=0;
for(int i=1,x;i<=n;++i){
    cin>>x;
    if(i&1){
        ans^=x;
    }
}
if(ans)cout<<"Yes"<<'\n';
else cout<<"No"<<'\n';
```

[893. 集合-Nim游戏 - AcWing题库](https://www.acwing.com/problem/content/895/)

sg函数，每一堆情况的异或和

```
int sg(int x)
{
    if(f[x]!=-1) return f[x];
    //因为取石子数目的集合是已经确定了的,所以每个数的sg值也都是确定的,如果存储过了,直接返回即可
    set<int> S;
    //set代表的是有序集合(注:因为在函数内部定义,所以下一次递归中的S不与本次相同)
    for(int i=0;i<m;i++)
    {
        int sum=s[i];
        if(x>=sum) S.insert(sg(x-sum));
        //先延伸到终点的sg值后,再从后往前排查出所有数的sg值
    }

    for(int i=0;;i++)
    //循环完之后可以进行选出最小的没有出现的自然数的操作
     if(!S.count(i))
      return f[x]=i;
}
```

[894. 拆分-Nim游戏 - AcWing题库](https://www.acwing.com/problem/content/896/)

sg函数，模拟每一堆的变化。

最大值变小，所以一定可以结束

```
int f[120];
//由大变小，模拟每一堆的变化
int sg(int x){
    //第一步：记忆化
    if(f[x]!=-1)return f[x];
    //第二步：递归模拟变化，找到所有的sg
    unordered_set<int>se;
    for(int i=0;i<x;++i){//两堆更小的子问题
        for(int j=0;j<=i;++j){
        //子问题的和，用^
            se.insert(sg(i)^sg(j));
        }
    }
    //第三步：mex函数
    for(int i=0;;i++){
        if(!se.count(i))return f[x]=i;
        
    }
}
```

## 五、容斥原理

### 基础原理：

公式：|A∪B∪C| = |A+B+C| - |A∩B| - |B∩C| - |C∩A| + |A∩B∩C|

一共有:2^n-1项

### 核心理解：

对于这类题往往采用二进制枚举子集，复杂度往往有2^n大小，需要先定义相关集合，并且要明确集合的计算方式。

1. 定义集合，明确公式
2. 计算集合大小，枚举计算
3. 返回答案

### 例题

#### 一、[890. 能被整除的数 - AcWing题库](https://www.acwing.com/problem/content/892/)

核心代码：

```int p[20];
int p[20];
void solve(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<m;++i){
        cin>>p[i];
    }
    int ans=0;
    //二进制枚举的方式解决容斥问题
    for(int i=1;i<(1<<m);++i){
        int cnt=0;//统计个数,奇数加，偶数减
        int now=1;//统计当前质数是谁
        for(int j=0;j<m;++j){
            if(i>>j&1){
                if(now*p[j]>n){
                    cnt=-1;
                    break;
                }
                cnt++;
                now*=p[j];
            }
        }
        // cout<<now<<'\n';
        if(cnt!=-1){
            if(cnt&1)ans+=n/now;
            else ans-=n/now;
        }
    }
    cout<<ans<<'\n';
}
```

#### 二、[214. Devu和鲜花 - AcWing题库](https://www.acwing.com/problem/content/216/)

核心理解：

公式推导：

所有的情况减去不成立的情况,不成立的情况在于取并集，所以容斥原理做

定义集合：si表示第i个盒子不合法

公式（正难则反）：C（n+m−1，n−1）−|s1|−|s2|−…−|sn|+|s1∩s2|+|s1∩s3|+…+|sn−1∩sn|−|s1∩s2∩s3|−…

si计算：C（n+m−1-(pi+1)，n−1）

​              因为每个至少pj个，所以也用了正难则反的想法，而且因为映射关系，所以要加1,表示从剩下m-pj里面在做选择

核心代码：



```c++
int down=1;
int n,m;
//所选的项数特别小，所以可以暴力计算组合数
int c(int a,int b){
    if(a<b||b<0)return 0;
    int up=1;
    for(int i=a;i>a-b;--i)up=i%mod*up%mod;//i可能很大
    return up*down%mod;
}
void solve(){

    cin>>n>>m;
    for(int i=0;i<n;++i){
        cin>>p[i];
    }
    down=1;
    for(int i=1;i<n;++i)down=down*i%mod;
    down=ksm(down,mod-2);
    // cout<<c(3,1)<<'\n';
    int ans=c(n+m-1,n-1);//答案是：所有的情况减去不成立的情况,不成立的情况在于取并集，所以容斥原理做
    // cout<<ans<<'\n';
    //容斥原理，遍历所有项的情况,
    for(int i=1;i<(1<<n);++i){
        int sign=1;
        int a=m+n-1,b=n-1;
        //
        for(int j=0;j<n;++j){
            if(i>>j&1){
                sign*=-1;
                //因为每个至少pj个，所以也用了正难则反的想法，而且因为映射关系，所以要加1
                a-=p[j]+1;
            }
        }
        // cout<<sign<<' '<<c(a,b)<<'\n';
        ans=(ans+sign*c(a,b)+mod)%mod;
    }
    cout<<ans<<'\n';
}
```

#### 三、[215. 破译密码 - AcWing题库](https://www.acwing.com/problem/content/description/217/)

核心理解：

有个问题的转换，通过a/d、b/d将问题转换成在a/d、b/d范围内两两互质的种类数（因为*d相当于公因子为d），而这个问题用莫比乌斯（辅助）、整除分块（降低复杂度）来解决刚好，运用容斥原理，总-单个质数+两个质数。。。（a在除l因为是除去质数得到种类数）

解决了质数数量问题，使用了莫比乌斯函数、整除分块、前缀和优化、公式推导相关的知识。

采用了正难则反加优化的想法。

核心代码：

```
const int maxj=1e5+10;
int prim[maxj],cnt;
bool vis[maxj];
int mo[maxj],sum[maxj];//莫比乌斯函数的记录
//欧拉筛求解莫比乌斯函数
void init(int n){
    mo[1]=1;
    for(int i=2;i<=n;++i){
        if(!vis[i]){
            prim[++cnt]=i;
            //奇数次出现
            mo[i]=-1;
        }
        for(int j=1;j<=cnt&&prim[j]*i<=n;++j){
            vis[i*prim[j]]=1;
            if(i%prim[j]==0){
                //有重复质子数
                mo[i*prim[j]]=0;
                break;
            }
            //奇数次偶数次轮流交替
            mo[prim[j]*i]=mo[i]*-1;
        }
    }
    //预处理前缀和
    for(int i=1;i<=n;++i)sum[i]=sum[i-1]+mo[i];
}
void solve(){
    int t;
    cin>>t;
    while(t--){
        int a,b,d;
        cin>>a>>b>>d;
        //向下取整，映射降低复杂度，转换问题
        a/=d,b/=d;
        int n=min(a,b);
        int ans=0;
        //整除分块，O(2*sqrt(n))级别的复杂度，
        for(int l=1,r;l<=n;l=r+1){
            r=min(n,min(a/(a/l),b/(b/l)));//固定右边界
            ans+=(sum[r]-sum[l-1])*(a/l)*(b/l);
        }
        cout<<ans<<'\n';
    }
}
```



## 六、概率与数学期望

### 基础原理

性质：事件发生的期望的线性性E(aX+bY)=aE(X)+bE(Y)

期望：所有情况的加权平均

### 核心理解

有的题是公式有的题是dp

概率题大多起点固定，终点不固定，
状态-数组，有向边-状态转移，多采用记忆化搜索，使用的是期望的性质

### 例题

#### 一、[217. 绿豆蛙的归宿 - AcWing题库](https://www.acwing.com/problem/content/219/)

```
double f[maxj];
int n,dout[maxj];
vector<pii>g[maxj];//建图
//概率题大多起点固定，终点不固定，
//状态-数组，有向边-状态转移，多采用记忆化搜索，使用的是期望的性质
double dp(int u){
    //边界
    if(f[u]>=0)return f[u];
    if(u>=n)return f[u]=0;//到终点的期望为0
    //初始化
    f[u]=0;
    for(auto i:g[u]){
        f[u]+=(i.second+dp(i.first))/dout[u];
    }
    return f[u];
}
void solve(){
    int m;
    cin>>n>>m;
    for(int i=0;i<=n;++i)f[i]=-1;
    //有向无环图
    for(int i=1;i<=m;++i){
        int x,y,w;
        cin>>x>>y>>w;
        g[x].emplace_back(y,w);
        dout[x]++;
    }    
    printf("%.2lf",dp(1));
}
```

#### 二、[218. 扑克牌 - AcWing题库](https://www.acwing.com/problem/content/220/)

```c++
const double inf=1e10;
//尽可能使用性质，设置好状态使得问题可以转化成搜索问题
int A,B,C,D;
double f[15][15][15][15][5][5];//到结束状态的期望
//题目中翻牌期望最小受到大小王的影响
double dp(int a,int b,int c,int d,int x,int y){
    //考虑边界
    double &v=f[a][b][c][d][x][y];
    if(v>=0)return v;
    if(a>13||b>13||c>13||d>13)return inf;
    //结束
    int as=a+(x==0)+(y==0);
    int bs=b+(x==1)+(y==1);
    int cs=c+(x==2)+(y==2);
    int ds=d+(x==3)+(y==3);
    if(as>=A&&bs>=B&&cs>=C&&ds>=D){
        return v=0;
    }
    int sum=a+b+c+d+(x!=4)+(y!=4);
    sum=54-sum;
    //少了个边界的情况sum,少个初始化
    v=1;
    if(sum<=0)return inf;
    //期望的性质是累加的
    if(a<13)v+=(13.0-a)/sum*dp(a+1,b,c,d,x,y);
    if(b<13)v+=(13.0-b)/sum*dp(a,b+1,c,d,x,y);
    if(c<13)v+=(13.0-c)/sum*dp(a,b,c+1,d,x,y);
    if(d<13)v+=(13.0-d)/sum*dp(a,b,c,d+1,x,y);
    //大小王是在选择最小的期望
    if(x==4){
        double t=inf;
        for(int i=0;i<4;++i){
            //忘记了期望概率了
            t=min(t,1.0/sum*dp(a,b,c,d,i,y));
        }
        v+=t;
    }
    if(y==4){
        double t=inf;
        for(int i=0;i<4;++i){
            t=min(t,1.0/sum*dp(a,b,c,d,x,i));
        }
        v+=t;
    }
    return v;
    
}
void solve(){
    memset(f,-1,sizeof(f));
    cin>>A>>B>>C>>D;
    //初始状态就是化整为零结束的位置
    double t=dp(0,0,0,0,4,4);
    // cout<<(int)t<<'\n';
    if(t>1e5)cout<<"-1.000"<<'\n';
    else
    printf("%.3lf",t);
}
```

## 七、欧拉反演



## 八、矩阵快速幂

主要解决递推式第n项的问题

[【朝夕的ACM笔记】杂项-矩阵快速幂 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/137677246)

```c++
matrix mpow(matrix &a,ll m)//矩阵a的m次方
{
    matrix res;
    for(int i=1;i<=n;i++) res.x[i][i]=1;//单位矩阵
    while(m>0)
    {
        if(m&1) res=multiply(res,a);
        a=multiply(a,a);
        m>>=1;
    }
    return res;
}
```

[6.方程【算法赛】 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/16576/learning/?contest_id=168)

根据所给的公式推导，推出所给的公式

fn=k*fn-1+fn-2

```c++
#include <iostream>
#include <cstring>
using namespace std;
const int p = 1e9 + 7;
typedef long long ll;
void mul(ll c[][2], ll a[][2], ll b[][2])
{
    ll temp[2][2] = {0};
    for (ll i = 0; i <= 1; i++)
        for (ll j = 0; j <= 1; j++)
            for (ll k = 0; k <= 1; k++)
                temp[i][j] = (temp[i][j] + a[i][k] * b[k][j]) % p;
    memcpy(c, temp, sizeof temp);
}
void qpow(ll a[2][2], ll b)
{
    // 初始化单位矩阵
    ll res[2][2];
    for(int i=0;i<2;++i){
        for(int j=0;j<2;++j){
            res[i][j]=a[i][j];
        }
    }
    while (b)
    {
        if (b & 1)
        {
            mul(res, res, a);
        }
        mul(a, a, a);
        b >>= 1;
    }
    memcpy(a, res, sizeof res);
}
ll n, t, k;
int main()
{
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    // 请在此输入您的代码
    cin >> t;
    while (t--)
    {
        cin >> n >> k;
        ll f1 = k;
        ll f2 = ((k * k - 2) % p + p) % p;
        if (n == 1)
        {
            cout << f1 << endl;
            continue;
        }
        if (n == 2)
        {
            cout << f2 << endl;
            continue;
        }
        ll a[2][2] = {{0, -1}, {1, k}};  // A矩阵对应a1 a2 ， B矩阵是使得A矩阵经过矩阵乘法之后变成a2 a3      
        qpow(a, n-2);
        cout << ((f1 * a[0][0] % p + f2 * a[1][0] % p) % p + p) % p << endl;
    }
    return 0;
}
```

