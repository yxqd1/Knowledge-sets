# 图论

## 一、最短路

### 1）单一权值最短路

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int,int>
const int maxj=2e5+100;
int n,m;
int dis[maxj],vis[maxj];
vector<pii>g[maxj];
int st=1;
void dij(){
    for(int i=0;i<=n+1;++i){
        dis[i]=1e10;
        vis[i]=0;
    }
    priority_queue<pii,vector<pii>,greater<pii>>que;//是小根堆
    que.emplace(0,st);
    dis[st]=0;
    while(que.size()){
        pii now=que.top();
        que.pop();
        int u=now.second,w=now.first;
        if(vis[u])continue;
        vis[u]=1;
        // if(dis[u]!=w)continue;
        for(auto i:g[u]){
            int v=i.first,ww=i.second;
            if(dis[v]>dis[u]+ww){
                dis[v]=dis[u]+ww;
                que.emplace(dis[v],v);
            }
        }
    }
}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=m;++i){
        int u,v,w;
        cin>>u>>v>>w;
        g[u].emplace_back(v,w);
        g[v].emplace_back(u,w);
    }
    dij();
    for(int i=1;i<=n;++i){
        cout<<dis[i]<<' ';
    }cout<<'\n';
    return 0;
}
```

### 2）双权值最短路

```
#include <bits/stdc++.h>
using namespace std;
#define pii pair<int, int>
const int maxj = 3e3 + 1000, inf = 1e9;
int n, m;
int dis[maxj], vis[maxj];
int cost[maxj];
int st, ed;
int d1[maxj][maxj], d2[maxj][maxj];
void dij()
{
    priority_queue<pii, vector<pii>, greater<pii>> que; // 是小根堆
    que.emplace(0, st);
    dis[st] = 0;
    cost[st] = 0;
    while (que.size())
    {
        pii now = que.top();
        que.pop();
        int u = now.second, w = now.first;
        if (vis[u])
            continue;
        vis[u] = 1;
        // 暴力所有节点
        for (int i = 1; i <= n; ++i)
        {
            int v = i;
            if (dis[v] > dis[u] + d1[u][v])
            {
                dis[v] = dis[u] + d1[u][v];
                cost[v] = cost[u] + d2[u][v];
                que.emplace(dis[v], v);
            }
            else if (dis[v] == dis[u] + d1[u][v])
            {
                cost[v] = cost[u] + d2[u][v];
                que.emplace(dis[v], v);
            }
        }
    }
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 0; i <= n + 1; ++i)
    {
        dis[i] = inf;
        cost[i] = inf;
        vis[i] = 0;
        for (int j = 0; j <= n + 1; ++j)
        {
            d1[i][j] = d2[i][j] = inf;
            d1[j][i] = d2[j][i] = inf;
        }
    }
    for (int i = 1; i <= m; ++i)
    {
        int u, v, d, p;
        cin >> u >> v >> d >> p;

        if (d1[u][v] > d)
        {
            d1[u][v] = min(d1[u][v], d);
            d1[v][u] = d1[u][v];
            d2[u][v] = p;
            d2[v][u] = d2[u][v];
        }
        else if (d1[u][v] == d)
        {
            d2[u][v] = min(d2[u][v], p);
            d2[v][u] = d2[u][v];
        }
    }
    cin >> st >> ed;

    dij();

    cout << dis[ed] << ' ' << cost[ed] << '\n';

    return 0;
}
```

#### 重载节点

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
// typedef long long ll;
// typedef pair<int,int> PII;
#define fi first
#define se second
#define all(x) (x).begin(),(x).end()
// #define int ll
const int inf=0x3f3f3f3f;
const int maxn=2e6+6;//maxn与结点数量挂钩

int n,m;
int h[maxn],ne[maxn],e[maxn],w[maxn],p[maxn];
int idx;
int dist[maxn];
int dist2[maxn];
bool vis[maxn];
int st,ed;

void add(int a,int b,int c,int d)
{
    e[idx]=b;ne[idx]=h[a];w[idx]=c;p[idx]=d;h[a]=idx++;
}

struct node
{
    int w,p,u;                                                                   
    bool operator< (const node&c)const 
    {
        if(w==c.w)return p>c.p;
        return w>c.w; 
    }
};
int ans;
void  dijkstra(int st)
{
    memset(dist,inf,sizeof dist);
    dist[st]=0;
    dist2[st]=0;
    priority_queue<node>q;
    q.push((node){0,0,st});
    while(q.size())
    {
        node x=q.top();
        q.pop();
        int pp=x.p;
        int uu=x.u;
        if(vis[uu])continue;
        vis[uu]=true;
        for(int i=h[uu];i;i=ne[i])
        {
            int vv=e[i];
            int dd=w[i];
            int pp=p[i];
            if(dist[vv]>dist[uu]+dd)
            {
                dist[vv]=dist[uu]+dd;
                dist2[vv]=dist2[uu]+pp;
                q.push((node){dist[vv],pp,vv});
            }
        }
    }
}

signed main()
{
    cin>>n>>m;
    for(int i=1;i<=m;++i)
    {
        int a,b,c,d;
        cin>>a>>b>>c>>d;
        add(a,b,c,d);
        add(b,a,c,d);
    }
    cin>>st>>ed;
    dijkstra(st);
    cout<<dist[ed]<<" "<<dist2[ed]<<endl;
}//http://10.36.65.50:81/problem/10000
```

### 3）多源纯暴力，可用于判断最小权值环

[Problem - E - Codeforces](https://codeforces.com/gym/103409/problem/E)

```
inline void dijkstra(int start){
    memset(v,0,sizeof(v));
    d[start][start]=0;
    q.push(make_pair(0, start));
    while(q.size()){
        auto tmp = q.top();
        int x = tmp.second; q.pop();
        if(v[x]) continue;
        v[x] = 1;
        for(int i = head[x]; i; i = Next[i]){
            int y = ver[i], z = edge[i];
            if(d[start][y] > d[start][x] + z){
                d[start][y] = d[start][x] + z;
                q.push(make_pair(-d[start][y], y));
            }
        }
    }
}
————————————————
版权声明：本文为CSDN博主「HeartFireY」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/yanweiqi1754989931/article/details/121198699
```

## 二、分层图

[P4568 [JLOI2011\] 飞行路线 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4568)

```c++
//不一样的地方就在建图上，最短路用板子就行
void solve(){
    //多建层多建边从而模拟分层
    int n,m,k;
    cin>>n>>m>>k;
    int s,t;
    cin>>s>>t;
    for(int i=1;i<=m;++i){
        int u,v,w;cin>>u>>v>>w;
        g[u].emplace_back(v,w);
        g[v].emplace_back(u,w);
        for(int j=1;j<=k;++j){//同一层之间花费c，不同层之间花费0，按照题意走的
            g[u+(j-1)*n].emplace_back(v+(j)*n,0);
            g[v+(j-1)*n].emplace_back(u+(j)*n,0);
            g[u+(j)*n].emplace_back(v+(j)*n,w);
            g[v+(j)*n].emplace_back(u+(j)*n,w);
            
        }
    }
    for(int i=1;i<=k;++i){//不同层之间结束位置构造
        g[t+(i-1)*n].emplace_back(t+i*n,0);
        // g[t+(i)*n].emplace_back(t+i*n,0);
    }
    dij(s);
    cout<<dis[t+n*k]<<'\n';//免费一次，相当于跳了一层
}   
```

## 三、最小环计数

[Problem - 7322 (hdu.edu.cn)](https://acm.hdu.edu.cn/showproblem.php?pid=7322)

```c++
//使用Floyd计算最小环及其长度
//最短长度圈的个数+长度
int n,m;cin>>n>>m;
for(int i=1;i<=n;++i){
    for(int j=1;j<=n;++j){
       dis[i][j]=inf;
       cnt[i][j]=0;
    }
}
//输入数据
for(int i=1;i<=m;++i){
    int u,v,w;
    cin>>u>>v>>w;
    if(dis[u][v]>w){
        dis[u][v]=w;
        cnt[u][v]=1;
    }else if(dis[u][v]==w){
        // dis[u][v]=w;
        cnt[u][v]=(cnt[u][v]+1)%mod;
    }
}
//inf要尽可能最大
int ans=0,mn=inf;
for(int k=1;k<=n;++k){
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j){
            //更新最短路
            int tt=dis[i][k]+dis[k][j];
            if(tt<dis[i][j]){
                dis[i][j]=tt;
                //更新计数
                cnt[i][j]=(cnt[i][k]*cnt[k][j])%mod;
            }else if(tt==dis[i][j]){
                cnt[i][j]=(cnt[i][j]+(cnt[i][k]*cnt[k][j])%mod)%mod;
            }
        }
    }
    //选择最小的环，更新mn和ans
    for(int i=1;i<=n;++i){
        if(dis[i][i]<mn){
            mn=dis[i][i];
            ans=0;
            }
        }
    //每一层更新出来的最小环和计数是不一样的，当经过1-k时，最小环长和计数都会发生改变，最后记录的才是合适的
    if(dis[k][k]==mn){
        ans=ans+cnt[k][k];
    }
}
ans=(ans%mod+mod)%mod;
if(mn==inf){
    cout<<-1<<' '<<-1<<'\n';
}else{
    cout<<mn<<' '<<ans<<'\n';
}
```

## 四、二分图匹配（未完

### 4.1 基础知识

bfs实现二分图匹配，思路与圈叉法相似

```
//使用bfs实现二分图匹配
bool bfs(int now){
    
    int top=0;
    vis[now]=1;
    que[++top]={now,1};
    
    while(top>=1){
        pii now=que[top--];
        int nn=now.first,ww=now.second;
        for(int i=0;i<g[nn].size();++i){
            int v=g[nn][i];
            if(vis[v]==ww)return 0;
            if(vis[v]!=0)continue;
            vis[v]=3-ww;
            que[++top]={v,3-ww};
        }
    }
    return 1;
}
```

### 4.2 匈牙利

​		算法复杂度： O(nm)

```
	匹配：在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。
	最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。
下面是一些补充概念：
	完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。
	交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。
	增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替 路称为增广路（agumenting path）。
```

```c++
vector<int>g[maxj];
int match[maxj];//女生选择男生的映射
int st[maxj];//标记女生是否有男朋友
//查看男生是否有女朋友
bool find(int now){
    for(auto i:g[now]){
        if(!st[i]){
            st[i]=1;
            if(!match[i]||find(match[i])){
                match[i]=now;
                return 1;
            }
        }
    }
    return 0;
}
void solve()
{ 
    int n1,n2,m;
    cin>>n1>>n2>>m;
    for(int i=1,u,v;i<=m;++i){
        cin>>u>>v;
        g[u].emplace_back(v);
        // g[v].emplace_back(u);
    }
    int res=0;
    //匈牙利算法暴力所有情况，
    for(int i=1;i<=n1;++i){
        memset(st,0,sizeof(st));
        //每次标记都要初始化
        // fill(st,0,st+n1+1);
        if(find(i)){
            res++;
        }
    }
    cout<<res<<'\n';
}  
```



### 4.3 网络流



### 4.4 hk算法



### 4.5 费用流



## 五、网络流（未完

[用最通俗的语言让你学会网络流 - 钱逸凡 的博客 - 洛谷博客 (luogu.com.cn)](https://www.luogu.com.cn/blog/ONE-PIECE/wang-lao-liu-di-zong-jie)



## 六、费用流（未完



## 七、tarjan（未完



### 7.1 tarjan求有向无环图

### 板子

首先，求强连通分量

```
//tarjan算强连通分量，线型复杂度
void tarjan(int now){
    dfn[now]=low[now]=++tim;
    stk[++top]=now;in_stk[now]=1;
    //更新low，能到达的最小dfn序
    for(auto i:g[now]){
        if(!dfn[i]){
            tarjan(i);
            low[now]=min(low[now],low[i]);
        }else if(in_stk[i]){
            low[now]=min(low[now],low[i]);
        }
    }
    //统计强连通分量情况,包括尺寸
    if(dfn[now]==low[now]){
        ++scc;
        int y;
        do{
            y=stk[top--];
            in_stk[y]=0;
            siz[scc]++;
            id[y]=scc;
        }while(y!=now);
    }
}
```

其次，进行缩点

```
//缩点，这个题重点在于统计强连通分量出度为0的情况和尺寸
for(int i=1;i<=n;++i){
    for(auto j:g[i]){
        int a=id[i],b=id[j];
        if(a!=b)dout[a]++;
    }
}
```

最后，有个对于拓扑序的理解



### [1174. 受欢迎的牛 - AcWing题库](https://www.acwing.com/problem/content/1176/)



总的代码：

```
const int maxj=1e5+10;
int n,m;
vector<int>g[maxj];
int dfn[maxj],low[maxj],siz[maxj],tim;
int scc,id[maxj];//记载强连通分量个数，以及每个点对应的序号，这个序号和拓扑序有关
int stk[maxj],top;
bool in_stk[maxj];
int dout[maxj];
//tarjan算强连通分量，线型复杂度
void tarjan(int now){
    dfn[now]=low[now]=++tim;
    stk[++top]=now;in_stk[now]=1;
    //更新low，能到达的最小dfn序
    for(auto i:g[now]){
        if(!dfn[i]){
            tarjan(i);
            low[now]=min(low[now],low[i]);
        }else if(in_stk[i]){
            low[now]=min(low[now],low[i]);
        }
    }
    //统计强连通分量情况,包括尺寸
    if(dfn[now]==low[now]){
        ++scc;
        int y;
        do{
            y=stk[top--];
            in_stk[y]=0;
            siz[scc]++;
            id[y]=scc;
        }while(y!=now);
    }
}
void solve(){
    cin>>n>>m;
    for(int i=1,x,y;i<=m;++i){
        cin>>x>>y;
        g[x].push_back(y);
    }
    //强连通分量
    for(int i=1;i<=n;++i){
        if(!dfn[i]){
            tarjan(i);
        }
    }
    int sum=0;
    //缩点，这个题重点在于统计强连通分量出度为0的情况和尺寸
    for(int i=1;i<=n;++i){
        for(auto j:g[i]){
            int a=id[i],b=id[j];
            if(a!=b)dout[a]++;
        }
    }
    for(int i=1;i<=scc;++i){
        if(dout[i]==0){
            if(sum!=0){
                sum=0;
                break;
            }else sum+=siz[i];
        }
    }
    cout<<sum<<'\n';
}
```

### [367. 学校网络 - AcWing题库](https://www.acwing.com/problem/content/369/)



```
//缩点，不一样的地方在于证明和出入度的理解（起点终点）
    for(int i=1;i<=n;++i){
        for(auto j:g[i]){
            int a=id[i],b=id[j];
            if(a!=b)dout[a]++,din[b]++;;
        }
    }
    int a=0,b=0;
    for(int i=1;i<=scc;++i){
        if(din[i]==0)a++;
        if(dout[i]==0)b++;
    }
    cout<<a<<'\n';
    if(scc==1){
        cout<<0<<'\n';
    }else cout<<max(a,b)<<'\n';
```



## 八 、拓扑排序

[848. 有向图的拓扑序列 - AcWing题库](https://www.acwing.com/problem/content/850/)

[L-Grayscale Confusion_“范式杯”2023牛客暑期多校训练营10 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/57364/L)



### 解释：

跟环有关系，并且跟先后次序也有关系，注意深度和次序



次序是本身的数组

深度是dep，准确说是层级



### 板子：

核心在于用队列实现拓扑序

```c++
vector<int>g[maxj];
int q[maxj];//记录拓扑序下的数是谁
int du[maxj];
int tt=0,hh=1;
int n,m;
void topsort(){
    for(int i=1;i<=n;++i){
        if(du[i]==0){
            q[++tt]=i;
        }
    }
    while(hh<=tt){
        int now=q[hh++];
        for(auto i:g[now]){
            du[i]--;
            if(du[i]==0){
                q[++tt]=i;
            }
        }
    }
}
```

