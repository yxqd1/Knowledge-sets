# 线段树基础内容

## 一、普通线段树

### 带lazy的板子

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxj = 1e5 + 10;
#define rl rt << 1
#define rr rt << 1 | 1
struct node
{
    int sum;
};
// 带Lazy标记的，主要在区间修改，和区间查询的位置有所修改
struct Tree
{
    node v[maxj << 2];   // 开4倍的空间
    int lazy[maxj << 2]; // lazy很多在于打标记，而原数组在于做真正的操作
    void pushup(int rt)
    { // 向上更新
        v[rt].sum = v[rl].sum + v[rr].sum;
    }
    void pushdown(int rt, int l, int r)
    {
        lazy[rr] += lazy[rt];
        lazy[rl] += lazy[rt];
        v[rl].sum += lazy[rt] * l;
        v[rr].sum += lazy[rt] * r;
        lazy[rt] = 0;
    }
    void build(int l, int r, int rt, int *a)
    { // 建树
        if (l == r)
        {
            v[rt].sum = a[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(l, mid, rl, a);
        build(mid + 1, r, rr, a);
        pushup(rt);
    }
    void update(int pos, int c, int l, int r, int rt)
    { // 单点修改，在pos位置，修改为c
        if (l == r)
        {
            v[rt].sum = c;
            return;
        }
        int mid = (l + r) >> 1;
        if (pos <= mid)
            update(pos, c, l, mid, rl);
        else
            update(pos, c, mid + 1, r, rr);
        pushup(rt);
    }
    int query(int L, int R, int l, int r, int rt)
    { // 区间询问
        if (L <= l && r <= R)
        {
            return v[rt].sum;
        }
        int mid = (l + r) >> 1;
        if (lazy[rt])
            pushdown(rt, mid - l + 1, r - mid);
        int ans = 0;
        if(R<=mid)return query(L,R,l,mid,rl);
        else if(L>mid)return  query(L,R,mid+1,r,rr);
        else {
            return query(L,mid,l,mid,rl)+query(mid+1,R,mid+1,r,rr);
        }
    }
    void update(int L, int R, int c, int l, int r, int rt)
    { // 区间修改
        if (L <= l && R >= r)
        {
            v[rt].sum += c * (r - l + 1);
            lazy[rt] += c;
            return;
        }
        int mid = (l + r) >> 1;
        if (lazy[rt])
            pushdown(rt, mid - l + 1, r - mid);
        if(mid>=R)update(L,R,c,l,mid,rl);
        else if(mid+1<=L)update(L,R,c,mid+1,r,rr);
        else {
            update(L,mid,c,l,mid,rl);
            update(mid+1,R,c,mid+1,r,rr);
        }
        pushup(rt); // 向上更新
    }
};
signed main()
{

    return 0;
}
// https://vjudge.net/contest/537315#problem/B
// 二进制位上的线段树，
// 线段树上大体的板子没啥变化，就是细节可能发生改变
//https://vjudge.net/contest/537315#overview 题单
```

### 动态开点线段树

```
/*
动态开点线段树 
*/
#include<cstdio> 
#include<cstring> 
#include<algorithm> 

inline int read() { //必须有，输入量大了，read是最快的
	int x = 0,f = 1; 
	char c  = getchar() ; 
	while(c < '0' || c > '9')c = getchar(); 
	while(c <= '9' && c >= '0') x = x * 10 + c - '0',c = getchar(); 
	return x * f; 
} 
const int maxn = 500007 * 30; //空间不可以给小了，
int rt = 0; 
struct Segtree { 
	int tot ; 
	int ls[maxn],rs[maxn],tag[maxn],sum[maxn]; 
	void pushdown(int x,int l,int r) { //区间是正经的区间，下标不是正经的下标
		int mid = l + r >> 1;  
		if(l != r) { 
 			if(!ls[x]) ls[x] = ++ tot; //记得开点这里 
 			if(!rs[x]) rs[x] = ++ tot; 
			sum[ls[x]] = (mid - l + 1) * tag[x]; 
			sum[rs[x]] = (r - mid) * tag[x]; 
			tag[ls[x]] = tag[x]; 
			tag[rs[x]] = tag[x]; 
		} 
		tag[x] = -1; 
	} 
	void modify(int &x,int l,int r,int L,int R,int w) {//需要用&，没有真的在开，动态的给下标赋值
		if(!x) x = ++ tot; //动态的开点，赋值
		if(l >= L && r <= R) { 
			sum[x] = (r - l + 1) * w; 
			tag[x] = w; 
			return; 
		} 
		if(tag[x] >= 0) pushdown(x,l,r); //0也需要更新，可能是需要开点，因为不是-1
		int mid = l + r >> 1; 
		if(L <= mid) modify(ls[x],l,mid,L,R,w); 
		if(R >  mid) modify(rs[x],mid + 1,r,L,R,w); 
		sum[x] = sum[ls[x]] + sum[rs[x]]; 
	} 
} t; 
int main() { 
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout); // a为add,,w
#endif
	int n = read(); 
	int m = read(); 
	memset(t.tag,-1,sizeof t.tag); //初始化，错1
	for(int type,l,r,i = 1;i <= m;++ i) { 
		l = read(),r = read(),type = read(); 
		if(type == 1) t.modify(rt,1,n,l,r,1); 
		else t.modify(rt,1,n,l,r,0); 
		printf("%d\n",n-t.sum[1]); 
	} 
	return 0; 
} 

//https://vjudge.net/contest/537315#problem/J 主要特点是范围很大没办法开
```



## 二、主席树

[255. 第K小数 - AcWing题库](https://www.acwing.com/problem/content/257/)



```
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100005;
//d 为离散化数组
int n, m, len, a[N], d[N];

//T[i] 为 [1, i] 区间的权值线段树的根节点
int T[N], tot = 0;

//线段树的每个点
struct SegTree{
    int l, r, v;
}t[N * 20];

//建树
int build(int l, int r){
    int p = ++tot, mid = (l + r) >> 1;
    if(l < r) {
        t[p].l = build(l, mid);
        t[p].r = build(mid + 1, r);
    }
    t[p].v = 0; return p;
}

//增加一个数 pre 为上一个的根节点。
int update(int pre, int l, int r, int v){
    int p = ++tot, mid = (l + r) >> 1;
    t[p].l = t[pre].l, t[p].r = t[pre].r, t[p].v = t[pre].v + 1;
    if(l < r){
        //应该更新哪一个值域区间
        if(v <= mid) t[p].l = update(t[pre].l, l, mid, v);
        else t[p].r = update(t[pre].r, mid + 1, r, v); 
    }
    return p;
}

//查询
int query(int x, int y, int l, int r, int k){
    //找到了
    if(l == r) return l;
    //对位相减
    int sum = t[t[y].l].v - t[t[x].l].v, mid = (l + r) >> 1;
    if(k <= sum) return query(t[x].l, t[y].l, l, mid, k);
    else return query(t[x].r, t[y].r, mid + 1, r, k - sum);
}

int main(){
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d", a + i), d[i] = a[i];
    //离散化
    sort(d + 1, d + 1 + n);
    len = unique(d + 1, d + 1 + n) - (d + 1);
    for(int i = 1; i <= n; i++) 
        a[i] = lower_bound(d + 1, d + 1 + len, a[i]) - d;


    T[0] = build(1, len);
    for(int i = 1; i <= n; i++)
        T[i] = update(T[i - 1], 1, len, a[i]);

    //回答
    while(m--){
        int l, r, k; scanf("%d%d%d", &l, &r, &k);
        int ans = query(T[l - 1], T[r], 1, len, k);
        printf("%d\n", d[ans]);
    }
    return 0;
}

```



## 三、树链剖分

[树链剖分 - OI Wiki (oi-wiki.org)](https://oi-wiki.org//graph/hld/)



第一个 DFS 记录每个结点的父节点（father）、深度（deep）、子树大小（size）、重子节点（hson）。

第二个 DFS 记录所在链的链顶（top，应初始化为结点本身）、重边优先遍历时的 DFS 序（dfn）、DFS 序对应的节点编号（rank）。



```
fa(x) 表示节点 x 在树上的父亲。
dep(x) 表示节点 x 在树上的深度。
siz(x) 表示节点 x 的子树的节点个数。
son(x) 表示节点 x 的 重儿子。
top(x) 表示节点 x 所在 重链 的顶部节点（深度最小）。
dfn(x) 表示节点 x 的 DFS 序，也是其在线段树中的编号。
rnk(x) 表示 DFS 序所对应的节点编号，有 rnk(dfn(x))=x。
```

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxj=1e5+100;
int tr[maxj<<2],laz[maxj<<2];//用于树
int sz[maxj],dep[maxj],fa[maxj],son[maxj];//用于dfs1
int top[maxj],id[maxj],nw[maxj];//用于dfs2
int k,n;
int a[maxj];
vector<int>g[maxj<<1];
//处理重儿子和树上的基本信息
void dfs1(int no,int father,int depth){
    dep[no]=depth,fa[no]=father,sz[no]=1;
    for(auto i:g[no]){
        if(i==father)continue;
        dfs1(i,no,depth+1);
        sz[no]+=sz[i];
        if(sz[son[no]]<sz[i])son[no]=i;
    }
}
//处理重链
void dfs2(int no,int to){
    top[no]=to,id[no]=++k,nw[k]=a[no];
    if(!son[no])return ;
    dfs2(son[no],to);
    for(auto i:g[no]){
        //注意条件
        if(i==fa[no]||i==son[no])continue;
        dfs2(i,i);
    }
}  
void pushup(int rt){
    tr[rt]=tr[rt<<1|1]+tr[rt<<1];
}
void pushdown(int rt,int l,int r){
    //左边
    laz[rt<<1]+=laz[rt];
    tr[rt<<1]+=laz[rt]*l;
    //右边
    laz[rt<<1|1]+=laz[rt];
    tr[rt<<1|1]+=laz[rt]*r;
    laz[rt]=0;
}
//建树
void build(int l,int r,int rt){
    if(l==r){
        tr[rt]=nw[l];
        laz[rt]=0;
        return ;
    }
    int mid=(l+r)>>1;
    build(l,mid,rt<<1);
    build(mid+1,r,rt<<1|1);
    pushup(rt);
}
//询问操作
int  query(int L,int R,int l,int r,int rt){
    if(L<=l&&R>=r){
        return tr[rt];
    }
    int mid=(l+r)>>1;
    if(laz[rt]){
        pushdown(rt,mid-l+1,r-mid);
    }
    int ans=0;
    if(R>mid)ans+=query(L,R,mid+1,r,rt<<1|1);
    if(L<=mid)ans+=query(L,R,l,mid,rt<<1);
    return ans;
    // if(L>mid)return query(L,R,mid+1,r,rt<<1|1);
    // if(R<=mid)return query(L,R,l,mid,rt<<1);
    // return query(L,mid,l,mid,rt<<1)+query(mid+1,R,mid+1,r,rt<<1|1);
}
//更新操作
void update(int L,int R,int l,int r,int rt,int k){
    //结束位置
    if(L<=l&&R>=r){
        tr[rt]+=(r-l+1)*k;
        laz[rt]+=k;
        return ;
    }
    int mid=(l+r)>>1;
    if(laz[rt]){
        pushdown(rt,mid-l+1,r-mid);
    }
    if(R>mid)update(L,R,mid+1,r,rt<<1|1,k);
    if(L<=mid)update(L,R,l,mid,rt<<1,k);
    // if(L>mid)update(L,R,mid+1,r,rt<<1|1,k);
    // else if(R<=mid)update(L,R,l,mid,rt<<1,k);
    // else update(L,mid,l,mid,rt<<1,k),update(mid+1,R,mid+1,r,rt<<1|1,k);
    pushup(rt);
}
//更新路径
void update_path(int u,int v,int k){
    //树剖的经典操作，模拟lca向上跳跃
    while(top[u]!=top[v]){
        //是top之间的比较
        if(dep[top[u]]<dep[top[v]])swap(u,v);
        update(id[top[u]],id[u],1,n,1,k);
        u=fa[top[u]];
    }
    //直到同一个链中
    if(dep[u]<dep[v])swap(u,v);
    update(id[v],id[u],1,n,1,k);
    
}
//更新子树
void update_subtr(int u,int k){
    //结束尺寸不太对
    update(id[u],id[u]+sz[u]-1,1,n,1,k);
}
//询问路径
void query_path(int u,int v){
    int ans=0;
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]])swap(u,v);
        ans+=query(id[top[u]],id[u],1,n,1);
        u=fa[top[u]];
    }
    if(dep[u]<dep[v])swap(u,v);
    ans+=query(id[v],id[u],1,n,1);
    cout<<ans<<'\n';
}
//询问子树
void query_subtr(int u){
    cout<<query(id[u],id[u]+sz[u]-1,1,n,1)<<'\n';
}
signed main(){
    cin>>n;
    for(int i=1;i<=n;++i)cin>>a[i];
    for(int i=1;i<n;++i){
        int u,v;cin>>u>>v;
        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }
    
    dfs1(1,0,1);
    dfs2(1,1);
    build(1,n,1);
    
    int m;cin>>m;
    while(m--){
        int op;
        cin>>op;
        if(op==1){
            int u,v,k;cin>>u>>v>>k;
            update_path(u,v,k);
        }else if(op==2){
            int u,k;cin>>u>>k;
            update_subtr(u,k);
        }else if(op==3){
            int u,v;cin>>u>>v;
            query_path(u,v);
        }else{
            int u;cin>>u;
            query_subtr(u);
        }
    }
    return 0;
}
//https://www.luogu.com.cn/problem/P2590  树的统计
//https://www.acwing.com/problem/content/2570/
//https://www.acwing.com/problem/content/920/
```

## 四、树状数组

```
int n;
struct bit{//离散化+树状数组
    int sum[maxj];
    int lowbit(int x){return x&(-x);}
    void add(int x,int c){while(x<=n)sum[x]+=c,x+=lowbit(x);}
    int getsum(int x){int res=0;while(x)res+=sum[x],x-=lowbit(x);return res;}
}t1;
```

