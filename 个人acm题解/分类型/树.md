# 树

## 一、二进制+线段树

[Problem - J - Codeforces](https://codeforces.com/gym/104095/problem/J)

二进制位运算=》需要记录每一位进行操作，暴力，线段树区间修改就要暴力单点修改+剪枝了

线段树=》lazy不是必须，区间修改可能要单点修改+可行化剪枝

因为有&操作，所以只有v[rt].x[i]==1&&(((x>>i)&1)==0)的时候才需要修改=》剪枝

注意read快读，少用long long 等提高速度

## 二、线段树，莫队，query和update不同

[Problem - F - Codeforces](https://codeforces.com/contest/1793/problem/F)

卡了好久，大小，输入，输出，剪枝很重要，query

复杂度极高=》莫队，线段树

区间内相差最小=》线段树维护每个节点的所有数据，通过和莫队的结合做题

莫队=》输入数据，排序，然后再原数据上一个状态一个状态的改变

不一样的地方=》建立的时候节点所有涉及的数据都要更新，，，update的时候pos<=mid的时候要全部更新，，，query由于终点（准确地左右）比较特殊，所以要准确的更新

有个mnn最优化剪枝，下边回溯时有小的了，然后没必要在更新了

利用r，然后排序，或者在前一个状态下更新

## 三、树上启发式合并（dus on tree）

[Problem - 600E - Codeforces](https://codeforces.com/problemset/problem/600/E)

，主要处理字树问题

题解：[dsu on tree学习笔记 - EinNiemand - 博客园 (cnblogs.com)](https://www.cnblogs.com/EinNiemand/p/11721101.html)

树上启发式合并：[dsu on tree(树上启发式合并)详解_Hypoc_的博客-CSDN博客](https://blog.csdn.net/a_forever_dream/article/details/102967706)

轻重链剖分：[轻重链剖分 学习笔记_jiangtaizhe的博客-CSDN博客_轻重链剖分](https://blog.csdn.net/jiangtaizhe/article/details/108176128)

## 四、并查集，加新边，离线处理

[Problem - K - Codeforces](https://codeforces.com/group/Aokqa6Haao/contest/427952/problem/K)

### 思路：

离线的预处理，将m条边加入到树的边中，按照权重排序，然后遍历，不是规定的权重就排序，然后合并，除非到达规定的上限就离线统计答案

### 代码：

注意并查集的操作，

find merge init

f[y]=x;

siz[x]+=siz[y];//统计并查集的大小

## 五、二进制，数学函数，dfs化简

[Problem - J - Codeforces](https://codeforces.com/group/Aokqa6Haao/contest/428245/problem/J)

题解：[2022CCPC江苏省赛题解ACIJKL - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/563134194)

### 思路：

首先，你要明白函数，然后理解dfs化简，这个题dp（空间不行）和别的都不太行，

由递推方程（平衡树递归想到）=》取log=》带方程，推导公式=》递归

### 注意：

不是组合数学，而是逐层递归模拟

## 六、数论转化为图论，最大字段和

[Problem - D - Codeforces](https://codeforces.com/contest/1796/problem/D)

### 思路：

最大字段和的改编：

参考：[最大字段和问题 - FizzPu - 博客园 (cnblogs.com)](https://www.cnblogs.com/jielearscoding/p/13942359.html#:~:text=最大子段和 -- 分治%2Cdp 1 1.问题描述 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。 求所有子数组的和的最大值。 ...,负数加上一个数%2C必然比这个数小%2C 就像是一个数减了某个数%2C 肯定变小. ... 4 3. 方案3 )

题解参考：[Educational Codeforces Round 144 (Rated for Div. 2) (A~E) 题解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/610522558)

## 七、前序、中序、后序、层序遍历算法

[1497. 树的遍历 - AcWing题库](https://www.acwing.com/problem/content/description/1499/)

## 八、树hash裸体

[Problem - G - Codeforces](https://codeforces.com/contest/1800/problem/G)

### 参考知识：[树Hash的一些常用姿势 - 空気力学の詩 - 博客园 (cnblogs.com)](https://www.cnblogs.com/cjjsb/p/17177725.html)

[树哈希 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/tree-hash/)

### 思路：

### 注意：

要加上随机数才行

## 九、线段树

[H-摘苹果_2023年中国高校计算机大赛-团队程序设计天梯赛（GPLT）上海理工大学校内选拔赛（同步赛) (nowcoder.com)](https://ac.nowcoder.com/acm/contest/52244/H)

### 思路：

板子题

因为需要对于每个点修改，所以修改操作里剪枝+单点修改

询问操作里左右区间对应才行

### 注意：

递归的写法

```c++
//这个地方要做精细化分析
    if(mid>=R)update(rl,L,R,l,mid);
    else if(mid+1<=L)update(rr,L,R,mid+1,r);
    else {
        update(rl,L,mid,l,mid);
        update(rr,mid+1,R,mid+1,r);
    }
```

## 十、线段树——树（欧拉函数）

[Problem - E - Codeforces](https://codeforces.com/contest/1797/problem/E)

### 思路：

关于欧拉函数：[算法学习笔记(18): 欧拉函数 - 知乎 (zhihu.com)

将欧拉函数制作成树，这样有flag标记（剪枝），lca寻找最近公共祖先计算查询

线段树记录flag（标记），区间长度（用于统一的跳跃），mx（区间统一的值），cnt(区间跳到相同的高度所需的次数)，然后就是经典的维护更新

注意很多题的维护可能是单点的维护。

## 十一、树，模拟dfs

[Problem - D - Codeforces](https://codeforces.com/contest/1797/problem/D)

### 思路：

树上的关系大多都是固定的，而且，主要是对树上的关系进行修改。

树上的操作大多都是dfs模拟暴力

过程越详细的题往往是模拟解决。

## 十二、数学和树（注意不太会

[Problem - 1824B1 - Codeforces](https://codeforces.com/problemset/problem/1824/B1)

### 思路：

树上的题在于模板和树上信息（dfs）的应用

分三种情况找相应的期望。

## 十三、树hash，基环树、树hash判同构

https://zhuanlan.zhihu.com/p/592934588

## 十四、tire树

[Problem - K - Codeforces](https://codeforces.com/gym/104022/problem/K)

## 十五、树状数组、时间戳、多因素控制

https://codeforces.com/gym/104053/problem/E



## 十六、逆序对，相邻交换次数

[1215. 小朋友排队 - AcWing题库](https://www.acwing.com/problem/content/description/1217/)

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+100;
int h[N],b[N];
int n;
struct node{
   int sum[N*2];
   int lowbit(int x){
       return x&(-x);
   }
   void init(){
       for(int i=0;i<2*N;++i)sum[i]=0;
   }
  void add(int id,int x){
      for(int i=id;i<N;i+=lowbit(i)){
          sum[i]+=x;
      }
  }
  int query(int id){
      int ans=0;
      for(int i=id;i>0;i-=lowbit(i)){
          ans+=sum[i];
      }
      return ans;
  }
}tr;
signed main(){
    // 同一个人尽可能少用
    // 还是和逆序对有关
    /*
        通过树状数组优化复杂度，前边大的需要移动到后边，后边小的需要移动到前边
        通过树状数组完成优化操作,sum内容是h的大小，记载的是相对大小的个数
        范围不是很大，也没有必要去重=》不必离散化
    */
    cin>>n;
    for(int i=1;i<=n;++i){
        cin>>h[i];
        h[i]++;
    }
    tr.init();
    // 先找到比自己大的
    for(int i=1;i<=n;++i){
        tr.add(h[i],1);
        // cout<<tr.query(h[i])<<'\n';
        b[i]=(i)-tr.query(h[i]);
    }
    // cout<<tr.sum[h[1]]<<'\n';
    // cout<<b[1]<<'\n';
    tr.init();
    // memset(tr.sum,0,sizeof tr.sum); //该逆序算了，所以维护树状数组不一样，所以算完大的要清0.
    // 后找到后边比自己小的
    for(int i=n;i>=1;--i){
        tr.add(h[i],1);
        b[i]+=tr.query(h[i]-1);
    }
    int ans=0;
    
    for(int i=1;i<=n;++i){
        ans+=(b[i]+1)*b[i]/2;
        // cout<<b[i]<<' ';
    }
    cout<<ans<<endl;
    return 0;
}
```

## 十七、且、或、非关系的模拟

```
L2-3 到底爱不爱我
分数 25
love.JPG

古代少女有了心上人时，会悄悄折一条树枝，揪那枝上的叶子，揪一片叶子念一句“爱我”，再揪一片念一句“不爱我”…… 这样揪落最后一片叶子的时候，看看是停在“爱”还是“不爱”。

但聪明的慧娘一眼洞穿，只要数一下叶子有多少片，根据这个数字的奇偶性判断是以“爱”开始还是以“不爱”开始，就总是可以最后落在“爱”上。这个游戏顿时就变得无趣了 —— 真的是文科生制造浪漫，理科生杀死浪漫。

于是有着工科生大脑的慧娘打算另外制作一个更有趣的浪漫游戏。她用不同植物的枝条做成了三种“情枝”：

“专情枝”：是一根有两个分岔的树枝，只有当两个分岔上连接的枝条传过来的情话都是“爱”的时候，这根枝条的根部才传出“爱”；否则树枝根部传出的是“不爱”。
“博爱枝”：也是一根有两个分岔的树枝，只有当两个分岔上连接的枝条传过来的情话都是“不爱”的时候，这根枝条的根部才传出“不爱”；否则树枝根部传出的都是“爱”。
“情变枝”：是没有分岔的一根直枝，如果一端接到“爱”，另一端必须传出“不爱”；反之如果一端接到“不爱”，另一端则会传出“爱”。
慧娘将这些树枝摆放在院子里，布了一个“情阵”，先选一根特殊的枝条作为初试一枝，从这枝条的根部开始，扩散开去，令它们根枝相连。然后她在末梢的枝杈旁随意写下“爱”或“不爱”。现在请你写个程序帮她算出来，在初始一枝的根部，她能得到“爱”还是“不爱”？

输入格式：
输入在第一行中给出正整数 N（≤30），是慧娘制作的情枝数量。这里假设她将所有的情枝从 1 到 N 做好了编号。随后 N 行，第 i 行给出第 i 枝的描述，格式为

类型 左分枝连接的编号 右分枝连接的编号
其中 类型 为 1 代表专情、2 代表博爱、3 代表情变。当然如果是情变枝，则后面跟的是其唯一末端连接的情枝编号，并没有两个分枝的信息。如果一个分枝是末梢，并没有连接其它枝条，则对应编号为 0。

接下来一行中给出正整数 K（≤30），是慧娘询问的次数。以下 K 行，每行给出一个由 0 和 1 组成的字符串，其中 0 表示“不爱”，1 表示“爱”—— 这是慧娘从左到右在每个枝杈末梢处写下的。（注意：“从左到右”的意思是，我们从初试一枝出发去遍历所有枝条的末梢时，总是遵循先遍历左边情阵、再遍历右边情阵的顺序）

输出格式：
对慧娘的每个询问，如果她在初始一枝的根部能得到“爱”，就输出 Ai；否则输出 BuAi。

输入样例：
6
2 6 4
1 0 0
3 1
2 0 0
3 0
1 5 2
5
11111
00000
11100
10011
01100

输出样例：
BuAi
Ai
Ai
BuAi
BuAi

样例说明：
样例对应的情阵以及慧娘第 3 问的情势如图所示，其中完整的心对应 1，裂开的心对应 0。

sample.jpg

代码长度限制
16 KB
时间限制
400 ms
内存限制
64 MB
栈限制
8192 KB
```

代码：

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+100;
int type[N];
int son[N][4];
int in[N];
bool dfs(int x){
    if(x==0){ // 枝叶
        char cc;cin>>cc;
        return cc-'0';
    }
    // 专情枝模拟的是且
    if(type[x]==1){
        return dfs(son[x][0])&dfs(son[x][1]);
    }
    // 博爱枝模拟的是或
    if(type[x]==2){
        return dfs(son[x][0])|dfs(son[x][1]);
    }
    // 情变枝模拟的是非
    if(type[x]==3){
        return !dfs(son[x][0]);
    }
}
signed main(){
    // 要和具体的思路进行结合
    // 一棵树难免要记录son，fa，type，dfs这些信息
    int n;cin>>n;
    for(int i=1,ty;i<=n;++i){
        cin>>ty;
        type[i]=ty;
        if(ty==1||ty==2){
            cin>>son[i][0]>>son[i][1];
            in[son[i][0]]++;
            in[son[i][1]]++;
        }else {
            cin>>son[i][0];
            in[son[i][0]]++;
        }
    }
    int fa=0;
    for(int i=1;i<=n;++i)if(!in[i]){
        fa=i;break;
    }
    int m;cin>>m;
    while(m--){
        if(dfs(fa))cout<<"Ai\n";
        else cout<<"BuAi\n";
    }
    return 0;
}
```

## 十八、几种遍历树的方式

[L2-006 树的遍历 - 团体程序设计天梯赛-练习集 (pintia.cn)](https://pintia.cn/problem-sets/994805046380707840/exam/problems/994805069361299456?type=7&page=1)

## 十九、线段树，单点加lowbit

[Problem - D - Codeforces](https://codeforces.com/group/n9YFSztryg/contest/520588/problem/D)

区间修改：

如果二进制只有一个1，区间整体乘2

否则单点修改，单个数10101010..最多次数不超20，复杂度可行

lazy更新时是累乘的，每个rt都是1
