# 图论

## 一、

注意dis更新的判断条件啊，>或者>=,都试试，

[G-清楚姐姐逛街(Easy Version)_2023牛客寒假算法基础集训营4 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/46812/G)

## 二、

数论转化成图论，还涉及到排序算法

[J-清楚姐姐学排序_2023牛客寒假算法基础集训营4 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/46812/J)

## 三、

[E-阿宁的生成树_2023牛客寒假算法基础集训营6 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/46814/E)

首先，审对题，然后，分步更新，借鉴prim算法，

2e5的数据中，相邻质数之间的距离不大于1e2的复杂度

## 四、

[Problem - D - Codeforces](https://codeforces.com/contest/1787/problem/D)

1. 
   ​    **数论转化成图论，正反向建图**

2. **dfs**

   

## 五、

[Problem - F - Codeforces](https://codeforces.com/group/Aokqa6Haao/contest/426543/problem/F)

有一次跳跃，=》正向的遍历一次和反向的遍历一次

跳跃要求=》正向的和反向的时候，当前点不可以是b，因为b不是终点

异或值为0=》前后有重复的数出现

## 六、

[Problem - E - Codeforces](https://codeforces.com/group/Aokqa6Haao/contest/426543/problem/E)

lps问题，字符串上和树上两种

采用区间dp的方法

lps参考：[(动态规划)最长回文子序列、回文子序列个数 - AndyJee - 博客园 (cnblogs.com)](https://www.cnblogs.com/AndyJee/p/4465696.html#:~:text=给定字符串，求它的最长回文子序列长度。,回文子序列反转字符顺序后仍然与原序列相同。 例如字符串abcdfcba中，最长回文子序列长度为7，abcdcba或abcfcba。)

题解参考：[CF1771D Hossam and (sub-)palindromic tree - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/solution/CF1771D)

个人理解：

首先采用dfs处理区间边界，

之后采用记忆化搜索==dp，初始化数组需要为-1，因为有0的情况，

## 七、

[Problem - G - Codeforces](https://codeforces.com/group/Aokqa6Haao/contest/427952/problem/G)

搜索，割点

### 思路：

当a和b作为割点的时候，a的左边和b的右边相互到达的时候是不可跳开a或者b的

所以，a到b做dfs/bfs   b到a做dfs/bfs计数，两个部分不可达的乘积就是答案

### 注意：

图论嘛，做个图，看看图上有什么关系，肯定需要剪枝搜索，并查集之类的结构，当然啊，有可能有的题不是真的图论，而是贪心数论

## 八、图论、模拟

[Problem - D - Codeforces](https://codeforces.com/contest/1818/problem/D)

### 思路：

判环以及暴力筛取鱼的尾巴，

用bfs可以防止爆栈，dfs也行，但是细节处理不对。

它最后筛选的方法，感觉有定律。（有点问题

## 九、二维带权并查集

[G (codeforces.com)](https://codeforces.com/group/n9YFSztryg/contest/440964/problem/G)

### 思路：

数据量太大，可以离散化，一维可以解决一维的，或者二维的，甚至离散化，都可以用fa数组。

### find板子:

```
//初始化
 for(int i=0;i<=n;++i)fa[i]=i;
//find
int find(int x){
    return (fa[x]==x)?x:fa[x]=find(fa[x]);
}
//合并，前提都有数据
//查找
	int a=find(pre);
	int b=find(now);
	//合并
	if(a<b)swap(a,b);
	if(a!=b){
		fa[a] = b;
		//相关操作
            
	}else {
		//相关操作
	}

//使用,得用find函数
cout<<ans[find(now)]<<'\n';

```

## 十、并查集、判环（还是不太理解，一定重做

[Problem - E - Codeforces](https://codeforces.com/contest/1833/problem/E)

### 思路：

需重新做。

## 十一、多次最短路，汇点的枚举

[码题集OJ-公园 (matiji.net)](https://www.matiji.net/exam/brushquestion/1/4347/179CE77A7B772D15A8C00DD8198AAC74?from=1)

## 十二、离线，并查集，结论推导

一般题都有模拟跳跃的方法，都有结论和规律

这个题的权值具有传递性

一定要注意点和点的权值之间的区别，卡死我了

[Problem - G - Codeforces](https://codeforces.com/contest/1851/problem/G)

```c++
int h[maxj];
struct node{
    int a,b,e,idx;
};
void solve()
{ 
    //a点到b点问可达不可达
    //结论在于过程中ha加上e可达，那么过程中都可达
    int n,m;cin>>n>>m;
    for(int i=1;i<=n;++i){
        cin>>h[i];
    }
    vector<pii>edge;
    for(int i=1,u,v;i<=m;++i){
        cin>>u>>v;
        edge.emplace_back(u,v);
    }   
    sort(edge.begin(),edge.end(),[&](const pii &a,const pii &b) {
        //为了使可跨越的值具有传递性
        return max(h[a.first],h[a.second])<max(h[b.first],h[b.second]);
    });
    // for(auto i:edge){
    //     cout<<i.first<<' '<<i.second<<'\n';
    // }
    int q;cin>>q;
    vector<node>qq;
    for(int i=0,a,b,e;i<q;++i){
        cin>>a>>b>>e;
        qq.emplace_back(a,b,e,i);
    }
    sort(qq.begin(),qq.end(),[&](const node &a,const node &b){
        return h[a.a]+a.e<h[b.a]+b.e;
    });
    DSU ds(n+1);
    //初始化答案字符串
    vector<string>ans(q,"NO");
    //可以扩展一个类似的板子，多源点dj并且带有负权  ？？？？？
    //线性的遍历n和m,一定要注意点不是关键，关键是权值
    for(int i=0,j=0;i<q;++i){
        int a=qq[i].a,b=qq[i].b,e=qq[i].e,idx=qq[i].idx,lim=h[a]+e;
        while(j<m){
            if(max(h[edge[j].first],h[edge[j].second])<=lim){
               ds.merge(edge[j].first,edge[j].second); 
               j++;
            }else break;
        }
        if(ds.same(a,b))ans[idx]="YES";
    }
    for(auto i:ans){
        cout<<i<<'\n';
    }
    cout<<'\n';
}
```

## 十三、基环树、拓扑排序

https://codeforces.com/contest/1872/problem/F

拓扑排序，判环

## 十四、规律dfs



https://codeforces.com/gym/104077/problem/L

## 十五、最短路，规律转换图论

如果真的需要排序并且使用iota最好数组从0开始，现在也不知道哪里出问题了

最值注意尽可能大



贪心规律题=》最短路

题意：

给定uvy，其中u或者v出现的次数有限制<=y

相互制约相互限制

策略：

最短路实现

从后往前想，到n，n是不可以出现的，所以到n的点限制就是y，逐渐递推，到每个点的最短路

最短边权就是出现的最小次数

[Problem - D - Codeforces](https://codeforces.com/contest/1842/problem/D)

## 十六、有向图+手写哈希散列表

[4407. 扫雷 - AcWing题库](https://www.acwing.com/problem/content/4410/)

stl可以用unordered_map或者unordered_set

手写板子看下边代码

```c++
const int N=5e4+100,M=999997,inf=0x7f7f7f7f7f7f7f7f;
int id[M];
bool st[M];
int h[M];//M 是 N 的2-10倍
struct cir{
    int x,y,r;
}dd[N];
// 将二维转换1维
int get_key(int x,int y){
    return x*1000000001ll+y;
}
// 手写散列表
int find(int x,int y){
    int key=get_key(x,y);
    int t=(key%M+M)%M;;
    while(h[t] !=-1 &&h[t] != key)// 没人占用或者ht是key时停下
        if(++t==M)
            t=0;
    return t;
}
int sqr(int x,int y){
    return (x-y)*(x-y);
}
void dfs(int x,int y,int r){
    for(int i=x-r;i<=x+r;++i){
        for(int j=y-r;j<=y+r;++j){
            if(sqr(x,i)+sqr(y,j)<=r*r){
                int t=find(i,j);
                if(id[t]&&!st[t]){
                    st[t]=1;
                    dfs(i,j,dd[id[t]].r);//dfs暴力找该暴的雷
                }
            }
        }
    }
}
void solve(){
	// 点到点是有向边，建图dfs遍历
	int n,m;cin>>n>>m;
	//
	memset(h,-1,sizeof(h));
	for(int i=1;i<=n;++i){
	    int x,y,r;
	    cin>>x>>y>>r;
	    dd[i]={x,y,r};
	    // 建立hash
	    int t=find(x,y);
	    if(h[t]==-1)h[t]=get_key(x,y);
	    // 建立索引
	    if(!id[t]||dd[id[t]].r<r){
	        id[t]=i;
	    }
	}
	
    while(m--){
        int x,y,r;
        cin>>x>>y>>r;
        // 圆的问题采用暴力循环的方式解决
        for(int i=x-r;i<=x+r;++i){
            for(int j=y-r;j<=y+r;++j){
                if(sqr(x,i)+sqr(y,j)<=r*r){
                    int t=find(i,j);
                    if(id[t]&&!st[t]){
                        st[t]=1;
                        dfs(i,j,dd[id[t]].r);//dfs暴力找该暴的雷
                    }
                }
            }
        }
    }
    int ans=0;
    for(int i=1;i<=n;++i)
        if(st[find(dd[i].x,dd[i].y)])
            ans++;
    cout<<ans<<'\n';
}
```

## 十七、距离、策略

[Problem - I - Codeforces](https://codeforces.com/gym/102801/problem/I)

dis表示i点到j最短距离，要求最短路最少价格。

有点诈骗的感觉
