# 字符串

## 一、子串，回文，字符串hash

[Problem - K - Codeforces](https://codeforces.com/gym/104095/problem/K)

注意初始化

回文串=》正着和反着进行hash，p排列数组不用多来，p数组表示的是排列之间的差距

翻转=》利用hash减去旧的新添新的，注意p数组的补位（减就行）

哪里翻转=》暴力第一个不同的位置，同的不用管

## 二、子串，贪心，双指针，全排列

[Problem - C - Codeforces](https://codeforces.com/contest/1793/problem/C)

左右端点值和最大最小有关=》子串可以通过删除得到，双指针

左右端点是最大最小值，则需要进行更更改，不是的话满足题意

## 三、指针，递推，全排列数，子串

[Problem - D - Codeforces](https://codeforces.com/contest/1793/problem/D)

上下两个串未出现的最小=》令其为x，那么1--x-1就都得出现，令L,R为其中满足条件的位置

需要特判1=》分开1的位置，计算其他位置的情况数，cnt*（cnt+1）/2；完整区间，所以是等差数列求和

合适的位置=》在【max(p+1,q+1),L）,(R,min(q-1,p-1)】,两个合适区间做乘法累加

最后加1，不太清楚

## 四、反向构造马拉车字符串

[Problem - F - Codeforces](https://codeforces.com/group/Aokqa6Haao/contest/445660/problem/F)

理应的右边界，和当前的右边界

一些特判，外加正确的对称位置

## 五、子串、字典序、对于相对位置和原来坐标的利用

[Problem - D - Codeforces](https://codeforces.com/contest/1847/problem/D)

## 六、对于子序列和子串的理解

从后往前，子序列不可能重复出现，累加每个数造成的影响，任意两个数的开始和结尾都是子序列无法重复子串的

开始想的大都是对的，但是对于细节的处理还是不太够

[Problem - F - Codeforces](https://codeforces.com/contest/1883/problem/F)

## 七、马拉车优化判回文串（双hash也行）

找特例判结论，用算法优化过程

[Problem - D - Codeforces](https://codeforces.com/contest/1944/problem/D)

思路、结论、马拉车找回文串

```c++
const int maxj = 2e5 + 100, mod = 1e9 + 7, inf = 0x3f3f3f3f;
char a[maxj], b[maxj << 1];
int p[maxj << 1], f1[maxj << 1], f2[maxj << 1]; // 记录每个对应位置的回文半径，注意是变换后的串,半径减1是回文长度
int n;
// int l[maxj<<1],r[maxj]
// 将长度变换成奇数
void init()
{
    int k = 0;
    b[k++] = '$';
    b[k++] = '#';
    for (int i = 0; i < n; ++i)
    {
        b[k++] = a[i];
        b[k++] = '#';
    }
    b[k++] = '^';
    n = k;
    for (int i = 0; i <= n; ++i)
    {
        f1[i] = f2[i] = 0;
    }
}
// 执行马拉车算法,可以求最长回文长度，
void manacher()
{
    // 右边界都采用开区间,所以是mr-i
    int mr = 0, mid;
    for (int i = 1; i < n; ++i)
    {
        // 根据分析，最长回文内部选最小
        if (i < mr)
            p[i] = min(p[2 * mid - i], mr - i);
        else
            p[i] = 1;

        // 进行扩展，算自己了
        while (b[i - p[i]] == b[i + p[i]])
            p[i]++;

        // 更新最大回文区间
        if (i + p[i] > mr)
        {
            mr = i + p[i];
            mid = i;
        }
    }
}
void solve()
{
    int m,nn;
    cin >> nn >> m;
    cin >> a;
    n = strlen(a);
    init();
    manacher();
    n -= 2;
    // for(int i=0;i<=n;++i)cout<<b[i]<<' ';
    // cout<<'\n';
    // 结论的寻找，代码的继承
    // 让下标都从0开始,从后往前
    for(int i=nn-1;i>=0;--i){
        // 奇偶位不一样
        if(i+1<nn&&a[i]==a[i+1])f1[i]=f1[i+1];
        else f1[i]=i+1;
        // 奇偶位一样
        if(i+2<nn&&a[i]==a[i+2])f2[i]=f2[i+2];
        else f2[i]=i+2;
    }
    // for(int i=0;i<nn;++i){
    //     cout<<f2[i]<<' ';
    // }
    // cout<<'\n';
    // 每一次的遍历
    while(m--){
        int l,r;cin>>l>>r;
        l--;
        int ans=0,len=r-l;
        // 判断奇偶位不同时的全部情况=>偶数长度
        if(f1[l]<r){
            int te=(len-1-(len-1)%2);
            // 偶数个不行的子集也都不行
            if(te>=2)ans=ans+(te+2)*((te-2)/2+1)/2;
        }
        // cout<<ans<<'\n';
        // 判断奇偶位相同的全部情况
        if(f2[l]<r||f2[l+1]<r){
            int te=(len-1-(len)%2);
            if(te>=3)ans=ans+(te+3)*((te-3)/2+1)/2;
        }
        // 不轴对称，补上最长的
        // cout<<ans<<'\n';
        if(p[l+r+1]<len)ans+=len;
        cout<<ans<<'\n';
    }

}
```

## 八、kmp算法

[C-小刻的字符串_2024CUST百度之星选拔赛决赛 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/83524/C)

重点在于题意的理解和kmp的理解

next数组：

如何匹配字符串：对next数组进行操作，匹配子串
