# 最短路径

## 一、

[Problem - H - Codeforces](https://codeforces.com/group/Aokqa6Haao/contest/427552/problem/H)

最短路，预处理，编号，暴力

### 思路：

dis【t】【i】表示，从1到t经过i编号的最小距离，首先运用dij算法预处理dis，编号累加即可，(注意是编号)

之后暴力解决ans的问题，ans=min(ans,dis[ t ] [ i ]+pre);pre累加w【i】的值，表示从1到t经过i，并累加权重w的最小答案。

### 注意：

1，如果出现说缓存区溢出，可能是endl或者别用read

2，每次都应采用较快的输入输出方式，容易t

3，用结构体处理小根堆 

```
priority_queue< node >que;
结构体重载
 bool operator <(const node&d) const{
        return w>d.w;//符号反向，表示小根堆
 }
```

4，最短路往往是dij，N^3的那个少见，而且dij往往需要改编，预处理

## 二、

[Problem - B - Codeforces](https://codeforces.com/group/Aokqa6Haao/contest/427952/problem/B)

单点对单点用bfs，筛法

### 思路：

先用筛法预处理素数，然后在外围sqrt里边while的方法下处理质因子建立点和质因子的关系，之后bfs加剪枝，

### 注意：

要用筛法，不然一大堆错。

点和质因子暴力过就不要再暴力了，会t

## 三、

[F-坐火车_2023年中国高校计算机大赛-团队程序设计天梯赛（GPLT）上海理工大学校内选拔赛（同步赛) (nowcoder.com)](https://ac.nowcoder.com/acm/contest/52244/F)

迪杰特斯拉的变形，有个先后影响因素

### 思路：

首先用迪杰特斯拉算法计算，然后因为题意要求有两个因素的影响，首先是城市数最小，之后是距离最短。

所有有  dis.cnt>cnt+1||（dis.cnt>=cnt+1&&dis.w>=now.w+ww)时更新。

### 注意：

加上小根堆后，node里边的operator>里边的也是>

## 四、最短路，第一个要素在范围内，第二个要素要最小

[E-LZ的冠军之旅_2024CUST百度之星选拔赛决赛 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/83524/E)

和两个要不太一样的是，其中一个要素在范围内即可

结构体内重载排序算法函数名operator <  里边 >

```c++
struct node{
    int v,w,t;
    bool operator < (const node& a)const {
        if(t!=a.t)return t>a.t;
        return w>a.w;
    }
};
vector<node>g[1200];
int vis[1200][1200]; // 点 宇宙币
int dis[1200][1200]; // 点 宇宙币 时间
int k,n,m;
int mn=0x3f3f3f3f;
void dij(){
    memset(dis,0x3f3f,sizeof(dis));
//     cout<<dis[0][0]<<' ';
    priority_queue<node>que;
    que.push({1,0,0});
    dis[1][0]=0;
    while(que.size()){
        auto now = que.top();
        que.pop();
        int u=now.v,t=now.t;// 主要看条件
        if(vis[u][t])continue;
        vis[u][t]=1;
        for(int i=0;i<g[u].size();++i){
            int ww=g[u][i].w,vv=g[u][i].v,tt=g[u][i].t;
            if(tt+t<=k&&dis[vv][tt+t]>=dis[u][t]+ww){
                dis[vv][tt+t]=dis[u][t]+ww;
                if(!vis[vv][tt+t]){
                    que.push({vv,dis[vv][tt+t],tt+t});// 更新所有情况
                }
            }
        }
    }
}
signed main(){

    cin>>k>>n>>m;
    for(int i=1,u,v,w,t;i<=m;++i){
        cin>>u>>v>>w>>t;
        g[u].push_back({v,w,t});
//         g[v].push_back({u,w,t});

    }
    dij();
    int ans=4557430888798830399;
    for(int i=0;i<=k;++i){
        ans=min(dis[n][i],ans);// 在可行时间内选最小花费
    }
    if(ans!=4557430888798830399)
        cout<<ans<<'\n';
    else cout<<"impossible\n";
    return 0;
}
```

