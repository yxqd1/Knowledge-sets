# 贪心思维暴力

贪心的一大特点就是排序

## 一、贪心，大整数

[P1080 [NOIP2012 提高组\] 国王游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1080)

### 思路：

可以用python代替大整数

假设a1,b1,a2,b2,max(s/b2,s * a2/b1)<max(s/b1,s * a1/b2)

由于s*a2/b1>=s/b1

要保证<成立=》s *a2/b1<s *a1/b2=》a2 * b2<a1*b1所以是乘积由小到大排

### 注意：

注意贪心，要注意一般情况公式的推导

## 二、贪心，字符串，时间戳，二进制

[Problem - F - Codeforces](https://codeforces.com/contest/1800/problem/F)

### 思路：

输入时要求奇数个，所以就只需要记录奇数个出现的字母，记录没出现过的字母的位置

处理时遍历没出现过字母的内容，前边记录，后边加和

### 注意：

用二进制记录，奇数为1，偶数为0，（1<<26)-1为26个1

## 三、

[Problem - C - Codeforces](https://codeforces.com/contest/1806/problem/C)

关键在于对于公式的推导，其实还是有点不太懂，公式推导涉及到分类和谈论

### 思路：

重点在于对于问题模拟暴力推导

所有的数都可以是0，

n==1时，在于它两个的差值

n==2时，0 0 0 0 ，-1 -1 -1  2 ，2  2  2  2

n是奇数时，只有0 0 0 0

n是偶数时，0 0 0 或者-1 -1.....n



## 四、二进制枚举暴力

[Problem - I - Codeforces](https://codeforces.com/group/Aokqa6Haao/contest/433997/problem/I)

### 思路：

从样例当中可以看出，每一项都不可以重复使用，所以需要消除影响

二进制枚举暴力每一行的选择，求行的和消除行中每一个元素的影响，然后用剩余次数求所选列（列求和并排序），最后选最大

### 注意：

注意枚举暴力，一维从0-2^(n)-1,二维从0-n-1进行枚举



```c++
	for(int i=0;i<(1<<n);++i){
		vector<int>now;
		int su=0;
		//枚举行的选择,注意暴力都是从0开始 
		for(int j=0;j<n;++j){
			if((i>>j)&1){
				now.push_back(j+1);
			}
		}
	}
```

## 五、构造题

[Problem - C - Codeforces](https://codeforces.com/contest/1809/problem/C)

### 思路

构造题往往是最简单，最一般的构造

左边都是整数右边都是负数

边界在于调整需要的次数-2 * pos -1 +2 *  (k-(pos+1)*pos/2),需要的个数 然后位置必须需要前边的;

## 六、gcd，lcm（重做

[Problem - C - Codeforces](https://codeforces.com/contest/1798/problem/C)

### 思路

题意：最小区间个数，区间指的是价值一致的段落

利用连续的性质,如果最大公因数%单价的最小公倍数==0，那么这一段就是可行的

## 七、构造题，

[Problem - D - Codeforces](https://codeforces.com/contest/1798/problem/D)

### 思路

那个全排列是个幌子，然后主要在于题意的突破

题意：任意连续区间的和小于max-min，而且n个数的和==0

策略：尽可能是前缀和为0，这样的话无论怎么找子串，区间和都尽可能接近0



## 八、二分（比较经典

[Problem - E - Codeforces](https://codeforces.com/group/Aokqa6Haao/contest/436613/problem/E)

### 思路：好多问题可以用assert去测试，如果re就是问题所在

1.    **//最大和最小，显然是二分**
2.    ​    **//在基础算法的基础上，一位一位走的题往往需要模拟模拟找找规律，最后打出代码，**
3.    ​    **//多举举反例，多去试试。**
4.    ​    **int** l=0,r=(1e18)/n;**//下界和上界，往往要开大，开成1e12是可以过的，因为如果每个a[i]都是1，然后mid=1e18   ，这样的话一定不行，开成ull也行   **
5.    ​    **int** ans=0;**//问的是抵抗力最小中的最大，直接查找的就是抵抗力，看看能不能满足要求，能的就尽可能大，**

```c++
int check(int mid){
    int ans=0;//j记录到达mid所需的次数
    for(int i=1;i<=n;++i){
        b[i]=(mid+a[i]-1)/a[i];//向上取整
    }
    int now=0;
    for(int i=1;i<=n;++i){
        if(b[i]<=0)continue;//这里边有个细节，前后走的时候，就算后边的点已经满足了，但是也得走
        //前一步后一步来回走就是策略
        ans += (b[i]-1)*2 ; 
        ans += i-now;//我得站在哪里的被另算了
        now=i;
        // ans ++;
        b[i + 1] = max(0ll , b[i + 1] - (b[i] - 1));
    }
    return ans;
}
```

## 九、思维水题

[Problem - D - Codeforces](https://codeforces.com/contest/1811/problem/D)

  **题意**：边长为斐波那契数的正方形分割矩阵

 **要求**：1，有一个x，y位置边长为1  2，最多一对一样边长，   3，正方形边长为斐波那契数

  **策略**：画图找规律，然后发现，从一侧、从f[n]开始到f[2]进行逐个摆放才行,这个是限制

好多题都强调策略这个事。

## 十、构造题

[Problem - F - Codeforces](https://codeforces.com/group/Aokqa6Haao/contest/436613/problem/F)

### 思路：

构造题，构造字典序最小，不重复决斗的问题

  逐个的决斗找规律，这个题和lowbit有关

  每个交换对称区间的长度是lowbit(i)*2，因为是对称区间所以可以作差，而且前面会对后边造成影响，可以继承。

```c++
int n,k;sc(n); sc(k);
    if(k>lowbit(n)-1){
        puts("Impossible");
        return ;
    }
    for(int i=1;i<=n;++i)a[i]=i;
    for(int i=1;i<=k;++i){
        int len = lowbit(i) << 1;
        // cout<<len<<'\n';
        for(int j=1;j<=n;j+=len)
            for(int l=1;l<=len/2;++l){
                // cout<<j<<' '<<j+len-l<<'\n';
                swap(a[l+j-1],a[j+len-l]);
            }
        for(int j=1;j<=n;++j)cout<<a[j]<<' ';
        cout<<'\n';
    }
```

## 十一、贪心暴力分组

[Problem - D - Codeforces](https://codeforces.com/group/Aokqa6Haao/contest/436613/problem/D)

### 思路：

题意：a和b的每一位构造出c，给c求如何构造a，b

策略：贪心暴力，一轮一轮去暴力

先确定a[0]后确定b，然后确定其他a并检查是否是可行解

这一类题往往都需要贪心暴力的求解，要在满足条件的前提下求解检查

```c++
bool ask(){
    int len=strlen(cc);
    int pos=0;
    //先由a[0]确定b
    for(int j=0;j<m;++j){
        if(pos==len)return 0;//位数不够了
        int x=cc[pos++]-'0';
        if(pos<len&&x&&x<a[0])x=x*10+cc[pos++]-'0';//需要2位数
        if(x%a[0]||x/a[0]>9)return 0;
        b[j]=x/a[0];
    }
    //然后由b确定每一位的a
    for(int i=1;i<n;++i){
        for(int j=0;j<m;++j){
            if(pos==len)return 0;//数不够了
            int x=cc[pos++]-'0';
            if(pos<len&&x&&x<b[j])x=x*10+cc[pos++]-'0';
            //当求a的时候，x=0就变得非常麻烦
            if(x&&(b[j]==0||(j&&a[i]==0)))return 0;//x不是理想值
            if(x==0){
                //最开始它有可能成为0
                if(b[j]&&(j&&a[i]))return 0;//两个都不是0,x=0已经确定了
                if(!j)a[i]=0;
            }else {
                //查看是否符合情况
                if(x%b[j]||(j&&x/b[j]!=a[i])||x/b[j]>9)return 0;
                a[i]=x/b[j];
            }
        }
    }
    return pos==len;
}
```

## 十二、构造题，鸽巢原理

[Problem - C - Codeforces](https://codeforces.com/group/QJA47ykHfD/contest/437692/problem/C)

鸽巢原理，1---n+1之间会有b[i]%n==b[j]%n;  b[i]指的是有i个连续的1  

x=b[j] - b[i]  

就是有j-i个连续的1后有i个0，在取余意义下，0%n取余可以整除 。

## 十三、交互构造

[Problem - C - Codeforces](https://codeforces.com/contest/1797/problem/C)

从最简单最基本的部分构造，

题意：三次询问下，找到初始地点的准确下标

策略：先询问（1，1），返回的k，那么准确下标就在k+1行或者k+1列，那么如果a+1的位置超过n或者m，再询问一次之后确定准确的行或者列

其他询问a = (k+1,1),b = (1,k+1),a和b如果都是k，那么答案在(k+1,k+1)位置，a不够k，(k+1,a),b不够k那么(b,k+1)，这样就可以准确找到位置。

## 十四、贪心、check，模拟思维规律

[Problem - D - Codeforces](https://codeforces.com/contest/1816/problem/D)

### 思路：

因为每一次切，都会导致其中一部分的丢失，所以最大的h或者w，都可能是原来的h或者w，需要通过check函数模拟，

check主要是：h和w在不超过1e6+10的情况下，每次吃最小的一部分，

​				如果h有的位置有，那么就吃掉这一段，

​				如果w有，那么就吃掉，否则，就不行（缺几段，

开空间a、b数组开N的大小，ph和pw开ai的大小，每次吃最小的段落，这样时间上就是可以的。

每一次吃都是重复子问题，数组大小，int 和long long 的区别使用是重点。

## 十五、贪心、排序、模拟

[Problem - D - Codeforces](https://codeforces.com/contest/1821/problem/D)

### 思路：

由于有按下和拿起的操作，所以区间需要选择，

贪心选择的策略是每次删掉长度最短的，每次删的时候选择最小的操作次数，过程运用模拟

## 十六，构造

[Problem - D - Codeforces](https://codeforces.com/contest/1823/problem/D)

### 思路：

1，突破点都是一些固定的模型

2，abc作为固定填充，开始有贡献之后没有贡献，关注k的范围，新的贡献产生于新的字母

## 十七、模拟，思维，规律（建议重做

[Problem - I - Codeforces](https://codeforces.com/group/n9YFSztryg/contest/440964/problem/I)

### 思路：

参考题解：[2021浙江省赛_ChikingChen的博客-CSDN博客](https://blog.csdn.net/two_big_monkey/article/details/123272342)

普通的折叠就不太好想，有个特例，1叠2,2叠3,3叠1，这个特例特别难想。

输入就要掌握规律，

## 十八、贪心思维或者线段树（好

[Problem - D - Codeforces](https://codeforces.com/contest/1826/problem/D)

### 思路：

题意：最短区间下最大和

策略：线段树维护和或者前缀和维护区间关系。

前缀开始可以有差距，但是后边必须进行更改，统一化操作最好。

## 十九、位运算暴力，简化步骤

[Problem - H - Codeforces](https://codeforces.com/group/Aokqa6Haao/contest/445660/problem/H)

## 二十、前缀和，题意难懂

[Problem - J - Codeforces](https://codeforces.com/group/Aokqa6Haao/contest/445660/problem/J)

## 二十二、双指针、反向构造，

[Problem - C - Codeforces](https://codeforces.com/contest/1839/problem/C)

### 思路：

题意：经过合适的操作,能使得b变成a

右侧添加0，从p以及他的左侧取反

策略：正难则反，反向构造，

问题转化为将当前0删除，之前的取反、删除

## 二十三、二分判断

[Problem - C - Codeforces](https://codeforces.com/contest/1856/problem/C)

挺经典的，check是模拟，二分找尽可能达到的位置

找到最大值一直向前，会是逐渐减1的趋势

## 二十四、和左右某个数的位置有关

[Problem - D - Codeforces](https://codeforces.com/contest/1849/problem/D)

## 二十五、枚举，寻找数值之间的关系

[Problem - C - Codeforces](https://codeforces.com/contest/1848/problem/C)

## 二十六、找到合并时普遍的规律，奇数位和偶数位

[Problem - C - Codeforces](https://codeforces.com/contest/1844/problem/C)

## 二十七、余数之间的规律，循环节

[Problem - D - Codeforces](https://codeforces.com/contest/1844/problem/D)

## 二十八、区间最大异或值

[Problem - C - Codeforces](https://codeforces.com/contest/1847/problem/C)

## 二十九、找数值间的运算公式

[Problem - B - Codeforces](https://codeforces.com/contest/1836/problem/B)

## 三十、模拟，有了公式就可以固定一边推导另一边

[Problem - C - Codeforces](https://codeforces.com/contest/1836/problem/C)

## 三十一、二分答案，重点在于check

[码题集OJ-第五维度 (matiji.net)](https://www.matiji.net/exam/brushquestion/3/4347/179CE77A7B772D15A8C00DD8198AAC74?from=1)

## 三十二、控制边界

可以先不考虑两边，最后补上就行

[Problem - B - Codeforces](https://codeforces.com/contest/1858/problem/B)

## 三十四、二进制，d1也是

https://codeforces.com/contest/1869/problem/D2

## 三十五、变相链表

https://codeforces.com/contest/1867/problem/D

## 三十六、双指针，模拟，数学推导

https://codeforces.com/contest/1872/problem/G

## 三十七、异或操作

https://codeforces.com/contest/1872/problem/E

## 三十八、二进制位优化二维和

https://codeforces.com/contest/1879/problem/D

## 三十九、循环除转化为连续最小

https://codeforces.com/contest/1870/problem/D

## 四十、模拟链表

https://codeforces.com/gym/104022/problem/G

## 四十一、打标记，

采用打标记的方法优化复杂度

https://codeforces.com/contest/1864/problem/D

## 四十二、贪心，前缀和、后缀和，初始化

[Problem - D - Codeforces](https://codeforces.com/contest/1861/problem/D)

## 四十三、枚举暴力，落脚点的选择

[Problem - A - Codeforces](https://codeforces.com/gym/104076/problem/A)

## 四十四、模拟、找规律

[Problem - D - Codeforces](https://codeforces.com/contest/1877/problem/D)

## 四十五、二维前缀和，

一般到图这里就是二维前缀和，主要是对于矩阵的理解

首先，找到剩余矩阵的位置

然后，让矩阵进行真实的移动，记录每个位置经过的次数

最后，统计答案

[A (codeforces.com)](https://codeforces.com/gym/104128/problem/A)

## 四十六、二分

二分，前提二分维护的东西具有单调性

二分维护的常有答案，时间，

check，是按照条件打出来的

[Problem - D - Codeforces](https://codeforces.com/gym/104128/problem/D)

## 四十七、前缀和优化

[Problem - C - Codeforces](https://codeforces.com/contest/1884/problem/C)

## 四十八、多维，正难则反，二分

[Problem - G2 - Codeforces](https://codeforces.com/contest/1883/problem/G2)

排序，筛掉符合的条件的，作差找到不符合条件的

## 四十九、数学规律，循环

[Problem - C - Codeforces](https://codeforces.com/contest/1928/problem/C)



## 五十、位运算，规律

[Problem - D1 - Codeforces](https://codeforces.com/contest/1934/problem/D1)

```c++
void solve()
{
    // 有很多约定俗称的东西，审题很重要
    /*
        构造题
        题意：
          给n（n==x），m，n>m，问是否有y， 使得0<y<x and 0<(x⊕y)<x 然后就可以将y赋值或者异或值赋值
        问是否存在这么个序列使得n变成m

        思路：
          如果本身nm满足题意直接构造即可，
          否则，就是异或值不满足，找到一个中间值使得异或值满足并且和m的关系也成立
    */
    int n, m;
    cin >> n >> m;
    // 检测是否可以一步
    if ((n ^ m) < n)
    {
        // cout << -1 << '\n';
        cout<<1<<'\n';
        cout<<n<< ' ' <<m<<'\n';
        return;
    }
    // 消除相同位的情况
    int i = 60;
    while ((n >> i & 1) == (m >> i & 1))
        i--;
    int j = i - 1;
    // 是否有某一位n是0，m是1的情况
    while (j >= 0 && (~n >> j & 1))
    {
        if (m >> j & 1)
        {
            cout << -1 << '\n';
            return;
        }
        j--;
    }
    // 构造k使得，对n异或值变小，对后边大
    // 前半部分改变问题位，后半部分保证大于m
    // 注意位运算优先级
    int k = (n ^ (1ll << i) | ((1ll << (j + 1)) - 1));
    assert((k ^ n) < n);
    assert(k < n);
    assert((m ^ k) < k);
    assert(m < k);
    cout << 2 << '\n';
    cout << n << ' ' << k << ' ' << m << '\n';
}
```

## 五十一、双指针优化，二维前缀和

[4405. 统计子矩阵 - AcWing题库](https://www.acwing.com/problem/content/4408/)

```c++
// 问子矩阵和不超过k的矩阵个数
    // 首先是二维前缀和，之后  原本的暴力是四维，之后通过指针操作优化一维
    int n,m,k;cin>>n>>m>>k;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            cin>>g[i][j];
            g[i][j]+=g[i-1][j]+g[i][j-1]-g[i-1][j-1];
        }
    }
    int ans=0;
    // 四条线中间夹闭区域
    for(int i=1;i<=m;++i){
        for(int j=i;j<=m;++j){
            for(int s=1,t=1;t<=n;++t){
                // 遍历可行性
                while(s<=t&&g[t][j]-g[t][i-1]-g[s-1][j]+g[s-1][i-1]>k)s++;
                ans+=t-s+1;
            }
        }
    }
    cout<<ans<<'\n';
```

## 五十二、二进制操作，状态转移

[Problem - D - Codeforces](https://codeforces.com/contest/1946/problem/D)

## 五十三、模拟，堆排序优化

[Problem - C - Codeforces](https://codeforces.com/contest/1935/problem/C)

## 五十四、模拟，正难则反，分类

[Problem - D - Codeforces](https://codeforces.com/contest/1935/problem/D)

## 五十五、字符串、规律

[Problem - C - Codeforces](https://codeforces.com/contest/1925/problem/C)

## 五十六、排列组合，规律

[Problem - E - Codeforces](https://codeforces.com/contest/1922/problem/E)

## 五十七、前缀、后缀和，位置限制

[Problem - D - Codeforces](https://codeforces.com/contest/1923/problem/D)

## 五十八、构造题、找到固定的模型然后构造

构造题比较固定的想法，找到固定的变化模型，然后去构造题意

+1：RDLU

+2：LURD

-1：DRUL

-2：ULDR

然后以198为界进行分类，另外*2+2也是在二进制位上的操作

[Problem - H - Codeforces](https://codeforces.com/group/n9YFSztryg/contest/520588/problem/H)

## 五十九、模拟，贪心

[Problem - H - Codeforces](https://codeforces.com/gym/102801/problem/H)

## 六十、二进制规律，矩阵异或

[Problem - E - Codeforces](https://codeforces.com/gym/102801/problem/E)

不可以由其他向量异或得到，涉及线性相关和线性无关

两个有偶数个1的数异或后仍有偶数个1，所以会有重复的

## 六十一、找完整的四边形，规律

[G-正方形的个数_2024CUST百度之星选拔赛决赛 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/83524/G)

边长为1  sqrt（2）  sqrt（5） 只要边长一样所有角度都为90都可以

看边长分情况，列统一的式子

## 六十二、dp或者双指针

[D-LH 想吃纸杯蛋糕_2024CUST百度之星选拔赛决赛 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/83524/D)

数对九取余为0的，各位和对九取余也为零

```c++
signed main(){
    scanf("%s",&s[1]);
    int len = strlen(s+1);
//     printf("%lld",len);
    memset(dp,-inf,sizeof(dp));
    dp[0][0]=0;// 最开始什么都没有
    for(int i=1;i<=len;++i){
        for(int j=0;j<=9;++j){
            // 当前位置可以清空
            dp[i][0]=fmax(dp[i-1][j],dp[i][0]);
            int res=(j*10+s[i]-'0') % 9;//  当前位由前边转移过来
            if(res==0)dp[i][0]=fmax(dp[i-1][j]+1,dp[i][0]);
            else dp[i][res]=fmax(dp[i][res],dp[i-1][j]);
        }
    }
    int ans=0;
    for(int i=0;i<=9;++i){
//         cout<<dp[len][i]<<''
        ans=fmax(ans,dp[len][i]);
//         printf("%d ",dp[len][i]);
    }
    printf("%d\n",ans);
    return 0; 
}
```

## 六十三、凸峰，规律

[Problem - C - Codeforces](https://codeforces.com/contest/1973/problem/C)

