# 读者-写者问题（写者优先）

## 一、问题概述

有两组并发进程：读者和写者，共享一个文件，要求:
（1）允许多个读者同时执行读操作
（2）任一写者在完成写操作之前不允许其它读者或写者工作
（3）写者执行写操作前，应让已有的写者和读者全部退出

## 二、写者优先

### 要求：

1. 写者线程的优先级高于读者线程。

2. 当有写者到来时应该阻塞读者线程的队列。

3. 当有一个写者正在写时或在阻塞队列时应当阻塞读者进程的读操作，直到所有写者进程完成写操作时放开读者进程。

### 解决方案如下：

   我们可以通过增加一个特权级队列来实现这个功能，一旦有写者申请写，那么后面的读者全部在特权及队列中排队

   每个读进程在读取之前都申请一下r，并且在申请成功读者数加一后就释放r，但是第一个写进程申请的时候占据r，后面的写进程无需申请r，直到所有的写进程结束后才释放r，而在这期间，所有申请的读进程都在r上排队，达到了写者优先的效果

```
int readcount=0, writecount=0; 
semaphore mutex1=1, mutex2=1, w=1, r=1 ; 
 
读者进程：
 
P(r); // 表示一个读者尝试进入
    P(mutex1); // 上锁进行读者计数更新，防止多个读者计数发生计数冲突的问题
        readcount++; // 更新读者计数器
        if (readcount == 1 ) // 检查自己是否为第一个读者
           P(w); // 如果是，则对文件上锁
     V(mutex1); // 开锁允许其他读者
V(r); // 表示已经进入并且退出
	 ...
      reading is performed
     ...
P(mutex1); // 上锁进行读者计数更新，防止多个读者计数发生计数冲突的问题
    readcount --; // 因为已经完成读操作，所以读者计数减一
    if (readcount == 0 ) // 检查自己是否为最后一个读者
        V(w); // 如果是，则释放文件资源
V(mutex1); // 开锁允许其他读者
 
写者进程：     
P(mutex2); // 上锁进行写者计数更新，防止多个写者计数发生计数冲突的问题
    writecount++; // 更新写者计数器
    if (writecount == 1 ) // 检查自己是否为第一个写者
           P(r); // 如果是，则抢 r 的锁，从而避免饿死
V(mutex2);  // 开锁允许其他写者
P(w); // 对资源上锁，防止其他写者同时进行写操作
   ...
    writing is performed
   ...
V(w); // 释放资源 
P(mutex2); // 上锁进行写者计数更新，防止多个写者计数发生计数冲突的问题
    writecount --; // 更新写者计数器
    if (writecount == 0) // 检查自己是否为最后一个写者
           V(r); //如果是，则放开 r 的锁，让读者可以进入
V(mutex2); // 开锁

```

## 三、补充

### 3.1读者优先

```
int readcount=0; 
semaphore mutex=1, wrt=1 ; 
 
读者进程：
    wait (mutex); // 上锁进行读者计数更新，防止多个读者计数发生计数冲突的问题
	readcount++; // 读者计数加一
	if (readcount == 1) // 检查是否为第一个读者 
	       wait(wrt); // 如果是，则对文件上锁
	signal (mutex); // 开锁允许其他读者
		…
	   reading is performed
		 …
	wait (mutex); // 上锁进行读者计数更新，防止多个读者计数发生计数冲突的问题
	readcount--; // 因为已经完成读操作，所以读者计数减一
	if (readcount == 0) // 检查自己是否为最后一个读者
		signal (wrt); // 如果是，则释放文件资源，之后写者可以进行写操作
	signal (mutex); // 开锁允许其他读者
 
 
写者进程：     
      wait(wrt); // 文件上锁
	    …
         writing is performed
	    …
      signal(wrt); // 开锁允许其他进程的读或写操作
```

### 3.2读写公平

#### 要求：

1. 优先级相同。
2. 写者、读者互斥访问。

#### 解决方案：

1. 设置file信号量实现对临界资源的互斥访问。
2. 设置计数器 readCount实现多个读者访问临界资源，通过设置信号量 mutex 实现对readCount计数器的互斥访问。
3. 设置信号量 w实现读者和写者的公平竞争（令牌）。
4. 设置信号量 rw实现只有读者队列或写者阻塞在 w（对资源的访问控制）

```
int readcount=0; 
semaphore mutex=1, rw=1 w=1; 
 
读者进程：
        wait (w); // 读者尝试进入
        wait (mutex); // 上锁进行读者计数更新，防止多个读者计数发生计数冲突的问题
        if (readcount == 0) // 检查是否为第一个读者
	       wait(rw); // 如果是，则对文件上锁
    	readcount++; // 读者计数加一	
    	signal (mutex); // 开锁允许其他读者
        signal (w); // 表示已经进入并且退出
		…
    	   reading is performed
		 …
    	wait (mutex); // 上锁进行读者计数更新，防止多个读者计数发生计数冲突的问题
    	readcount--; // 因为已经完成读操作，所以读者计数减一
    	if (readcount == 0) // 检查自己是否为最后一个读者
    		signal (rw); // 如果是，则释放文件资源，之后写者可以进行写操作
    	signal (mutex); // 开锁允许其他读者
 
 
写者进程：     
    wait(w); // 写者尝试进入
    wait(rw); // 文件上锁
	    …
         writing is performed
	    …
    signal(rw); // 开锁允许其他进程的读或写操作
    signal(w); // 表示已经进入并且退出
 
```

