# 子集和问题

## 问题描述：

给定一个集合，以及一个目标数值，要求找出集合中所有和为目标数值的子集。

假设我们有一组数：{3, 34, 4, 12, 5, 2}，目标和为 9，我们需要找到所有和为 9 的子集。

在这个例子中，解答应该是 {4, 5} 和 {2, 3, 4}。

## 一、回溯法：

### 思路：

​	此问题可以使用回溯法来求解问题，具体过程如下：

​	具体来说，它采用了深度优先搜索的方式，对于集合中的每一个元素，分别考虑选择或不选择的情况，并通过约束函数达到剪枝的效果，从而避免了不必要的搜索。最终，当搜索到最底层时，即已经确定了一个子集，如果它的和正好为目标值，则输出该子集。

​	具体实现上，代码首先读入集合大小、目标值和集合本身，然后初始化一些变量。接着调用 `dfs` 函数进行搜索，其中 `now` 表示当前已经选择的元素的和，`sum` 表示当前未选择的元素的和，`vis2` 数组表示每个元素是否被选择，`id` 表示当前处理的元素编号。在 `dfs` 函数中，每次都先判断是否到达边界条件，即已经处理完了所有元素。如果是，那么判断当前选择的元素和是否等于目标值，如果是则输出当前方案。否则直接返回。如果还没有处理完所有元素，那么分别考虑当前元素选择和不选择两种情况。对于选择的情况，如果当前已选择元素的和加上当前元素的值小于等于目标值，则将当前元素标记为已选择，并继续搜索下一个元素。对于不选择的情况，如果当前已选择元素的和加上未选择元素的总和都大于目标值，则将当前元素标记为未选择，并继续搜索下一个元素。这样通过约束条件剪枝，减少了无用的搜索，并最终得到了所有符合要求的子集和。

#### **约束函数**

```php+HTML

1，检查当前整数a[id]加入子集和是否超过W，若超过，则不能选择该路径。

2，一个结点满足now+sum<W,即即使选择剩余的所有整数，也不可能找到一个解。
```

#### **时间复杂度**

时间复杂度 O（2^n）,解空间树中有 2^ (n+1) -1个结点

####  **解空间树**

<img src="C:\Users\30279\Documents\Tencent Files\3027916815\FileRecv\MobileFile\扫描全能王 2023-05-26 19.03.jpg" alt="扫描全能王 2023-05-26 19.03" style="zoom:80%;" />

### 代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define vec vector<long long>
#define pii pair<int, int>
#define pi acos(-1)
#define rep(i, l, r) for (int i = l; i <= r; ++i)
// #pragma GCC optimize(2)                    //
// #pragma GCC optimize(3, "Ofast", "inline") //
#define debug cout << "appear" << '\n';
const int maxj = 4e5 + 10, MOD = 1e9 + 7, inf = 0x3f3f3f3f;
template <class t>
void read(t &res)
{
    char c;
    t flag = 1;
    while ((c = getchar()) < '0' || c > '9')
        if (c == '-')
            flag = -1;
    res = c - '0';
    while ((c = getchar()) <= '9' && c >= '0')
        res = res * 10 + c - '0';
    res *= flag;
}
// void read(__int128 &x){
//     x=0;
//     int f=1;
//     char ch;
//     if((ch=getchar())=='-')f=-f;
//     else x=x*10+ch-'0';
//     while((ch=getchar())>='0'&&ch<='9')x=x*10+ch-'0';
//     x*=f;
// }
// void print(__int128 x){
//     if(x<0){
//         putchar('-');
//         x=-x;
//     }
//     if(x>9)print(x/10);
//     putchar(x%10+'0');
// }//别和ios混用
int ksm(int a, int b,int m)
{ // 快速幂
    int ans = 1;
    a%=m;
    while (b)
    {
        if (b & 1)
            ans = ans * a%(m);
        a = a * a%(m);
        b >>= 1;
    }
    return ans%m;
}
// int log2(int a){
//     return floor(log(a)/log(2));
// }
// int lower_bit(int x){
//     return x&(-x);
// }
// bool check(int x){//判断回文数
//     int y=x,t=0;
//     while(y){
//         t=t*10+y%10;
//         y/=10;
//     }return x==t;
// }
// bool cmp1(int a,int b){//从大到小
//     return a>b;
// }
// bool cmpp(pair<char,int>a,pair<char,int>b){
//     return a.second<b.second;
// }
// int pai(int x){//全排列
//     if(x==0||x==1)return 1;
//     return x*pai(x-1)%mod;
// }
// int e[maxj],nex[maxj],head[maxj],cnt=1,w[maxj];
// void add(int u,int v,int ww){//链式前向星
//     e[cnt]=v;
//     nex[cnt]=head[u];
//     w[cnt]=ww;
//     head[u]=cnt++;
// }
// bool cmp(node a,node b){//结构体排序
//     return a.c>b.c;
// }
// int n;
// struct bit{//离散化+树状数组
//     int sum[maxj];
//     int lowbit(int x){return x&(-x);}
//     void add(int x,int c){while(x<=n)sum[x]+=c,x+=lowbit(x);}
//     int getsum(int x){int res=0;while(x)res+=sum[x],x-=lowbit(x);return res;}
// }t1;
// int f[maxj],inv[maxj];
// int n,m,p;
// int C(int n,int m){
//     if(m>n)return 0;
//     return ((f[n]*ksm(f[m],p-2,p))%p*ksm(f[n-m],p-2,p)%p);
// }
// int Lucas(int n,int m){
//     if(!m)return 1;
//     return C(n%p,m%p)*Lucas(n/p,m/p)%p;
// }
//有n个数，a装载数值，求子集和为w
int n;
int a[maxj];
int w;
int cnt;
void print(bool vis2[]){
    cout<<"第"<<++cnt<<"个解："<<'\n';
    for(int i=1;i<=n;++i){
        if(vis2[i]){
            cout<<a[i]<<' ';
        }
    }cout<<'\n';
}
void dfs(int now,int sum,bool vis2[],int id){
    //边界，最深的层次
    if(id>n){
        if(now==w){
            print(vis2);
        }
        return ;
    }
    //约束函数
    //这个点有可能被选择
    if(now+a[id]<=w){
        vis2[id]=1;
        dfs(now+a[id],sum-a[id],vis2,id+1);
    }
    //不可以实现的点
    if(now+sum>w){
        vis2[id]=0;
        dfs(now,sum-a[id],vis2,id+1);
    }

}
void solve()
{  
    puts("请输入数据个数，子集和的目标，最后输入数据: ");
    cin>>n>>w;
    bool vis[maxj];
    int sum=0;
    for(int i=1;i<=n;++i){
        cin>>a[i];
        sum+=a[i];
        vis[i]=0;
    }
    dfs(0,sum,vis,1);
}
signed main()
{
    // ios::sync_with_stdio(0);
    // cin.tie(0);
    // cout.tie(0);
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout); // a为add,,w
#endif
    int t;
    t = 1;
    // cin >> t;
    while (t--)
        solve();

    return 0;
}

```



## 二、二进制枚举：

### 思路：

由于递归往往可以转化成递推的方式，所以个人使用二进制枚举的方法暴力求解所有可能的子集，输出满足题意的解。这种方式的代码会很简洁，但是复杂度很高，与回溯法相似，指数级的复杂度。

具体实现如下：

1. 首先从输入中读取集合个数n和给定值w；
2. 读取n个整数存储在vector<int> a中，a[i]表示第i个数的值；
3. 利用位运算枚举所有子集，并计算当前子集元素之和sum以及包含的元素now；
4. 如果当前子集元素之和等于给定值w，则将当前子集now加入答案ans中；
5. 最后输出所有满足条件的子集。

需要注意的是，该算法的时间复杂度为指数级别，因此对于数据量较大的情况会非常慢。

#### **时间复杂度**

时间复杂度 O（2^n）

### 代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define vec vector<long long>
#define pii pair<int, int>
#define pi acos(-1)
#define rep(i, l, r) for (int i = l; i <= r; ++i)
// #pragma GCC optimize(2)                    //
// #pragma GCC optimize(3, "Ofast", "inline") //
#define debug cout << "appear" << '\n';
const int maxj = 4e5 + 10, MOD = 1e9 + 7, inf = 0x3f3f3f3f;
template <class t>
void read(t &res)
{
    char c;
    t flag = 1;
    while ((c = getchar()) < '0' || c > '9')
        if (c == '-')
            flag = -1;
    res = c - '0';
    while ((c = getchar()) <= '9' && c >= '0')
        res = res * 10 + c - '0';
    res *= flag;
}
// void read(__int128 &x){
//     x=0;
//     int f=1;
//     char ch;
//     if((ch=getchar())=='-')f=-f;
//     else x=x*10+ch-'0';
//     while((ch=getchar())>='0'&&ch<='9')x=x*10+ch-'0';
//     x*=f;
// }
// void print(__int128 x){
//     if(x<0){
//         putchar('-');
//         x=-x;
//     }
//     if(x>9)print(x/10);
//     putchar(x%10+'0');
// }//别和ios混用
int ksm(int a, int b,int m)
{ // 快速幂
    int ans = 1;
    a%=m;
    while (b)
    {
        if (b & 1)
            ans = ans * a%(m);
        a = a * a%(m);
        b >>= 1;
    }
    return ans%m;
}
// int log2(int a){
//     return floor(log(a)/log(2));
// }
// int lower_bit(int x){
//     return x&(-x);
// }
// bool check(int x){//判断回文数
//     int y=x,t=0;
//     while(y){
//         t=t*10+y%10;
//         y/=10;
//     }return x==t;
// }
// bool cmp1(int a,int b){//从大到小
//     return a>b;
// }
// bool cmpp(pair<char,int>a,pair<char,int>b){
//     return a.second<b.second;
// }
// int pai(int x){//全排列
//     if(x==0||x==1)return 1;
//     return x*pai(x-1)%mod;
// }
// int e[maxj],nex[maxj],head[maxj],cnt=1,w[maxj];
// void add(int u,int v,int ww){//链式前向星
//     e[cnt]=v;
//     nex[cnt]=head[u];
//     w[cnt]=ww;
//     head[u]=cnt++;
// }
// bool cmp(node a,node b){//结构体排序
//     return a.c>b.c;
// }
// int n;
// struct bit{//离散化+树状数组
//     int sum[maxj];
//     int lowbit(int x){return x&(-x);}
//     void add(int x,int c){while(x<=n)sum[x]+=c,x+=lowbit(x);}
//     int getsum(int x){int res=0;while(x)res+=sum[x],x-=lowbit(x);return res;}
// }t1;
// int f[maxj],inv[maxj];
// int n,m,p;
// int C(int n,int m){
//     if(m>n)return 0;
//     return ((f[n]*ksm(f[m],p-2,p))%p*ksm(f[n-m],p-2,p)%p);
// }
// int Lucas(int n,int m){
//     if(!m)return 1;
//     return C(n%p,m%p)*Lucas(n/p,m/p)%p;
// }
void solve()
{
    //数据量不可以太大，指数级复杂度
    puts("请输入集合个数，w大小，并随之输入数据： ");
    int n,w;
    cin>>n>>w;
    vector<int>a(n+1);
    for(int i=1;i<=n;++i){
        cin>>a[i];
    }
    vector<vec>ans;
    for(int i=1;i<(1<<n);++i){
        int sum=0;
        vector<int>now;
        for(int j=0;j<n;++j){
            if(i&(1<<j)){
                now.emplace_back(a[j+1]);
                sum+=a[j+1];
            }
        }
        if(sum==w)
        ans.emplace_back(now);
    }
    int cnt=0;
    for(auto i:ans){
        cout<<"第"<<++cnt<<"种方案"<<' ';
        for(auto j:i){
            cout<<j<<' ';
        }cout<<'\n';
    }
}
signed main()
{
    // ios::sync_with_stdio(0);
    // cin.tie(0);
    // cout.tie(0);
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout); // a为add,,w
#endif
    int t;
    t = 1;
    // cin >> t;
    while (t--)
        solve();

    return 0;
}

```

