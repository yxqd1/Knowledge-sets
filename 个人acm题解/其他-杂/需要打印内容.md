# 计算几何

## 一、相关公式

### 余弦公式：

a·b=| a |  | b | cos，其中| a |和| b |分别是这两个向量的模

### 已知两个点求直线：

已知直线上的两点P1(X1,Y1)  P2(X2,Y2)， P1  P2两点不重合。则直线的一般式方程AX+BY+C=0中，A B C分别等于：

A = Y2 - Y1

B = X1 - X2

C = X2 *Y1 - X1 * Y2

### 点到直线的距离

直线:Ax+By+C=0;

d=|A *x0+B *y0+C|/sqrt(A *A+B *B);

## 二、板子：

若开long double 容易T

若是double注意精度，取最小和最大可能有误差

```
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
using T = double;
struct Point {
    T x;
    T y;
    Point(T x = 0, T y = 0) : x(x), y(y) {}
    
    Point &operator+=(const Point &p) {
        x += p.x, y += p.y;
        return *this;
    }
    Point &operator-=(const Point &p) {
        x -= p.x, y -= p.y;
        return *this;
    }
    Point &operator*=(const T &v) {
        x *= v, y *= v;
        return *this;
    }
    friend Point operator-(const Point &p) {
        return Point(-p.x, -p.y);
    }
    friend Point operator+(Point lhs, const Point &rhs) {
        return lhs += rhs;
    }
    friend Point operator-(Point lhs, const Point &rhs) {
        return lhs -= rhs;
    }
    friend Point operator*(Point lhs, const T &rhs) {
        return lhs *= rhs;
    }
};

T dot(const Point &a, const Point &b) {//点乘,余弦，距离
    return a.x * b.x + a.y * b.y;
}

T cross(const Point &a, const Point &b) {//叉乘
    return a.x * b.y - a.y * b.x;
}
T len(Point p)//向量的长度
{
	return sqrt(p.x*p.x+p.y*p.y);
}
T dist(Point p,Point a,Point b)//点到直线的距离
{
	Point v1=b-a,v2=p-a;
	return fabs(cross(v1,v2)/len(v1));
}
void solve() {
    Point a[6];
    for (int i = 0; i < 6; i++) {
        cin >> a[i].x >> a[i].y;
    }
    
    if (cross(a[0] - a[1], a[2] - a[1]) < 0) swap(a[0], a[2]);
    if (cross(a[3] - a[4], a[5] - a[4]) < 0) swap(a[3], a[5]);
    
    double len0 = sqrt(dot(a[0] - a[1], a[0] - a[1]));
    double len1 = sqrt(dot(a[3] - a[4], a[3] - a[4]));
    
    if (abs(len0 - len1) > 1E-9) cout << "YES\n";
    else cout << "NO\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout); // a为add,,w
#endif
    int t;
    cin >> t;
    
    while (t--) {
        solve();
    }
    
    return 0;
}
//https://ac.nowcoder.com/acm/contest/46800/E  
```

# 数论

## 一、exgcd

### 基本原理

#### 裴蜀定理：

a、b不全为0，则存在正整数x、y使得

ax+by=__gcd(a,b);

#### 欧几里得算法：

辗转相除法，求a、b的最大公因数

它的板子就是扩展欧几里得板子的简略版

#### 扩展欧几里得算法：

算裴蜀定理里的最小x、y

### 应用：

exgcd用于求解不定方程*ax+by=c*的一组解。准确的说，它是用来求解**ax+by=gcd(a,b)**的x和y。

欧几里得算法：两个数x和y的[最大公约数](https://so.csdn.net/so/search?q=最大公约数&spm=1001.2101.3001.7020)**gcd(x,y)=gcd(y,x%y).**

### 常见推导的理解：

通解的理解：

- 对于ax+by=d 

若求出来的是x0，y0

x=x0-k*(b/d)

y=y0+k*(a/d)

- 对于ax+by=m

x=x0*m/d

y=y0*m/d

### 板子：

```c++
// 求x, y，使得ax + by = gcd(a, b)
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```

### 例题1：[P1082 [NOIP2012 提高组\] 同余方程 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1082)

#### 取余操作推导总结：

​    a%b==c <=>a=b*k+c  <=> c=a-a/b * b

#### 思路

原来的取余可以转化为

ax+my=b  =>  x0 y0 => x=x0*b/d%m  y=y0 * b/d%m 

### 例题2：[Problem - A - Codeforces](https://codeforces.com/gym/104090/problem/A)

exgcd只是一种求二元不定方程x、y的一种工具

ns+n*(n+1)/2 *d+sum)%m最小

a=n,b=n*(n+1)/2

a*x+b *y+sum)%m

#### 求最小值：

ax+by=k1g1

k1g1%m  =>  k1g1+t*m = k2g2

最开始的式子转化为:

(k2g2+sum)%m

k2可以为负，尽可能让k2g2接近sum，所以相当于ans=sum%g2

#### 求x、y

ax+by=k1g1

k1g1+tm=ans-sum=k2g2

反向求解，求两次exgcd即可

```
//好多数学公式都和取余有关，推导猜测尝试
//注意下边的步骤
void solve(){
    int n,m,sum=0;
    cin>>n>>m;
    for(int i=1,x;i<=n;++i){
        cin>>x;
        sum+=x;
    }
    sum%=m;
    //明白exgcd公式的本质加上一点推导
    //求最小值
    int a=n,b=n*(n+1)/2,x,y,k1,t;
    int g1=__gcd(a,b);
    int g2=__gcd(g1,m);
    int ans=sum%g2;
    //求xy，利用方程组求
    exgcd(g1,m,k1,t);
    //这时的k1是最小的k1，不是实际公式里的
    k1=((ans-sum)/g2%m*k1%m+m)%m;
    exgcd(a,b,x,y);
    x=(x*k1%m+m)%m,y=(y*k1%m+m)%m;
    cout<<ans<<'\n';
    cout<<x<<' '<<y<<'\n';
}
```



## 二、中国剩余定理

### 基本原理

求解一元线性同余方程，其中m1 m2 m3.....两两互质

x≡a1(%m1)

x≡a2(%m2)

x≡a3(%m3)

.....

### 板子题

[204. 表达整数的奇怪方式 - AcWing题库](https://www.acwing.com/problem/content/206/)

推导大致采取两两合并线性推导的方式来推导的

有点问题

```c++
void solve(){
    //两两结合，转化为取余m余a
    int a1,m1,a2,m2,n,x;cin>>n;
    cin>>m1>>a1;
    for(int i=1;i<n;++i){
        cin>>m2>>a2;
        int k1,k2;
        //先记着用吧,a是公式右边的数
        int d=exgcd(m1,-m2,k1,k2);
        if((a2-a1)%d){
            x=-1;
            break;
        }
        a1=((a2-a1)*k1/d%(m2/d)+m2/d)%(m2/d)*m1+a1;
        m1=abs(m1/d*m2);
    }
    if(x!=-1)
    x=(a1%m1+m1)%m1;
    cout<<x<<'\n';
}
```



## 三、整除分块

[P2261 [CQOI2007\]余数求和 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2261)

### 板子：

```
for(int l=1,r;l<=n;l=r+1){
	if(k/l !=0)
		r=min(k/(k/l),n);
   	else r=n;
	//r=n/(n/l);//k实质是需要分块的区间长度，可以和循环的n不一样
	ans+=(r-l+1)*(k/l);//区间长度*区间值
}
```

因为**a%b=a-b*(a/b);**     向上取整和向下取整相互转换**「m/k = (m+k-1)/k」**

所以

原式=求和（k-i*(k/i))

=>n*k-求和(i/(k/i)),

所以

外围循环i的范围1-n

内围r=k/(k/l)   

ans-=k/l* (r-l+1) *(l+r)/2 //区间值 * 区间长度 * 平均每个值大小

## 四、博弈论

### 3.1 nim游戏，sg函数

##### 关于nim游戏

- 必胜态：可以一步到达必败态的状态
- 必败态：无论怎么走都会到达必胜态

若一个游戏满足：

1. ​	由两名玩家交替行动

2. ​	在游戏进行的任意时刻，可以执行的合法行动与轮到哪位玩家无关
3. ​	不能行动的玩家判负

​		则称该游戏为一个公平组合游戏。

​		尼姆游戏（NIM）属于公平组合游戏，但常见的棋类游戏，比如围棋就不是公平组合游戏，因为围棋交战双方分别只能落黑子和白子，胜负判定也比较负责，不满足条件2和3。

##### 关于sg函数

1.Mex运算:
		设S表示一个非负整数集合.定义mex(S)为求出不属于集合S的最小非负整数运算,即: mes(S)=min{x};
		例如:S={0,1,2,4},那么mes(S)=3;

2.SG函数
		在有向图游戏中,对于每个节点x,设从x出发共有k条有向边,分别到达节点y1,y2,····yk,定义SG(x)的后记节点y1,y2,····yk的SG函数值构成的集合在执行mex运算的结果,即: SG(x)=mex({SG(y1),SG(y2)····SG(yk)})
		特别地,整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值,即 SG(G)=SG(s).

3.有向图游戏的和
		设G1，G2,····,Gm是m个有向图游戏.定义有向图游戏G,他的行动规则是任选某个有向图游戏Gi,并在Gi上行动一步.G被称为有向图游戏G1,G2,·····,Gm的和.
		有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数的异或和,即: SG(G)=SG(G1)xorSG(G2)xor···xor SG(Gm)

#### 板子题：铁博文的号

[891. Nim游戏 - AcWing题库](https://www.acwing.com/problem/content/893/)

所有堆异或值为0则必败

[892. 台阶-Nim游戏 - AcWing题库](https://www.acwing.com/problem/content/894/)

```
//结论：奇数台阶的异或值为0，则必败
//理解：开始为0，后手可以让先手始终为0，后手可以跟随先手
//开始不为0，先手可以选择始终让后手为0的局面，从而使得后手必输
int n;cin>>n;
int ans=0;
for(int i=1,x;i<=n;++i){
    cin>>x;
    if(i&1){
        ans^=x;
    }
}
if(ans)cout<<"Yes"<<'\n';
else cout<<"No"<<'\n';
```

[893. 集合-Nim游戏 - AcWing题库](https://www.acwing.com/problem/content/895/)

sg函数，每一堆情况的异或和

```
int sg(int x)
{
    if(f[x]!=-1) return f[x];
    //因为取石子数目的集合是已经确定了的,所以每个数的sg值也都是确定的,如果存储过了,直接返回即可
    set<int> S;
    //set代表的是有序集合(注:因为在函数内部定义,所以下一次递归中的S不与本次相同)
    for(int i=0;i<m;i++)
    {
        int sum=s[i];
        if(x>=sum) S.insert(sg(x-sum));
        //先延伸到终点的sg值后,再从后往前排查出所有数的sg值
    }

    for(int i=0;;i++)
    //循环完之后可以进行选出最小的没有出现的自然数的操作
     if(!S.count(i))
      return f[x]=i;
}
```

[894. 拆分-Nim游戏 - AcWing题库](https://www.acwing.com/problem/content/896/)

sg函数，模拟每一堆的变化。

最大值变小，所以一定可以结束

```
int f[120];
//由大变小，模拟每一堆的变化
int sg(int x){
    //第一步：记忆化
    if(f[x]!=-1)return f[x];
    //第二步：递归模拟变化，找到所有的sg
    unordered_set<int>se;
    for(int i=0;i<x;++i){//两堆更小的子问题
        for(int j=0;j<=i;++j){
        //子问题的和，用^
            se.insert(sg(i)^sg(j));
        }
    }
    //第三步：mex函数
    for(int i=0;;i++){
        if(!se.count(i))return f[x]=i;
        
    }
}
```

## 五、容斥原理

### 基础原理：

公式：|A∪B∪C| = |A+B+C| - |A∩B| - |B∩C| - |C∩A| + |A∩B∩C|

一共有:2^n-1项

### 核心理解：

对于这类题往往采用二进制枚举子集，复杂度往往有2^n大小，需要先定义相关集合，并且要明确集合的计算方式。

1. 定义集合，明确公式
2. 计算集合大小，枚举计算
3. 返回答案

### 例题

#### 一、[890. 能被整除的数 - AcWing题库](https://www.acwing.com/problem/content/892/)

核心代码：

```int p[20];
int p[20];
void solve(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<m;++i){
        cin>>p[i];
    }
    int ans=0;
    //二进制枚举的方式解决容斥问题
    for(int i=1;i<(1<<m);++i){
        int cnt=0;//统计个数,奇数加，偶数减
        int now=1;//统计当前质数是谁
        for(int j=0;j<m;++j){
            if(i>>j&1){
                if(now*p[j]>n){
                    cnt=-1;
                    break;
                }
                cnt++;
                now*=p[j];
            }
        }
        // cout<<now<<'\n';
        if(cnt!=-1){
            if(cnt&1)ans+=n/now;
            else ans-=n/now;
        }
    }
    cout<<ans<<'\n';
}
```

#### 二、[214. Devu和鲜花 - AcWing题库](https://www.acwing.com/problem/content/216/)

核心理解：

公式推导：

所有的情况减去不成立的情况,不成立的情况在于取并集，所以容斥原理做

定义集合：si表示第i个盒子不合法

公式（正难则反）：C（n+m−1，n−1）−|s1|−|s2|−…−|sn|+|s1∩s2|+|s1∩s3|+…+|sn−1∩sn|−|s1∩s2∩s3|−…

si计算：C（n+m−1-(pi+1)，n−1）

​              因为每个至少pj个，所以也用了正难则反的想法，而且因为映射关系，所以要加1,表示从剩下m-pj里面在做选择

核心代码：



```c++
int down=1;
int n,m;
//所选的项数特别小，所以可以暴力计算组合数
int c(int a,int b){
    if(a<b||b<0)return 0;
    int up=1;
    for(int i=a;i>a-b;--i)up=i%mod*up%mod;//i可能很大
    return up*down%mod;
}
void solve(){

    cin>>n>>m;
    for(int i=0;i<n;++i){
        cin>>p[i];
    }
    down=1;
    for(int i=1;i<n;++i)down=down*i%mod;
    down=ksm(down,mod-2);
    // cout<<c(3,1)<<'\n';
    int ans=c(n+m-1,n-1);//答案是：所有的情况减去不成立的情况,不成立的情况在于取并集，所以容斥原理做
    // cout<<ans<<'\n';
    //容斥原理，遍历所有项的情况,
    for(int i=1;i<(1<<n);++i){
        int sign=1;
        int a=m+n-1,b=n-1;
        //
        for(int j=0;j<n;++j){
            if(i>>j&1){
                sign*=-1;
                //因为每个至少pj个，所以也用了正难则反的想法，而且因为映射关系，所以要加1
                a-=p[j]+1;
            }
        }
        // cout<<sign<<' '<<c(a,b)<<'\n';
        ans=(ans+sign*c(a,b)+mod)%mod;
    }
    cout<<ans<<'\n';
}
```

#### 三、[215. 破译密码 - AcWing题库](https://www.acwing.com/problem/content/description/217/)

核心理解：

有个问题的转换，通过a/d、b/d将问题转换成在a/d、b/d范围内两两互质的种类数（因为*d相当于公因子为d），而这个问题用莫比乌斯（辅助）、整除分块（降低复杂度）来解决刚好，运用容斥原理，总-单个质数+两个质数。。。（a在除l因为是除去质数得到种类数）

解决了质数数量问题，使用了莫比乌斯函数、整除分块、前缀和优化、公式推导相关的知识。

采用了正难则反加优化的想法。

核心代码：

```
const int maxj=1e5+10;
int prim[maxj],cnt;
bool vis[maxj];
int mo[maxj],sum[maxj];//莫比乌斯函数的记录
//欧拉筛求解莫比乌斯函数
void init(int n){
    mo[1]=1;
    for(int i=2;i<=n;++i){
        if(!vis[i]){
            prim[++cnt]=i;
            //奇数次出现
            mo[i]=-1;
        }
        for(int j=1;j<=cnt&&prim[j]*i<=n;++j){
            vis[i*prim[j]]=1;
            if(i%prim[j]==0){
                //有重复质子数
                mo[i*prim[j]]=0;
                break;
            }
            //奇数次偶数次轮流交替
            mo[prim[j]*i]=mo[i]*-1;
        }
    }
    //预处理前缀和
    for(int i=1;i<=n;++i)sum[i]=sum[i-1]+mo[i];
}
void solve(){
    int t;
    cin>>t;
    while(t--){
        int a,b,d;
        cin>>a>>b>>d;
        //向下取整，映射降低复杂度，转换问题
        a/=d,b/=d;
        int n=min(a,b);
        int ans=0;
        //整除分块，O(2*sqrt(n))级别的复杂度，
        for(int l=1,r;l<=n;l=r+1){
            r=min(n,min(a/(a/l),b/(b/l)));//固定右边界
            ans+=(sum[r]-sum[l-1])*(a/l)*(b/l);
        }
        cout<<ans<<'\n';
    }
}
```



## 六、概率与数学期望

### 基础原理

性质：事件发生的期望的线性性E(aX+bY)=aE(X)+bE(Y)

期望：所有情况的加权平均

### 核心理解

有的题是公式有的题是dp

概率题大多起点固定，终点不固定，
状态-数组，有向边-状态转移，多采用记忆化搜索，使用的是期望的性质

### 例题

#### 一、[217. 绿豆蛙的归宿 - AcWing题库](https://www.acwing.com/problem/content/219/)

```
double f[maxj];
int n,dout[maxj];
vector<pii>g[maxj];//建图
//概率题大多起点固定，终点不固定，
//状态-数组，有向边-状态转移，多采用记忆化搜索，使用的是期望的性质
double dp(int u){
    //边界
    if(f[u]>=0)return f[u];
    if(u>=n)return f[u]=0;//到终点的期望为0
    //初始化
    f[u]=0;
    for(auto i:g[u]){
        f[u]+=(i.second+dp(i.first))/dout[u];
    }
    return f[u];
}
void solve(){
    int m;
    cin>>n>>m;
    for(int i=0;i<=n;++i)f[i]=-1;
    //有向无环图
    for(int i=1;i<=m;++i){
        int x,y,w;
        cin>>x>>y>>w;
        g[x].emplace_back(y,w);
        dout[x]++;
    }    
    printf("%.2lf",dp(1));
}
```

#### 二、[218. 扑克牌 - AcWing题库](https://www.acwing.com/problem/content/220/)

```
const double inf=1e10;
//尽可能使用性质，设置好状态使得问题可以转化成搜索问题
int A,B,C,D;
double f[15][15][15][15][5][5];//到结束状态的期望
//题目中翻牌期望最小受到大小王的影响
double dp(int a,int b,int c,int d,int x,int y){
    //考虑边界
    double &v=f[a][b][c][d][x][y];
    if(v>=0)return v;
    if(a>13||b>13||c>13||d>13)return inf;
    //结束
    int as=a+(x==0)+(y==0);
    int bs=b+(x==1)+(y==1);
    int cs=c+(x==2)+(y==2);
    int ds=d+(x==3)+(y==3);
    if(as>=A&&bs>=B&&cs>=C&&ds>=D){
        return v=0;
    }
    int sum=a+b+c+d+(x!=4)+(y!=4);
    sum=54-sum;
    //少了个边界的情况sum,少个初始化
    v=1;
    if(sum<=0)return inf;
    //期望的性质是累加的
    if(a<13)v+=(13.0-a)/sum*dp(a+1,b,c,d,x,y);
    if(b<13)v+=(13.0-b)/sum*dp(a,b+1,c,d,x,y);
    if(c<13)v+=(13.0-c)/sum*dp(a,b,c+1,d,x,y);
    if(d<13)v+=(13.0-d)/sum*dp(a,b,c,d+1,x,y);
    //大小王是在选择最小的期望
    if(x==4){
        double t=inf;
        for(int i=0;i<4;++i){
            //忘记了期望概率了
            t=min(t,1.0/sum*dp(a,b,c,d,i,y));
        }
        v+=t;
    }
    if(y==4){
        double t=inf;
        for(int i=0;i<4;++i){
            t=min(t,1.0/sum*dp(a,b,c,d,x,i));
        }
        v+=t;
    }
    return v;
    
}
void solve(){
    memset(f,-1,sizeof(f));
    cin>>A>>B>>C>>D;
    //初始状态就是化整为零结束的位置
    double t=dp(0,0,0,0,4,4);
    // cout<<(int)t<<'\n';
    if(t>1e5)cout<<"-1.000"<<'\n';
    else
    printf("%.3lf",t);
}
```

# 树论

## 树链剖分

[树链剖分 - OI Wiki (oi-wiki.org)](https://oi-wiki.org//graph/hld/)



第一个 DFS 记录每个结点的父节点（father）、深度（deep）、子树大小（size）、重子节点（hson）。

第二个 DFS 记录所在链的链顶（top，应初始化为结点本身）、重边优先遍历时的 DFS 序（dfn）、DFS 序对应的节点编号（rank）。



```
fa(x) 表示节点 x 在树上的父亲。
dep(x) 表示节点 x 在树上的深度。
siz(x) 表示节点 x 的子树的节点个数。
son(x) 表示节点 x 的 重儿子。
top(x) 表示节点 x 所在 重链 的顶部节点（深度最小）。
dfn(x) 表示节点 x 的 DFS 序，也是其在线段树中的编号。
rnk(x) 表示 DFS 序所对应的节点编号，有 rnk(dfn(x))=x。
```

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxj=1e5+100;
int tr[maxj<<2],laz[maxj<<2];//用于树
int sz[maxj],dep[maxj],fa[maxj],son[maxj];//用于dfs1
int top[maxj],id[maxj],nw[maxj];//用于dfs2
int k,n;
int a[maxj];
vector<int>g[maxj<<1];
//处理重儿子和树上的基本信息
void dfs1(int no,int father,int depth){
    dep[no]=depth,fa[no]=father,sz[no]=1;
    for(auto i:g[no]){
        if(i==father)continue;
        dfs1(i,no,depth+1);
        sz[no]+=sz[i];
        if(sz[son[no]]<sz[i])son[no]=i;
    }
}
//处理重链
void dfs2(int no,int to){
    top[no]=to,id[no]=++k,nw[k]=a[no];
    if(!son[no])return ;
    dfs2(son[no],to);
    for(auto i:g[no]){
        //注意条件
        if(i==fa[no]||i==son[no])continue;
        dfs2(i,i);
    }
}  
void pushup(int rt){
    tr[rt]=tr[rt<<1|1]+tr[rt<<1];
}
void pushdown(int rt,int l,int r){
    //左边
    laz[rt<<1]+=laz[rt];
    tr[rt<<1]+=laz[rt]*l;
    //右边
    laz[rt<<1|1]+=laz[rt];
    tr[rt<<1|1]+=laz[rt]*r;
    laz[rt]=0;
}
//建树
void build(int l,int r,int rt){
    if(l==r){
        tr[rt]=nw[l];
        laz[rt]=0;
        return ;
    }
    int mid=(l+r)>>1;
    build(l,mid,rt<<1);
    build(mid+1,r,rt<<1|1);
    pushup(rt);
}
//询问操作
int  query(int L,int R,int l,int r,int rt){
    if(L<=l&&R>=r){
        return tr[rt];
    }
    int mid=(l+r)>>1;
    if(laz[rt]){
        pushdown(rt,mid-l+1,r-mid);
    }
    int ans=0;
    if(R>mid)ans+=query(L,R,mid+1,r,rt<<1|1);
    if(L<=mid)ans+=query(L,R,l,mid,rt<<1);
    return ans;
    // if(L>mid)return query(L,R,mid+1,r,rt<<1|1);
    // if(R<=mid)return query(L,R,l,mid,rt<<1);
    // return query(L,mid,l,mid,rt<<1)+query(mid+1,R,mid+1,r,rt<<1|1);
}
//更新操作
void update(int L,int R,int l,int r,int rt,int k){
    //结束位置
    if(L<=l&&R>=r){
        tr[rt]+=(r-l+1)*k;
        laz[rt]+=k;
        return ;
    }
    int mid=(l+r)>>1;
    if(laz[rt]){
        pushdown(rt,mid-l+1,r-mid);
    }
    if(R>mid)update(L,R,mid+1,r,rt<<1|1,k);
    if(L<=mid)update(L,R,l,mid,rt<<1,k);
    // if(L>mid)update(L,R,mid+1,r,rt<<1|1,k);
    // else if(R<=mid)update(L,R,l,mid,rt<<1,k);
    // else update(L,mid,l,mid,rt<<1,k),update(mid+1,R,mid+1,r,rt<<1|1,k);
    pushup(rt);
}
//更新路径
void update_path(int u,int v,int k){
    //树剖的经典操作，模拟lca向上跳跃
    while(top[u]!=top[v]){
        //是top之间的比较
        if(dep[top[u]]<dep[top[v]])swap(u,v);
        update(id[top[u]],id[u],1,n,1,k);
        u=fa[top[u]];
    }
    //直到同一个链中
    if(dep[u]<dep[v])swap(u,v);
    update(id[v],id[u],1,n,1,k);
    
}
//更新子树
void update_subtr(int u,int k){
    //结束尺寸不太对
    update(id[u],id[u]+sz[u]-1,1,n,1,k);
}
//询问路径
void query_path(int u,int v){
    int ans=0;
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]])swap(u,v);
        ans+=query(id[top[u]],id[u],1,n,1);
        u=fa[top[u]];
    }
    if(dep[u]<dep[v])swap(u,v);
    ans+=query(id[v],id[u],1,n,1);
    cout<<ans<<'\n';
}
//询问子树
void query_subtr(int u){
    cout<<query(id[u],id[u]+sz[u]-1,1,n,1)<<'\n';
}
signed main(){
    cin>>n;
    for(int i=1;i<=n;++i)cin>>a[i];
    for(int i=1;i<n;++i){
        int u,v;cin>>u>>v;
        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }
    
    dfs1(1,0,1);
    dfs2(1,1);
    build(1,n,1);
    
    int m;cin>>m;
    while(m--){
        int op;
        cin>>op;
        if(op==1){
            int u,v,k;cin>>u>>v>>k;
            update_path(u,v,k);
        }else if(op==2){
            int u,k;cin>>u>>k;
            update_subtr(u,k);
        }else if(op==3){
            int u,v;cin>>u>>v;
            query_path(u,v);
        }else{
            int u;cin>>u;
            query_subtr(u);
        }
    }
    return 0;
}
//https://www.luogu.com.cn/problem/P2590  树的统计
//https://www.acwing.com/problem/content/2570/
//https://www.acwing.com/problem/content/920/
```

### 动态开点线段树

```
/*
动态开点线段树 
*/
#include<cstdio> 
#include<cstring> 
#include<algorithm> 

inline int read() { //必须有，输入量大了，read是最快的
	int x = 0,f = 1; 
	char c  = getchar() ; 
	while(c < '0' || c > '9')c = getchar(); 
	while(c <= '9' && c >= '0') x = x * 10 + c - '0',c = getchar(); 
	return x * f; 
} 
const int maxn = 500007 * 30; //空间不可以给小了，
int rt = 0; 
struct Segtree { 
	int tot ; 
	int ls[maxn],rs[maxn],tag[maxn],sum[maxn]; 
	void pushdown(int x,int l,int r) { //区间是正经的区间，下标不是正经的下标
		int mid = l + r >> 1;  
		if(l != r) { 
 			if(!ls[x]) ls[x] = ++ tot; //记得开点这里 
 			if(!rs[x]) rs[x] = ++ tot; 
			sum[ls[x]] = (mid - l + 1) * tag[x]; 
			sum[rs[x]] = (r - mid) * tag[x]; 
			tag[ls[x]] = tag[x]; 
			tag[rs[x]] = tag[x]; 
		} 
		tag[x] = -1; 
	} 
	void modify(int &x,int l,int r,int L,int R,int w) {//需要用&，没有真的在开，动态的给下标赋值
		if(!x) x = ++ tot; //动态的开点，赋值
		if(l >= L && r <= R) { 
			sum[x] = (r - l + 1) * w; 
			tag[x] = w; 
			return; 
		} 
		if(tag[x] >= 0) pushdown(x,l,r); //0也需要更新，可能是需要开点，因为不是-1
		int mid = l + r >> 1; 
		if(L <= mid) modify(ls[x],l,mid,L,R,w); 
		if(R >  mid) modify(rs[x],mid + 1,r,L,R,w); 
		sum[x] = sum[ls[x]] + sum[rs[x]]; 
	} 
} t; 
int main() { 
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout); // a为add,,w
#endif
	int n = read(); 
	int m = read(); 
	memset(t.tag,-1,sizeof t.tag); //初始化，错1
	for(int type,l,r,i = 1;i <= m;++ i) { 
		l = read(),r = read(),type = read(); 
		if(type == 1) t.modify(rt,1,n,l,r,1); 
		else t.modify(rt,1,n,l,r,0); 
		printf("%d\n",n-t.sum[1]); 
	} 
	return 0; 
} 

//https://vjudge.net/contest/537315#problem/J 主要特点是范围很大没办法开
```

# 小技巧相关函数

### 2、vector取最大值

```
cout << (*max_element(v.begin() + 1, v.end())) << '\n';
```

### 3、sort排序，内置规则

```c++
vector<vector<int>>a(n,vector<int>(m));
for(int i=0;i<n;++i){
    for(int j=0;j<m;++j){
        cin>>a[i][j];
    }
    vector<int>o(m);//用于排序记录位置
    iota(o.begin(),o.end(),0);//从0开始，逐个递增填充数
    sort(o.begin(),o.end(),
        [&](int x,int y){
            return a[i][x]>a[i][y];
        });//sort内置规则
    a[i]=o;
}
```

### 4，填充初始化函数

```c++
vector<int>a(100);
fill(a.begin(),a.end(),12);
```

### 5，find的边界

```c++
s.find(t)!=string::npos //不等号为真 表示存在这个字符串t
```

### 6，bitset

下面是 `std::bitset` 类型的一些常用操作：

- `size()` 返回 `std::bitset` 的长度
- `count()` 返回 `std::bitset` 中值为 1 的位的数量
- `any()` 返回 `std::bitset` 中是否存在值为 1 的位
- `none()` 返回 `std::bitset` 中是否所有位都是 0
- `all()` 返回 `std::bitset` 中是否所有位都是 1
- `test(pos)` 返回 `std::bitset` 中位于 `pos` 位置的值
- `set(pos)` 将 `std::bitset` 中位于 `pos` 位置的值设为 1
- `reset(pos)` 将 `std::bitset` 中位于 `pos` 位置的值设为 0
- `flip(pos)` 将 `std::bitset` 中位于 `pos` 位置的值取反
- `to_ulong()` 返回 `std::bitset` 转换成的无符号整数值
- `to_ullong()` 返回 `std::bitset` 转换成的无符号长整数值

`std::bitset` 重载了许多二进制运算符，如 `&`、`|`、`^`、`~` 等，使其支持类似于整数类型的位运算操作。

# 字符串

## 一、后缀数组

### 概述

​     字符串从1开始sa[i]表示将所有后缀排序后第  i 小的后缀的编号，也是所说的后缀数组，后文也称编号数组 sa ；

​      rk[i]表示后缀  i 的排名，是重要的辅助数组，后文也称排名数组 rk 这两个数组满足性质：sa[rk[i]]=rk[sa[i]]=i

### 板子

应该是nlog

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxj = 1e6 + 100, MOD = 1e9 + 7, inf = 0x3f3f3f3f;
int sa[maxj], x[maxj], y[maxj], c[maxj], rk[maxj], height[maxj];
int n,m;
string s;
void get_sa()
{
    for (int i = 1; i <= n; i++)
        c[x[i] = s[i]]++;
    for (int i = 2; i <= m; i++)
        c[i] += c[i - 1];
    for (int i = n; i; i--)
        sa[c[x[i]]--] = i;
    for (int k = 1; k <= n; k <<= 1)
    {
        int num = 0;
        for (int i = n - k + 1; i <= n; i++)
            y[++num] = i;
        for (int i = 1; i <= n; i++)
            if (sa[i] > k)
                y[++num] = sa[i] - k;
        for (int i = 1; i <= m; i++)
            c[i] = 0;
        for (int i = 1; i <= n; i++)
            c[x[i]]++;
        for (int i = 2; i <= m; i++)
            c[i] += c[i - 1];
        for (int i = n; i; i--)
            sa[c[x[y[i]]]--] = y[i], y[i] = 0;
        swap(x, y);
        x[sa[1]] = 1, num = 1;
        for (int i = 2; i <= n; i++)
            x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++num;
            if (num == n) break;
        m = num;
    }
}
void get_height()
{
    for (int i = 1; i <= n; i++)
        rk[sa[i]] = i;
    for (int i = 1, k = 0; i <= n; i++)
    {
        if (rk[i] == 1)
            continue;
        if (k)
            k--;
        int j = sa[rk[i] - 1];
        while (i + k <= n && j + k <= n && s[i + k] == s[j + k])
            k++;
        height[rk[i]] = k;
    }
}int k;
bool check(int x){
    if(sa[x]>k&&sa[x-1]<k)return 1;
    if(sa[x-1]>k&&sa[x]<k)return 1;
    return 0;
}
void solve()
{
    //不是马拉车算法，马拉车算法是最长回文子串
    //在符合条件的子串中选最大的height，lcp
    string s1, s2;
    cin >> s1 >> s2;
    k=s1.size()+1;//恰好是分隔符的位置
    s=' '+s1+'@'+s2;
    n=s.size()-1;
    m=127;
    get_sa();
    get_height();
    int mn=min(s1.size(),s2.size());
    int ans=0;
    for(int i=1;i<=n;++i){
        if(check(i))ans=max(ans,height[i]);
    }
    cout<<ans<<'\n';
}
signed main()
{
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout); // a为add,,w
#endif
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t;
    t = 1;
    //     cin>>t;
    while (t--)
        solve();
    return 0;
}
//后缀数组在于对sa，rk，height 的理解和应用，尤其是height数组lcp
//尤其是height数组的运用，而且大部分题都和“相同子串”这个问题有关，并且有其他数据结构的加入
//https://ac.nowcoder.com/acm/contest/50135/D
//https://ac.nowcoder.com/acm/contest/50135/I   并查集+后缀数组，
```

