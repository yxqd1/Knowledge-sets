# 数独问题

## 题目描述：

​	给定一个部分填写的 9x9 的数独，每一行、每一列以及每一个小的 3x3 的方块中包含数字 1-9（数字不可重复），其他的空白格子需要填上正确的数字。使用回溯法，当我们发现已经填入的数字不满足要求时，就撤销上一步或几步的操作，再尝试其他的数字。

#### **规则：**

数独是一种来自日本的逻辑推理游戏。玩家需要填写数字以满足特定的条件。下面是基本的数独游戏规则：

（1） 数独通常是一个 9x9 的方格，由 9 个 3x3 的小方格（也称为"区域"或"盒"）组成。有些变体可能会有不同的大小，但是 9x9 的版本最为常见。

（2） 每一行、每一列以及每一个 3x3 的小方格中都必须包含数字 1 至 9，且每个数字在每一行、每一列和每一个小方格中只能出现一次。换句话说，任何数字都不能在同一行、同一列或同一个小方格中重复。

（3） 在开始游戏时，一些格子中已经填入了数字。玩家的任务是使用逻辑推理，找出剩下格子中的数字。

## 一、回溯法：

### 思路：

​	主要分为三个函数：init()、dfs()、solve()。

​	init()函数用来初始化标记数组和未标记位置数组，将已经填好的数字在对应的行、列、块进行标记。

​	dfs()函数是回溯搜索的核心部分，其参数pos表示当前搜索的位置。每次选择一个未填数字的格子，暴力枚举可填的数字，并检查是否满足数独规则（同一行、同一列、同一块不能有重复数字）。如果满足规则，则继续递归搜索下一个位置；如果不满足规则，则回溯到上一个状态，继续尝试其他数字。如果搜索完所有的未标记位置，找到了一组解，则设置ans=1退出函数。

​	solve()函数是主函数，用来输入数独矩阵数据并调用dfs()函数进行解题。如果找到了一组解，则输出解；否则输出不存在解。

时间复杂度较高，在最坏情况下需要遍历所有可能的数字组合，因此时间复杂度为指数级别。

#### **约束函数**

1，若已经找到，则结束dfs递归

2，若不满足行、列、块的条件，则不进行递归

#### **解空间树**

<img src="C:\Users\30279\Documents\Tencent Files\3027916815\FileRecv\MobileFile\扫描全能王 2023-05-26 21.23.jpg" alt="扫描全能王 2023-05-26 21.23" style="zoom:80%;" />

#### **时间复杂度：**

时间复杂度为：O(9^ve.size())

### 代码：

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define vec vector<long long>
#define pii pair<int, int>
#define pi acos(-1)
#define rep(i, l, r) for (int i = l; i <= r; ++i)
// #pragma GCC optimize(2)                    //
// #pragma GCC optimize(3, "Ofast", "inline") //
#define debug cout << "appear" << '\n';
const int maxj = 4e5 + 10, MOD = 1e9 + 7, inf = 0x3f3f3f3f;
template <class t>
void read(t &res)
{
    char c;
    t flag = 1;
    while ((c = getchar()) < '0' || c > '9')
        if (c == '-')
            flag = -1;
    res = c - '0';
    while ((c = getchar()) <= '9' && c >= '0')
        res = res * 10 + c - '0';
    res *= flag;
}
// void read(__int128 &x){
//     x=0;
//     int f=1;
//     char ch;
//     if((ch=getchar())=='-')f=-f;
//     else x=x*10+ch-'0';
//     while((ch=getchar())>='0'&&ch<='9')x=x*10+ch-'0';
//     x*=f;
// }
// void print(__int128 x){
//     if(x<0){
//         putchar('-');
//         x=-x;
//     }
//     if(x>9)print(x/10);
//     putchar(x%10+'0');
// }//别和ios混用
int ksm(int a, int b,int m)
{ // 快速幂
    int ans = 1;
    a%=m;
    while (b)
    {
        if (b & 1)
            ans = ans * a%(m);
        a = a * a%(m);
        b >>= 1;
    }
    return ans%m;
}
// int log2(int a){
//     return floor(log(a)/log(2));
// }
// int lower_bit(int x){
//     return x&(-x);
// }
// bool check(int x){//判断回文数
//     int y=x,t=0;
//     while(y){
//         t=t*10+y%10;
//         y/=10;
//     }return x==t;
// }
// bool cmp1(int a,int b){//从大到小
//     return a>b;
// }
// bool cmpp(pair<char,int>a,pair<char,int>b){
//     return a.second<b.second;
// }
// int pai(int x){//全排列
//     if(x==0||x==1)return 1;
//     return x*pai(x-1)%mod;
// }
// int e[maxj],nex[maxj],head[maxj],cnt=1,w[maxj];
// void add(int u,int v,int ww){//链式前向星
//     e[cnt]=v;
//     nex[cnt]=head[u];
//     w[cnt]=ww;
//     head[u]=cnt++;
// }
// bool cmp(node a,node b){//结构体排序
//     return a.c>b.c;
// }
// int n;
// struct bit{//离散化+树状数组
//     int sum[maxj];
//     int lowbit(int x){return x&(-x);}
//     void add(int x,int c){while(x<=n)sum[x]+=c,x+=lowbit(x);}
//     int getsum(int x){int res=0;while(x)res+=sum[x],x-=lowbit(x);return res;}
// }t1;
// int f[maxj],inv[maxj];
// int n,m,p;
// int C(int n,int m){
//     if(m>n)return 0;
//     return ((f[n]*ksm(f[m],p-2,p))%p*ksm(f[n-m],p-2,p)%p);
// }
// int Lucas(int n,int m){
//     if(!m)return 1;
//     return C(n%p,m%p)*Lucas(n/p,m/p)%p;
// }
bool ans=0;
char bord[10][10];
bool r[12][12];//行标记
bool c[12][12];//列标记
bool bloc[12][12][12];//块标记
vector<pii> ve;//未标记位置
void init(){
    for(int i=0;i<9;++i){
        for(int j=0;j<9;++j){
            if(bord[i][j]=='#'){
                // cout<<i<<' '<<j<<'\n';
                ve.emplace_back(i,j);                
            }else{
                int digit=bord[i][j]-'0'-1;
                r[i][digit]=c[j][digit]=bloc[i/3][j/3][digit]=1;
            }
        }
    }
}
void dfs(int pos){
    if(pos>=ve.size()){
        ans=1;
        return ;
    }
    //约束函数，已经存在答案
    if(ans){
        return ;
    }
    //暴力所有情况
    int ll=ve[pos].first,rr=ve[pos].second;
    for(int digit=0;digit<9;++digit){
        //约束函数，不满足规则
        if(r[ll][digit]||c[rr][digit]||bloc[ll/3][rr/3][digit])continue;
        r[ll][digit]=c[rr][digit]=bloc[ll/3][rr/3][digit]=1;
        bord[ll][rr]=digit+'0'+1;
        dfs(pos+1);
        if(ans)return ;
        bord[ll][rr]='#';
        r[ll][digit]=c[rr][digit]=bloc[ll/3][rr/3][digit]=0;
    }
}
void solve()
{  
    //解数独问题
    //回溯法
    puts("请给出9*9的矩阵数据，没有填写的用#表示");
    for(int i=0;i<9;++i){
        for(int j=0;j<9;++j){
            cin>>bord[i][j];
        }
    }

    init();
    // for(auto i:ve){
    //     cout<<i.first<<' '<<i.second<<'\n';
    // }
    dfs(0);
    if(ans){
        puts("输出其中的一组解：");
        for(int i=0;i<9;++i){
            for(int j=0;j<9;++j){
                cout<<bord[i][j];
            }cout<<'\n';
        }
    }else{
        puts("不存在解");
    }
}
signed main()
{
    // ios::sync_with_stdio(0);
    // cin.tie(0);
    // cout.tie(0);
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout); // a为add,,w
#endif
    int t;
    t = 1;
    // cin >> t;
    while (t--)
        solve();

    return 0;
}
/*
input
53##7####
6##195###
#98####6#
8###6###3
4##8#3##1
7###2###6
#6####28#
###419##5
####8##79
*/
```



## 二、优化方法

### 2.1位运算优化

可以通过位运算来提高算法的效率，位运算往往可以提高算法效率。

位运算，主要理解是将状态进行状态压缩，比方说9个数嘛，000000001表示9出现过，其他没有出现过，状态压缩为1（十进制）

#### 这个题涉及的位运算的意义理解：

1，  

```
r[ll] ^= (1 << digit);
c[rr] ^= (1 << digit);
bloc[ll / 3][rr / 3] ^= (1 << digit);
```

^异或运算，意义：将01互换

2，

```
 ~(r[ll] | c[rr] | bloc[ll / 3][rr / 3]) & 0x1ff;
```

括号内，意义：将所有出现的位合并，标记出现过

取非然后and，意义：表示没有出现过的数

3，

```
ma &= (ma - 1)
```

意义：将最低位1变为0

4，

```
int digitMa = ma & (-ma);
int digit = __builtin_ctz(digitMa);
```

digitMa，意义：表示ma最低位1的位置是啥

digit，意义：表示对应最低位1的十进制数

#### 代码：

```
bool ans = 0;
char bord[10][10];
int r[12];        // 行标记
int c[12];        // 列标记
int bloc[12][12]; // 块标记
vector<pii> ve;   // 未标记位置
void init()
{
    for (int i = 0; i < 9; ++i)
    {
        for (int j = 0; j < 9; ++j)
        {
            if (bord[i][j] == '#')
            {
                // cout<<i<<' '<<j<<'\n';
                ve.emplace_back(i, j);
            }
            else
            {
                int digit = bord[i][j] - '0' - 1;
                r[i] |= (1 << digit);
                c[j] |= (1 << digit);
                bloc[i / 3][j / 3] |= (1 << digit);
            }
        }
    }
}
void dfs(int pos)
{
    if (pos >= ve.size())
    {
        ans = 1;
        return;
    }
    // 约束函数，已经存在答案
    if (ans)
    {
        return;
    }
    // 暴力所有情况
    int ll = ve[pos].first, rr = ve[pos].second;
    //那些数没有出现过，ma为0，表示0-8全都出现过
    int ma = ~(r[ll] | c[rr] | bloc[ll / 3][rr / 3]) & 0x1ff;
    if (ans || !ma)
        return;
    // 找那些空的位，变化哪里是--下一个最低位的1
    for (; ma; ma &= (ma - 1))
    {
        int digitMa = ma & (-ma);
        int digit = __builtin_ctz(digitMa);
        // 约束函数，不满足规则
        r[ll] ^= (1 << digit);
        c[rr] ^= (1 << digit);
        bloc[ll / 3][rr / 3] ^= (1 << digit);
        bord[ll][rr] = digit + '0' + 1;
        dfs(pos + 1);
        if (ans)
            return;
        bord[ll][rr] = '#';
        r[ll] ^= (1 << digit);
        c[rr] ^= (1 << digit);
        bloc[ll / 3][rr / 3] ^= (1 << digit);
    }
}
```

### 2.2bitset优化

这个方法使用bitset来进行位运算的操作，与之前二进制位运算本质一样，但是在平台上进行自测时空间较大，而且理解不太容易。