# 校赛

## A小小蚁国

考点：双权值最短路

### 题意：

给出起点和终点，考虑两个因素 ，并且两个因素有轻重之分。

### 思路：

​    板子题，可以在网上搜到相关内容。       

​    使用堆优化版本的迪杰斯特拉算法，具体实现和单一因素和最短路算法不太一样，每一次更新都采用暴力的方式，这样可以不重不漏。详细内容看注释。

### 核心代码：

```
void dij()
{
    priority_queue<pii, vector<pii>, greater<pii>> que; // 是小根堆
    que.emplace(0, st);
    dis[st] = 0;
    cost[st] = 0;
    while (que.size())
    {
        pii now = que.top();
        que.pop();
        int u = now.second, w = now.first;
        if (vis[u])//出现过的点不要再次搜索
            continue;
        vis[u] = 1;
        // 暴力所有节点,寻找最短路径和最小粮食花费
        for (int i = 1; i <= n; ++i)
        {
            int v = i;
            if (dis[v] > dis[u] + d1[u][v])//最短路径
            {
                dis[v] = dis[u] + d1[u][v];
                cost[v] = cost[u] + d2[u][v];
                que.emplace(dis[v], v);
            }
            else if (dis[v] == dis[u] + d1[u][v])//最小粮食花费
            {
                cost[v] = cost[u] + d2[u][v];
                que.emplace(dis[v], v);
            }
        }
    }
}
```



## F瘟疫

考点：区间dp

### 题意：

给出S：S是期望的字符串，

给出操作：选择l和r，然后选择对应的字符，之后在l到r上覆盖原字符，直至成为期望的样子。

问最小操作次数

### 思路：

区间dp的板子题，

主要在于转移方程：

1. 左右颜色一样：

dp[l] [r] = min(dp[l] [r - 1], dp[l + 1] [r]);

​            2.不一样需要枚举间断点：

dp[l] [r] = min(dp[l] [r], dp[l] [k] + dp[k + 1] [r]);

### 代码：

```
void solve()
{
    string s;
    cin >> s;
    int n = s.size();
    s = ' ' + s;
    memset(dp, 0x3f3f3f3f, sizeof(dp));
    for (int i = 1; i <= n; ++i)
    {
        dp[i][i] = 1;
    }
    for (int len = 1; len <= n; ++len)
    {
        for (int l = 1, r = l + len; r <= n && l <= n; ++l, ++r)
        {
            if (s[l] == s[r])
            {
                dp[l][r] = min(dp[l][r - 1], dp[l + 1][r]);
            }
            else
            {

                for (int k = l; k < r; ++k)
                {
                    dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r]);
                }
            }
        }
    }
    cout << dp[1][n] << '\n';
} 
```

## J社会主义核心价值观

考点：白送分

答案：爱国



