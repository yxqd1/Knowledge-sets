# 环境安装

[IntelliJ IDEA 2023.3.2激活破解图文教程（亲测有用，永久激活） - 异常教程 (exception.site)](https://www.exception.site/essay/idea-reset-eval)



# 基本概念

- JDK、JRE、JVM的关系：
JDK：Java Development Kit，Java开发工具包
JRE: Java Runtime Environment，Java运行环境
JVM：Java Virtual Machine，Java虚拟机
JDK包含JRE，JRE包含JVM
- JDK版本选择
目前JDK1.8（也叫JDK8，注意不是JDK18）用得最多
- Java代码的编译运行流程
将Java源码编译成Java字节码。
使用JVM将Java字节码转化成机器码。
- JVM作用：跨平台、内存管理、安全。
- JSE、JEE、JME的区别
JSE: Java Standard Edition，标准版
JEE：Java Enterprise Edition，企业版
JME: Java Mirco Edition，移动版
Spring是JEE的轻量级替代品
SpringBoot是Spring + 自动化配置





# 语法

## 3.1 变量、运算符、输入与输出

类似于C#，Java的所有变量和函数都要定义在class中。

### 3.1.1 内置数据类型
```java
类型	字节数	举例
byte	1	123
short	2	12345
int	    4	123456789
long	8	1234567891011L
float	4	1.2F
double	8	1.2, 1.2D
boolean	1	true, false
char	2	‘A’
```
### 3.1.2 常量

使用final修饰：

final int N = 110;

### 3.1.3 类型转化

隐式转化是低精度向高精度转化

```java
显示转化：int x = (int)'A';
隐式转化：double x = 12, y = 4 * 3.3;
```
### 3.1.4 表达式

与C++、Python3类似：
```java
int a = 1, b = 2, c = 3;
int x = (a + b) * c;
x ++;
```
### 3.1.5 输入

方式1，效率较低，输入规模较小时使用。

```java
Scanner sc = new Scanner(System.in);
String str = sc.next();  // 读入下一个字符串
int x = sc.nextInt();  // 读入下一个整数
float y = sc.nextFloat();  // 读入下一个单精度浮点数
double z = sc.nextDouble();  // 读入下一个双精度浮点数
String line = sc.nextLine();  // 读入下一行

```
方式2，效率较高，输入规模较大时使用。**注意需要抛异常**。
```java
package com.yxc;

import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str = br.readLine();
        System.out.println(str);
    }
}
```

注意：字符串可进行转化

```
//单个输入
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int x = Integer.parseInt(br.readLine());  
//一行多个
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String[] strs = br.readLine().split(regex:" ");
int x=Integer.parseInt(strs[0]),y=Integer.parseInt(strs[1]);
```

### 3.1.6 输出

方式1，效率较低，输出规模较小时使用。

```java
System.out.println(123);  // 输出整数 + 换行
System.out.println("Hello World");  // 输出字符串 + 换行
System.out.print(123);  // 输出整数
System.out.print("yxc\n");  // 输出字符串
System.out.printf("%04d %.2f\n", 4, 123.456D);  // 格式化输出，float与double都用%f输出
```

方式2，效率较高，输出规模较大时使用。**注意需要抛异常**。

```java
package com.yxc;

import java.io.BufferedWriter;
import java.io.OutputStreamWriter;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        bw.write("Hello World\n");
        bw.flush();  // 需要手动刷新缓冲区
    }
}
```

## 3.2 判断语句

### 3.2.1 if-else语句

与C++、Python中类似。

例如：
```java

package com.yxc;

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int year = sc.nextInt();
        if (year % 100 == 0) {
            if (year % 400 == 0)
                System.out.printf("%d是闰年\n", year);
            else
                System.out.printf("%d不是闰年\n", year);
        } else {
            if (year % 4 == 0)
                System.out.printf("%d是闰年\n", year);
            else
                System.out.printf("%d不是闰年\n", year);
        }
    }
}
```
### 3.2.2 switch语句

与C++中类似。
```java
package com.yxc;

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int day = sc.nextInt();
        String name;
        switch (day) {
            case 1:
                name = "Monday";
                break;
            case 2:
                name = "Tuesday";
                break;
            case 3:
                name = "Wednesday";
                break;
            case 4:
                name = "Thursday";
                break;
            case 5:
                name = "Friday";
                break;
            case 6:
                name = "Saturday";
                break;
            case 7:
                name = "Sunday";
                break;
            default:
                name = "not valid";
        }
        System.out.println(name);
    }
}
```
### 3.2.3 逻辑运算符与条件表达式

与C++、Python类似。

例如：
```java
package com.yxc;

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int year = sc.nextInt();
        if (year % 100 != 0 && year % 4 == 0 || year % 400 == 0)
            System.out.printf("%d是闰年\n", year);
        else
            System.out.printf("%d不是闰年\n", year);
    }
}
```
## 3.3 循环语句

### 3.3.1 while循环

与C++、Python类似，例如：
```java
int i = 0;
while (i < 5) {
    System.out.println(i);
    i ++ ;
}
```
### 3.3.2 do while循环

与C++、Python类似，例如：
```java
int i = 0;
do {
    System.out.println(i);
    i ++ ;
} while (i < 5);
```
do while语句与while语句非常相似。唯一的区别是，do while语句限制性循环体后检查条件。不管条件的值如何，我们都要至少执行一次循环。



**do-while**：至少执行一次

**while**：至少执行0次

### 3.3.3 for循环

与C++、Python类似，例如：
```java
for (int i = 0; i < 5; i ++ ) {  // 普通循环
    System.out.println(i);
}
int[] a = {0, 1, 2, 3, 4};
for (int x: a) {  // forEach循环
    System.out.println(x);
}
//等价于,java也有auto
for(auto x:a){
    System.out.println(x);
}
```
## 3.4 数组

Java中的数组与C++中的数组类似。

### 3.4.1 初始化

与C++类似。
初始化定长数组，长度可以是变量，可以在初始化时赋值。
```java
int[] a = new int[5];  // 初始化长度为5的int数组，初始值为0，字符的时候默认为空
int n = 10;
float[] b = new float[n];  // 初始化长度为n的float数组，初始值为0.0F
char[] c = {'a', 'b', 'c'};  // 初始化长度为3的char数组，初始值为：'a', 'b', 'c'
char[] d = c;  // d与c地址相同，更改c中的元素，d中的元素也会改变，传引用，不是赋值，而是相等
```
### 3.4.2 数组元素的读取与写入

与C++类似。
```java
int[] a = new int[5];

for (int i = 0; i < 5; i++) {
    a[i] = i;
}
for (int i = 0; i < 5; i ++ ) {
    System.out.println(a[i] * a[i]);
}
```
### 3.4.3 多维数组

与C++类似。
```java
int[][] a = new int[2][3];
a[1][2] = 1;
int[][] b = {
        {1, 2, 3},
        {4, 5, 6},
};
System.out.println(a[1][2]);
System.out.println(b[0][1]);
```
### 3.4.4 常用API

- **属性length**：返回数组长度，注意不加小括号

- Arrays.sort(int[] a)：数组排序，可自定义排序

  ```java
  Integer[] a = {1,5,4,3,20};
  Arrays.sort(a,(x , y) -> y-x);//Arrays不支持var类型，要用对象
  System.out.print(Arrays.toString(a));
  ```

  

- Arrays.fill(int[] a, int val)：填充数组

- Arrays.toString()：将数组转化为字符串,一维

- Arrays.deepToString()：将多维数组转化为字符串

- 数组不可变长

## 3.5 字符串



### 3.5.1 String类

初始化：
```java
String a = "Hello World";
String b = "My name is";
String x = b;  // 存储到了相同地址,传引用
String c = b + "yxc";  // String可以通过加号拼接
String d = "My age is " + 18;  // int会被隐式转化成字符串"18"
String str = String.format("My age is %d", 18);  // 格式化字符串，类似于C++中的sprintf
String money_str = "123.45";
double money = Double.parseDouble(money_str);  // String转double
```

只读变量，不能修改，例如：
```java
String a = "Hello ";
a += "World";  // 会构造一个新的字符串
```
访问String中的字符：
```java
String str = "Hello World";
for (int i = 0; i < str.length(); i ++ ) {
    System.out.print(str.charAt(i));  // 只能读取，不能写入
}
```
常用API：

- length()：返回长度
- split(String regex)：分割字符串
- indexOf(char c)、indexOf(String str)：查找，找不到返回-1
- **equals()：判断两个字符串是否相等，注意不能直接用==，==比较地址值**  "M".equals();
- compareTo()：判断两个字符串的字典序大小，负数表示小于，0表示相等，正数表示大于
- startsWith()：判断是否以某个前缀开头
- endsWith()：判断是否以某个后缀结尾
- trim()：去掉首尾的空白字符
- toLowerCase()：全部用小写字符
- toUpperCase()：全部用大写字符
- replace(char oldChar, char newChar)：替换字符
- replace(String oldRegex, String newRegex)：替换字符串
- substring(int beginIndex, int endIndex)：返回[beginIndex, endIndex)中的子串//c++中是起点+长度

### 3.5.2 StringBuilder、StringBuffer

String不能被修改，如果打算修改字符串，可以使用StringBuilder和StringBuffer。

StringBuffer线程安全，速度较慢；StringBuilder线程不安全，速度较快。
```java
StringBuilder sb = new StringBuilder("Hello ");  // 初始化
sb.append("World");  // 拼接字符串
System.out.println(sb);

for (int i = 0; i < sb.length(); i ++ ) {
    sb.setCharAt(i, (char)(sb.charAt(i) + 1));  // 读取和写入字符
}

System.out.println(sb);
```
常用API：

- reverse()：翻转字符串

## 3.6 函数

Java的所有变量和函数都要定义在类中。

函数或变量前加static表示静态对象，类似于全局变量。（static的变量和方法，不同实例间共用，通过类名来访问，其他普通通过实例来访问
静态对象属于class，而不属于class的具体实例。

静态函数中只能调用静态函数和静态变量。

示例：
```java
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        System.out.println(max(3, 4));
        int[][] a = new int[3][4];
        fill(a, 3);
        System.out.println(Arrays.deepToString(a));

    int[][] b = getArray2d(2, 3, 5);
    System.out.println(Arrays.deepToString(b));
}

private static int max(int a, int b) {
    if (a > b) return a;
    return b;
}

private static void fill(int[][] a, int val) {
    for (int i = 0; i < a.length; i ++ )
        for (int j = 0; j < a[i].length; j ++ )
            a[i][j] = val;
}

private static int[][] getArray2d(int row, int col, int val) {
    int[][] a = new int[row][col];
    for (int i = 0; i < row; i ++ )
        for (int j = 0; j < col; j ++ )
            a[i][j] = val;
    return a;
}
}
```

例题

[823. 排列 - AcWing题库](https://www.acwing.com/problem/content/825/)

```java
import java.util.Scanner;
import java.io.*;

public class Main {
    private static int[] path;
    private static boolean[] st;
    private static int n;
    private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        path = new int[n];
        st = new boolean[n];
        dfs(0);
        bw.flush();
    }

    private static void dfs(int u) throws Exception {
        if (u == n) {
            for (int i = 0; i < n; i ++ )
                bw.write(path[i] + " ");
            bw.write("\n");
        } else {
            for (int i = 0; i < n; i ++ )
                if (!st[i]) {
                    st[i] = true;
                    path[u] = i + 1;
                    dfs(u + 1);
                    st[i] = false;
                }
        }
    }
}
```

## 3.7 类与接口

### 3.7.1 类

class与C++、Python类似。

#### 3.7.1.1 源文件声明规则

- 一个源文件中只能有一个public类。
- 一个源文件可以有多个非public类。
- 源文件的名称应该和public类的类名保持一致。
- 每个源文件中，先写package语句，再写import语句，最后定义类。

#### 3.7.1.2 类的定义

public: 所有对象均可以访问
private: 只有自己可以访问
```java
class Point {
    private int x;//私有变量
    private int y;

    public Point(int x, int y) {//构造函数
        this.x = x;
        this.y = y;
    }
    
    public void setX(int x) {//接口
        this.x = x;
    }
    
    public void setY(int y) {
        this.y = y;
    }
    
    public int getX() {
        return x;
    }
    
    public int getY() {
        return y;
    }
    
    public String toString() {
        return String.format("(%d, %d)", x, y);//字符串格式化
    }
}
```
#### 3.7.1.3 类的继承

每个类只能继承一个类。
```java
class ColorPoint extends Point {
    private String color;

    public ColorPoint(int x, int y, String color) {//必须要有的
        super(x, y);//super就是父类
        this.color = color;
    }
    
    public void setColor(String color) {//可以新建新的方法
        this.color = color;
    }
    
    public String toString() {//没有的可继承，有的会覆盖
        return String.format("(%d, %d, %s)", super.getX(), super.getY(), this.color);//私有的内容，子类依然不可访问
    }
}
```
#### 3.7.1.4 类的多态
多态，同一个类的实例，调用相同的函数，运行结果不同（eg.父类声明两个不同的子类，子类分别调用相同的函数，结果可能不同
```java
public class Main {
    public static void main(String[] args) {
        Point point = new Point(3, 4);
        Point colorPoint = new ColorPoint(1, 2, "red");

        // 多态，同一个类的实例，调用相同的函数，运行结果不同
        System.out.println(point.toString());
        System.out.println(colorPoint.toString());
    }
}
```
### 3.7.2 接口

interface与class类似。主要用来定义类中所需包含的函数。

接口也可以继承其他接口，一个类可以实现多个接口。

#### 3.7.2.1 接口的定义
```java
interface Role {
    public void greet();
    public void move();
    public int getSpeed();
}
```
#### 3.7.2.2 接口的继承

每个接口可以继承多个接口
```java
interface Hero extends Role {
    public void attack();
}
```
#### 3.7.2.3 接口的实现

每个类可以实现多个接口（必须实现接口的方法
```java
class Zeus implements Hero {
    private final String name = "Zeus";
    public void attack() {
        System.out.println(name + ": Attack!");
    }

    public void greet() {
        System.out.println(name + ": Hi!");
    }
    
    public void move() {
        System.out.println(name + ": Move!");
    }
    
    public int getSpeed() {
        return 10;
    }
    }
```
#### 3.7.2.4 接口的多态

（可以使用接口来声明不同的类，使用相同的方法但是具有不同的行为）（类似父类声明子类）

```java
class Athena implements Hero {
    private final String name = "Athena";
    public void attack() {
        System.out.println(name + ": Attack!");
}
public void greet() {
    System.out.println(name + ": Hi!");
}

public void move() {
    System.out.println(name + ": Move!");
}

public int getSpeed() {
    return 10;
}
}

public class Main {
    public static void main(String[] args) {
        Hero[] heros = {new Zeus(), new Athena()};
        for (Hero hero: heros) {
            hero.greet();
        }
    }
}
```
### 3.7.3 泛型

类似于C++的template，Java的类和接口也可以定义泛型，即同一套函数可以作用于不同的对象类型。（对象类型例如Double
泛型只能使用对象类型，不能使用基本变量类型。

### 3.7.4例题

#### 删除单个节点

```java
class Solution {
    public void deleteNode(ListNode node) {
        ListNode p = node.next;
        node.val = p.val;
        node.next = p.next;
    }
}
```

#### 翻转链表

迭代

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
}
```

递归

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode tail = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return tail;
    }
}
```

#### 删除重复节点

[29. 删除链表中重复的节点 - AcWing题库](https://www.acwing.com/problem/content/27/)

```
class Solution {
    public ListNode deleteDuplication(ListNode head) {
        //没有*的话看来也是指向，引用传递，相同地址
        //虚拟头结点
        ListNode hh = new ListNode(-1);
        hh.next=head;//赋的是地址，改动的是值
        ListNode cur=hh;
        //题意应该是连续重复的节点
        while(cur.next!=null){
            ListNode nn=cur.next;
            while(nn.next!=null && nn.next.val==cur.next.val)nn=nn.next;
            if(cur.next==nn)cur=nn;
            else cur.next=nn.next;//重复的全部删除
        }
        return hh.next;
    }
}
```

#### 862三元组排序

[862. 三元组排序 - AcWing题库](https://www.acwing.com/problem/content/864/)

```java
import java.util.Scanner;
import java.util.Arrays;
//要想实现Arrays里的sort，必须成为Comparable<E>的实现类
class Data implements Comparable<Data>{
    public int x;
    public double y;
    public String z;
    //利用构造函数赋值
    Data(int x,Double y,String z){
        this.x=x;
        this.y=y;
        this.z=z;
    }
    public int compareTo(Data t){
        return x-t.x;
    }
}

public class Main{
    
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Data[] a = new Data[n];
        for(int i=0;i<n;++i){
            //有数组之后，还要在申请一次，注意用构造函数
            a[i] = new Data(sc.nextInt(),sc.nextDouble(),sc.next());

        }
        Arrays.sort(a);
        // sort(a,0,n-1);
        for(int i=0;i<n;++i){
            // System.out.printf("%d",a[i].x);
            System.out.printf("%d %.2f %s\n",a[i].x,a[i].y,a[i].z);
        }
    }
   
}
```




## 3.8 常用容器


### 3.8.1 List

- 接口：java.util.List<>。

- 实现：

java.util.ArrayList<>：变长数组
java.util.LinkedList<>：双链表

- 函数：

add()：在末尾添加一个元素
clear()：清空
size()：返回长度
isEmpty()：是否为空
get(i)：获取第i个元素
set(i, val)：将第i个元素设置为val

### 3.8.2 栈

- 类：java.util.Stack<>

- 函数：

push()：压入元素
pop()：弹出栈顶元素，并返回栈顶元素
peek()：返回栈顶元素
size()：返回长度
empty()：栈是否为空
clear()：清空



### 3.8.3 队列

- 接口：java.util.Queue<>

- 实现：

java.util.LinkedList<>：双链表
java.util.PriorityQueue<>：优先队列     （默认小根堆
	默认是小根堆，大根堆写法：new PriorityQueue<>(Collections.reverseOrder())

-  函数：

add()：在队尾添加元素
remove()：删除并返回队头
isEmpty()：是否为空
size()：返回长度
peek()：返回队头
clear()：清空

### 3.8.4 Set

- 接口：java.util.Set<K>

- 实现：
java.util.HashSet<K>：哈希表
java.util.TreeSet<K>：平衡树

- 函数：

add()：添加元素
contains()：是否包含某个元素
remove()：删除元素
size()：返回元素数
isEmpty()：是否为空
clear()：清空
java.util.TreeSet多的函数：
	ceiling(key)：返回大于等于key的最小元素，不存在则返回null
	floor(key)：返回小于等于key的最大元素，不存在则返回null

### 3.8.5 Map

- 接口：java.util.Map<K, V>

- 实现：

java.util.HashMap<K, V>：哈希表
java.util.TreeMap<K, V>：平衡树

- 函数：

put(key, value)：添加关键字和其对应的值
get(key)：返回关键字对应的值
containsKey(key)：是否包含关键字
remove(key)：删除关键字
size()：返回元素数
isEmpty()：是否为空
clear()：清空
entrySet()：获取Map中的所有对象的集合
Map.Entry<K, V>：Map中的对象类型
	getKey()：获取关键字
	getValue()：获取值

java.util.TreeMap<K, V>多的函数：

​	ceilingEntry(key)：返回大于等于key的最小元素，不存在则返回null
​	floorEntry(key)：返回小于等于key的最大元素，不存在则返回null

# 小技巧

- Ctrl + Space：代码补全
- Ctrl + Alt + Space：第二次代码补全
- sout可以唤出System.out.println();
- souf可以唤出System.out.printf("");

- 多使用Scanner输入，printf输出，printf可以进行格式转化
- 快读快写，要抛出异常，快写要清空缓存区，不可与Scanner混用，绝对不行
- java赋值都是传引用，将右边的地址传到左边
- int是var，其对应Integer是其类对象，其他同理
- 每个类大多都放在一个文件里，不同根目录之间需要import使用
