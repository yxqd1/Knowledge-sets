# 3. 创建菜单与游戏页面

## 创建菜单页面

前端的html框架一般都从这里边找到，只需要修改替换相应内容就好

[Bootstrap v5 中文文档 · Bootstrap 是全球最受欢迎的 HTML、CSS 和 JS 前端工具库。 | Bootstrap 中文网 (bootcss.com)](https://v5.bootcss.com/)

## 个人总结

### 导航栏

首先在components里面建立NavBar.vue（导航栏

使用Bootstrap里面的模版

一般在view里写每个页面，建立文件夹和文件

接下来引入位置，在router里的index编辑

之后修改NavBar.vue里的地址并设置不刷新的方式
```java
<router-link class="dropdown-item" :to="{name:'user_bot_index'}">我的bot</router-link>
```

之后修改每一个views里的文件以及新建components.ContentField.vue控制内容格式

views里

```html
<template>
    <ContentField>
        对战
    </ContentField>
    
</template>

<script>
import ContentField from '../../components/ContentField.vue'
export default{
    components: {
        ContentField
    }
}
</script>

<style scoped>

</style>
```

ContentField.vue里

```html
<template>
    <div class="container">
        <div class="card">
            <div class="card-body">
                <slot></slot>
            </div>
        </div>
    </div>
</template>

<script>

</script>

<style scoped>
/* 控制内容格式 */
div.content-field{
    margin-top: 20px;

}
</style>
```

高亮设置，在NavBar文件的js部分加入
```javascript
<script>
import {useRoute} from 'vue-router'
import {computed} from 'vue'

export default{
  setup() {
    const route = useRoute();
    let route_name = computed(() => route.name)
    return {
      route_name
    }
  }
}
</script>
```


每个 每个导航栏菜单设置中 中加入

```
 <router-link :class="route_name == 'record_index'?'nav-link active' :'nav-link'" :to="{name:'record_index'}">对局列表</router-link>
```

### 游戏界面

基类，在asserts里新建images和scripts(代码脚本一般在asserts里)

scripts里新建

基类代码

```javascript
const AC_GAME_OBJECTS = []
export class AcGameObject {
    constructor() {
        AC_GAME_OBJECTS.push(this);
        this.timedelta = 0;
        this.has_called_start = false;

    }
    start() {//只执行一次

    }
    update() {//每一帧执行一次，除了第一帧之外

    }
    on_destroy() {//删除之前执行

    }
    destroy() {
        this.on_destroy();
        for(let i in AC_GAME_OBJECTS){
            const obj = AC_GAME_OBJECTS[i];
            if(obj==this){
                AC_GAME_OBJECTS.splice(i);
                break;
            }else {

            }
        }
    }
}
//上一次执行时间
let last_timestamp;
const step = timestamp  => {
    for(let obj of AC_GAME_OBJECTS){
        if(!obj.has_called_start){
            obj.start();
        }else {
            //时间间隔
            obj.timedelta=timestamp-last_timestamp;
            obj.update();
        }
    }
    last_timestamp=timestamp;
    requestAnimationFrame(step);
}
requestAnimationFrame(step)
```

地图代码

js

```javascript
import { AcGameObject } from "./AcGameObject";
import { Wall } from "./Wall";
export class GameMap extends AcGameObject{
    constructor(ctx,parent){
        super();
        this.ctx = ctx;
        this.parent = parent;
        this.L = 0;

        this.rows = 13;
        this.cols = 13;
        // 后边的墙覆盖前边的墙
        // 障碍物数量
        this.inner_walls_count=20;
        this.walls = [];
    }
    // 判断连通性
    check_connectivity(){

    }
    create_walls(){
        const g = [];
        for(let r=0;r<this.rows;r++){
            g[r]=[];
            for(let c=0;c<this.cols;c++){
                g[r][c]=false;
            }
        }
        //给四周加上障碍物
            // 竖着的
        for(let r=0;r<this.rows;r++){
            g[r][0]=g[r][this.cols-1]=true;
        }
            // 横着的
        for(let c=0;c<this.cols;c++){
            g[0][c]=g[this.rows-1][c]=true;

        }
        // 创造随机障碍物
        
        for(let i=0;i<this.inner_walls_count;i++){
            for(let j=0;j<1000;j++){
                let r = parseInt(Math.random()*this.rows);
                let c = parseInt(Math.random()*this.cols);
                if(g[r][c] || g[c][r])continue;
                if(r==1&&c==this.cols-2||(c==1&&r==this.rows-2))continue;
                g[r][c]=g[c][r]=true;
                break;
            }
        }
        // 检查是否可联通
        if(!this.check_connectivity())return false;
        for(let r=0;r<this.rows;r++){
            for(let c=0;c<this.cols;c++){
                if(g[r][c]){
                    this.walls.push(new Wall(r,c,this));
                }
            }
        }
        return true;
    }
    start(){
        for(let i=0;i<1000;i++){
            if(this.create_walls())break;
        }
    }
    update_size(){
        // 采取的都是相对大小
        this.L = parseInt(Math.min(this.parent.clientWidth / this.cols,this.parent.clientHeight / this.rows));
        this.ctx.canvas.width = this.L * this.cols;
        this.ctx.canvas.height = this.L * this.rows;

    }
    update(){
        this.update_size();
        this.render();

    }
    render(){
        // 图像规格
        const color_even = "#AAD751", color_odd = "#A2D149";
        for(let r = 0;r<this.rows;r++){
            for(let c = 0;c<this.cols;c++){
                if((r+c)%2==0){
                    this.ctx.fillStyle = color_even;
                }else{
                    this.ctx.fillStyle = color_odd;
                }
                // void ctx.fillRect(x, y, width, height); 
                this.ctx.fillRect(c * this.L, r * this.L,this.L,this.L);
            }
        }
    }
}
```

vue

```vue
<template>
    <div ref="parent" class="gamemap">
        <canvas ref="canvas">

        </canvas>
    </div>
</template>

<script>
import {GameMap} from "@/assets/scripts/GameMap";
import { ref , onMounted } from "vue";
export default{
    setup(){
        let parent = ref(null);
        let canvas = ref(null);
        onMounted(()=>{
            // 取值要用value
            new GameMap(canvas.value.getContext('2d'),parent.value)

        });
        return {
            parent,
            canvas
        }
    }
}
</script>

<style scoped>
    div.gamemap{
        width: 100%;
        height: 100%;
        /* 居中 */
        display: flex;
        /* 水平居中 */
        justify-content: center;
        /* 竖直居中 */
        align-items: center;
    }
</style>
```

pk专属界面控制代码（在components里

```vue
// 游戏区域
<template>
    <div class="playground">
      <GameMap />  
    </div>
</template>

<script>
import GameMap from './GameMap.vue';

export default{
    components:{
        GameMap,
    }
}
</script>

<style scoped>
/* css 样式 */
div.playground{
    width: 60vw;
    height: 70vh;
    background: lightblue;
    margin: 20px auto;
}
</style>
```

深度复制状态的方法

```vue
const copy_g=JSON.parse(JSON.stringify(g));
```

